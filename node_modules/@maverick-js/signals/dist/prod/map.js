import { effect, write, onDispose, read, isNotEqual, createComputation, createScope, scoped, dispose, compute } from './chunks/chunk-H5MBZ4KB.js';

// src/selector.ts
function selector(source) {
  let currentKey, nodes = /* @__PURE__ */ new Map();
  effect(() => {
    const newKey = source(), prev = nodes.get(currentKey), next = nodes.get(newKey);
    prev && write.call(prev, false);
    next && write.call(next, true);
    currentKey = newKey;
  });
  return function observeSelector(key) {
    let node = nodes.get(key);
    if (!node)
      nodes.set(key, node = new Selector(key, key === currentKey, nodes));
    node.s += 1;
    onDispose(node);
    return read.bind(node);
  };
}
function Selector(key, initialValue, nodes) {
  this.e = /** CLEAN */
  0;
  this.v = key;
  this.l = initialValue;
  this.s = 0;
  this.c = nodes;
  this.d = null;
}
var SelectorProto = Selector.prototype;
SelectorProto.r = isNotEqual;
SelectorProto.call = function() {
  this.s -= 1;
  if (!this.s) {
    this.c.delete(this.v);
    this.c = null;
  }
};

// src/map.ts
function computedMap(list, map, options) {
  return read.bind(
    createComputation(
      [],
      updateMap.bind({
        o: createScope(),
        h: 0,
        t: list,
        g: [],
        p: map,
        f: [],
        c: []
      }),
      options
    )
  );
}
function updateMap() {
  let i = 0, newItems = this.t() || [], mapper = () => this.p(read.bind(this.c[i]), i);
  scoped(() => {
    if (newItems.length === 0) {
      if (this.h !== 0) {
        dispose.call(this.o, false);
        this.g = [];
        this.f = [];
        this.h = 0;
        this.c = [];
      }
      return;
    }
    for (i = 0; i < newItems.length; i++) {
      if (i < this.g.length && this.g[i] !== newItems[i]) {
        write.call(this.c[i], newItems[i]);
      } else if (i >= this.g.length) {
        this.f[i] = compute(
          this.c[i] = createComputation(newItems[i], null),
          mapper,
          null
        );
      }
    }
    for (; i < this.g.length; i++)
      dispose.call(this.c[i]);
    this.h = this.c.length = newItems.length;
    this.g = newItems.slice(0);
    this.f = this.f.slice(0, this.h);
  }, this.o);
  return this.f;
}
function computedKeyedMap(list, map, options) {
  return read.bind(
    createComputation(
      [],
      updateKeyedMap.bind({
        o: createScope(),
        h: 0,
        t: list,
        g: [],
        p: map,
        f: [],
        c: []
      }),
      options
    )
  );
}
function updateKeyedMap() {
  const newItems = this.t() || [], indexed = this.p.length > 1;
  scoped(() => {
    let newLen = newItems.length, i, j, mapper = indexed ? () => this.p(newItems[j], read.bind(this.c[j])) : () => this.p(newItems[j]);
    if (newLen === 0) {
      if (this.h !== 0) {
        dispose.call(this.o, false);
        this.c = [];
        this.g = [];
        this.f = [];
        this.h = 0;
      }
    } else if (this.h === 0) {
      this.f = new Array(newLen);
      for (j = 0; j < newLen; j++) {
        this.g[j] = newItems[j];
        this.f[j] = compute(
          this.c[j] = createComputation(j, null),
          mapper,
          null
        );
      }
      this.h = newLen;
    } else {
      let start, end, newEnd, item, newIndices, newIndicesNext, temp = new Array(newLen), tempNodes = new Array(newLen);
      for (start = 0, end = Math.min(this.h, newLen); start < end && this.g[start] === newItems[start]; start++)
        ;
      for (end = this.h - 1, newEnd = newLen - 1; end >= start && newEnd >= start && this.g[end] === newItems[newEnd]; end--, newEnd--) {
        temp[newEnd] = this.f[end];
        tempNodes[newEnd] = this.c[end];
      }
      newIndices = /* @__PURE__ */ new Map();
      newIndicesNext = new Array(newEnd + 1);
      for (j = newEnd; j >= start; j--) {
        item = newItems[j];
        i = newIndices.get(item);
        newIndicesNext[j] = i === void 0 ? -1 : i;
        newIndices.set(item, j);
      }
      for (i = start; i <= end; i++) {
        item = this.g[i];
        j = newIndices.get(item);
        if (j !== void 0 && j !== -1) {
          temp[j] = this.f[i];
          tempNodes[j] = this.c[i];
          j = newIndicesNext[j];
          newIndices.set(item, j);
        } else
          dispose.call(this.c[i]);
      }
      for (j = start; j < newLen; j++) {
        if (j in temp) {
          this.f[j] = temp[j];
          this.c[j] = tempNodes[j];
          write.call(this.c[j], j);
        } else {
          this.f[j] = compute(
            this.c[j] = createComputation(j, null),
            mapper,
            null
          );
        }
      }
      this.f = this.f.slice(0, this.h = newLen);
      this.g = newItems.slice(0);
    }
  }, this.o);
  return this.f;
}

export { computedKeyedMap, computedMap, selector };
