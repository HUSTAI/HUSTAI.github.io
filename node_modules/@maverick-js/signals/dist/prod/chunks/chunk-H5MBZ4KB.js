// src/symbols.ts
var SCOPE = Symbol(0);

// src/core.ts
var scheduledEffects = false;
var runningEffects = false;
var currentScope = null;
var currentObserver = null;
var currentObservers = null;
var currentObserversIndex = 0;
var effects = [];
var NOOP = () => {
};
var STATE_CLEAN = 0;
var STATE_CHECK = 1;
var STATE_DIRTY = 2;
var STATE_DISPOSED = 3;
function flushEffects() {
  scheduledEffects = true;
  queueMicrotask(runEffects);
}
function runEffects() {
  if (!effects.length) {
    scheduledEffects = false;
    return;
  }
  runningEffects = true;
  for (let i = 0; i < effects.length; i++) {
    if (effects[i].e !== STATE_CLEAN)
      runTop(effects[i]);
  }
  effects = [];
  scheduledEffects = false;
  runningEffects = false;
}
function runTop(node) {
  let ancestors = [node];
  while (node = node[SCOPE]) {
    if (node.n && node.e !== STATE_CLEAN)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    updateCheck(ancestors[i]);
  }
}
function root(init) {
  const scope = createScope();
  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);
}
function peek(fn) {
  return compute(currentScope, fn, null);
}
function untrack(fn) {
  return compute(null, fn, null);
}
function tick() {
  if (!runningEffects)
    runEffects();
}
function getScope() {
  return currentScope;
}
function scoped(run, scope) {
  try {
    return compute(scope, run, null);
  } catch (error) {
    handleError(scope, error);
    return;
  }
}
function getContext(key, scope = currentScope) {
  return scope?.m[key];
}
function setContext(key, value, scope = currentScope) {
  if (scope)
    scope.m = { ...scope.m, [key]: value };
}
function onError(handler) {
  if (!currentScope)
    return;
  currentScope.j = [handler, ...currentScope.j];
}
function onDispose(disposable) {
  if (!disposable || !currentScope)
    return disposable || NOOP;
  const node = currentScope;
  if (!node.a) {
    node.a = disposable;
  } else if (Array.isArray(node.a)) {
    node.a.push(disposable);
  } else {
    node.a = [node.a, disposable];
  }
  return function removeDispose() {
    if (node.e === STATE_DISPOSED)
      return;
    disposable.call(null);
    if (isFunction(node.a)) {
      node.a = null;
    } else if (Array.isArray(node.a)) {
      node.a.splice(node.a.indexOf(disposable), 1);
    }
  };
}
function dispose(self = true) {
  if (this.e === STATE_DISPOSED)
    return;
  let head = self ? this.k ?? this[SCOPE] : this, current = this.i;
  while (current && current[SCOPE] === this) {
    dispose.call(current, true);
    disposeNode(current);
    current = current.i;
  }
  if (self)
    disposeNode(this);
  if (current)
    current.k = !self ? this : this.k;
  if (head)
    head.i = current;
}
function disposeNode(node) {
  node.e = STATE_DISPOSED;
  if (node.a)
    emptyDisposal(node);
  if (node.b)
    removeSourceObservers(node, 0);
  if (node.k)
    node.k.i = null;
  node[SCOPE] = null;
  node.b = null;
  node.d = null;
  node.k = null;
  node.m = null;
  node.j = null;
}
function emptyDisposal(scope) {
  try {
    if (Array.isArray(scope.a)) {
      for (let i = 0; i < scope.a.length; i++) {
        const callable = scope.a[i];
        callable.call(callable);
      }
    } else {
      scope.a.call(scope.a);
    }
    scope.a = null;
  } catch (error) {
    handleError(scope, error);
  }
}
function compute(scope, compute2, observer) {
  const prevScope = currentScope, prevObserver = currentObserver;
  currentScope = scope;
  currentObserver = observer;
  try {
    return compute2.call(scope);
  } finally {
    currentScope = prevScope;
    currentObserver = prevObserver;
  }
}
function handleError(scope, error) {
  if (!scope)
    throw error;
  let i = 0, len = scope.j.length, coercedError = coerceError(error);
  for (i = 0; i < len; i++) {
    try {
      scope.j[i](coercedError);
      break;
    } catch (error2) {
      coercedError = coerceError(error2);
    }
  }
  if (i === len)
    throw coercedError;
}
function coerceError(error) {
  return error instanceof Error ? error : Error(JSON.stringify(error));
}
function read() {
  if (this.e === STATE_DISPOSED)
    return this.l;
  if (currentObserver && !this.n) {
    if (!currentObservers && currentObserver.b && currentObserver.b[currentObserversIndex] == this) {
      currentObserversIndex++;
    } else if (!currentObservers)
      currentObservers = [this];
    else
      currentObservers.push(this);
  }
  if (this.q)
    updateCheck(this);
  return this.l;
}
function write(newValue) {
  const value = isFunction(newValue) ? newValue(this.l) : newValue;
  if (this.r(this.l, value)) {
    this.l = value;
    if (this.d) {
      for (let i = 0; i < this.d.length; i++) {
        notify(this.d[i], STATE_DIRTY);
      }
    }
  }
  return this.l;
}
var ScopeNode = function Scope() {
  this[SCOPE] = null;
  this.i = null;
  this.k = null;
  if (currentScope)
    currentScope.append(this);
};
var ScopeProto = ScopeNode.prototype;
ScopeProto.m = {};
ScopeProto.j = [];
ScopeProto.q = null;
ScopeProto.a = null;
ScopeProto.append = function appendScope(scope) {
  scope[SCOPE] = this;
  scope.k = this;
  scope.m = this.m;
  scope.j = this.j;
  if (this.i)
    this.i.k = scope;
  scope.i = this.i;
  this.i = scope;
};
function createScope() {
  return new ScopeNode();
}
var ComputeNode = function Computation(initialValue, compute2, options) {
  ScopeNode.call(this);
  this.e = compute2 ? STATE_DIRTY : STATE_CLEAN;
  this.u = false;
  this.n = false;
  this.b = null;
  this.d = null;
  this.l = initialValue;
  if (compute2)
    this.q = compute2;
  if (options && options.dirty)
    this.r = options.dirty;
};
var ComputeProto = ComputeNode.prototype;
Object.setPrototypeOf(ComputeProto, ScopeProto);
ComputeProto.r = isNotEqual;
ComputeProto.call = read;
function createComputation(initialValue, compute2, options) {
  return new ComputeNode(initialValue, compute2, options);
}
function isNotEqual(a, b) {
  return a !== b;
}
function isFunction(value) {
  return typeof value === "function";
}
function updateCheck(node) {
  if (node.e === STATE_CHECK) {
    for (let i = 0; i < node.b.length; i++) {
      updateCheck(node.b[i]);
      if (node.e === STATE_DIRTY) {
        break;
      }
    }
  }
  if (node.e === STATE_DIRTY)
    update(node);
  else
    node.e = STATE_CLEAN;
}
function cleanup(node) {
  if (node.i && node.i[SCOPE] === node)
    dispose.call(node, false);
  if (node.a)
    emptyDisposal(node);
  node.j = node[SCOPE]?.j || [];
}
function update(node) {
  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;
  currentObservers = null;
  currentObserversIndex = 0;
  try {
    cleanup(node);
    const result = compute(node, node.q, node);
    if (currentObservers) {
      if (node.b)
        removeSourceObservers(node, currentObserversIndex);
      if (node.b && currentObserversIndex > 0) {
        node.b.length = currentObserversIndex + currentObservers.length;
        for (let i = 0; i < currentObservers.length; i++) {
          node.b[currentObserversIndex + i] = currentObservers[i];
        }
      } else {
        node.b = currentObservers;
      }
      let source;
      for (let i = currentObserversIndex; i < node.b.length; i++) {
        source = node.b[i];
        if (!source.d)
          source.d = [node];
        else
          source.d.push(node);
      }
    } else if (node.b && currentObserversIndex < node.b.length) {
      removeSourceObservers(node, currentObserversIndex);
      node.b.length = currentObserversIndex;
    }
    if (!node.n && node.u) {
      write.call(node, result);
    } else {
      node.l = result;
      node.u = true;
    }
  } catch (error) {
    handleError(node, error);
    if (node.e === STATE_DIRTY) {
      cleanup(node);
      if (node.b)
        removeSourceObservers(node, 0);
    }
    return;
  }
  currentObservers = prevObservers;
  currentObserversIndex = prevObserversIndex;
  node.e = STATE_CLEAN;
}
function notify(node, state) {
  if (node.e >= state)
    return;
  if (node.n && node.e === STATE_CLEAN) {
    effects.push(node);
    if (!scheduledEffects)
      flushEffects();
  }
  node.e = state;
  if (node.d) {
    for (let i = 0; i < node.d.length; i++) {
      notify(node.d[i], STATE_CHECK);
    }
  }
}
function removeSourceObservers(node, index) {
  let source, swap;
  for (let i = index; i < node.b.length; i++) {
    source = node.b[i];
    if (source.d) {
      swap = source.d.indexOf(node);
      source.d[swap] = source.d[source.d.length - 1];
      source.d.pop();
    }
  }
}

// src/signals.ts
function signal(initialValue, options) {
  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);
  signal2.set = write.bind(node);
  return signal2;
}
function isReadSignal(fn) {
  return isFunction(fn);
}
function computed(compute2, options) {
  return read.bind(
    createComputation(
      options?.initial,
      compute2,
      options
    )
  );
}
function effect(effect2, options) {
  const signal2 = createComputation(
    null,
    function runEffect() {
      let effectResult = effect2();
      isFunction(effectResult) && onDispose(effectResult);
      return null;
    },
    void 0
  );
  signal2.n = true;
  update(signal2);
  return dispose.bind(signal2, true);
}
function readonly(signal2) {
  return () => signal2();
}
function isWriteSignal(fn) {
  return isReadSignal(fn) && "set" in fn;
}

export { SCOPE, compute, computed, createComputation, createScope, dispose, effect, getContext, getScope, isFunction, isNotEqual, isReadSignal, isWriteSignal, onDispose, onError, peek, read, readonly, root, scoped, setContext, signal, tick, untrack, write };
