{"version":3,"file":"index.js","sources":["../../src/node/utils.ts","../../src/node/category.ts","../../src/node/compact.ts","../../src/node/type.ts","../../src/node/plugin.ts"],"sourcesContent":["import type { App, Page } from \"@vuepress/core\";\nimport { Logger, keys } from \"vuepress-shared/node\";\n\nimport type { PageMap } from \"./typings/index.js\";\n\nexport const PLUGIN_NAME = \"vuepress-plugin-blog2\";\n\nexport const logger = new Logger(PLUGIN_NAME);\n\nexport const getPageMap = (\n  { options, pages }: App,\n  filter: (page: Page) => boolean\n): PageMap => {\n  const localePaths = keys(options.locales);\n  const pageMap: PageMap = {};\n\n  // initialize pageMap\n  // extra check to ensure at least one locale exists\n  (localePaths.length ? localePaths : [\"/\"]).forEach((path) => {\n    pageMap[path] = [];\n  });\n\n  pages.filter(filter).forEach((page) => {\n    if (page.path !== \"/404.html\") pageMap[page.pathLocale].push(page);\n  });\n\n  return pageMap;\n};\n","import type { App, Page } from \"@vuepress/core\";\nimport { createPage } from \"@vuepress/core\";\nimport { colors } from \"@vuepress/utils\";\nimport { isFunction, isString, removeLeadingSlash } from \"vuepress-shared/node\";\n\nimport type { BlogOptions } from \"./options.js\";\nimport type { PageMap } from \"./typings/index.js\";\nimport { logger } from \"./utils.js\";\nimport type { CategoryMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory)\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n  });\n\n`;\n\nexport const prepareCategory = (\n  app: App,\n  { category, slugify }: Required<Pick<BlogOptions, \"category\" | \"slugify\">>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> =>\n  Promise.all(\n    category.map(\n      async (\n        {\n          key,\n          getter,\n          sorter = (): number => -1,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n          itemPath = \"/:key/:name/\",\n          itemLayout = \"Layout\",\n          itemFrontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key.length) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`category[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        if (!isFunction(getter)) {\n          logger.error(\n            `Invalid ${colors.magenta(\"getter\")} option in \"${colors.cyan(\n              `category[${index}]`\n            )}\", it should be a function!`\n          );\n\n          return null;\n        }\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} category.\\n`);\n\n        const categoryMap: CategoryMap = {};\n        const pageKeys: string[] = [];\n        const getItemPath = isFunction(itemPath)\n          ? itemPath\n          : isString(itemPath)\n          ? (name: string): string =>\n              itemPath\n                .replace(/:key/g, slugify(key))\n                .replace(/:name/g, slugify(name))\n          : (): null => null;\n\n        for (const localePath in pageMap) {\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              path.replace(/:key/g, slugify(key))\n            )}`;\n\n            const mainPage = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"category\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) {\n              app.pages.push(mainPage);\n            } else if (app.pages[index].key !== mainPage.key) {\n              app.pages.splice(index, 1, mainPage);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n            pageKeys.push(mainPage.key);\n\n            categoryMap[localePath] = {\n              path: mainPage.path,\n              map: {},\n            };\n          } else {\n            categoryMap[localePath] = {\n              path: \"\",\n              map: {},\n            };\n          }\n\n          const { map } = categoryMap[localePath];\n          const pageMapStore: Record<string, Page[]> = {};\n\n          for (const page of pageMap[localePath]) {\n            const categories = getter(page);\n\n            for (const category of categories) {\n              if (!map[category]) {\n                const itemPath = getItemPath(category);\n\n                if (itemPath) {\n                  const pagePath = `${localePath}${removeLeadingSlash(\n                    itemPath\n                  )}`;\n\n                  const page = await createPage(app, {\n                    path: `${localePath}${removeLeadingSlash(itemPath)}`,\n                    frontmatter: {\n                      ...itemFrontmatter(category, localePath),\n                      blog: {\n                        type: \"category\",\n                        name: category,\n                        key,\n                      },\n                      layout: itemLayout,\n                    },\n                  });\n\n                  const index = app.pages.findIndex(\n                    ({ path }) => path === pagePath\n                  );\n\n                  if (index === -1) {\n                    app.pages.push(page);\n                  } else if (app.pages[index].key !== page.key) {\n                    app.pages.splice(index, 1, page);\n\n                    if (init)\n                      logger.warn(`Overriding existed path ${pagePath}`);\n                  }\n\n                  pageKeys.push(page.key);\n\n                  map[category] = {\n                    path: page.path,\n                    keys: [],\n                  };\n                } else {\n                  map[category] = {\n                    path: \"\",\n                    keys: [],\n                  };\n                }\n\n                pageMapStore[category] = [];\n              }\n\n              pageMapStore[category].push(page);\n            }\n          }\n\n          for (const category in pageMapStore)\n            map[category].keys = pageMapStore[category]\n              .sort(sorter)\n              .map(({ key }) => key);\n\n          if (app.env.isDebug) {\n            let infoMessage = `Route ${localePath} in ${key} category:\\n`;\n\n            for (const category in map) {\n              const { path, keys } = map[category];\n\n              infoMessage += `name: ${category}; ${\n                path ? `path: ${path}; ` : \"\"\n              }items: ${keys.length}\\n`;\n            }\n\n            logger.info(infoMessage);\n          }\n        }\n\n        return {\n          key,\n          map: categoryMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, CategoryMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: CategoryMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/category.js`,\n      `\\\nexport const categoryMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All categories generated.\");\n\n    return keys;\n  });\n","import { colors } from \"@vuepress/utils\";\n\nimport type { BlogOptions } from \"./options.js\";\nimport { logger } from \"./utils.js\";\n\n/** @deprecated */\nexport const convertOptions = (\n  options: BlogOptions & {\n    /** @deprecated */\n    customElement?: (tagName: string) => boolean;\n  }\n): void => {\n  // v2 changes\n  if (\"customElement\" in options) {\n    logger.warn(\n      `${colors.magenta(\n        \"customElement\"\n      )} is deprecated, please use ${colors.magenta(\"isCustomElement\")}.`\n    );\n\n    options[\"isCustomElement\"] = options[\"customElement\"];\n  }\n};\n","import type { App } from \"@vuepress/core\";\nimport { createPage } from \"@vuepress/core\";\nimport { colors } from \"@vuepress/utils\";\nimport { isString, removeLeadingSlash } from \"vuepress-shared/node\";\n\nimport type { BlogOptions } from \"./options.js\";\nimport type { PageMap } from \"./typings/index.js\";\nimport { logger } from \"./utils.js\";\nimport type { TypeMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogType)\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n  });\n`;\n\nexport const prepareType = (\n  app: App,\n  { type, slugify }: Required<Pick<BlogOptions, \"type\" | \"slugify\">>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> =>\n  Promise.all(\n    type.map(\n      async (\n        {\n          key,\n          sorter = (): number => -1,\n          filter = (): boolean => true,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key.length) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`type[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        const typeMap: TypeMap = {};\n        const pageKeys: string[] = [];\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} type.\\n`);\n\n        for (const localePath in pageMap) {\n          const keys = pageMap[localePath]\n            .filter(filter)\n            .sort(sorter)\n            .map(({ key }) => key);\n\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              slugify(path.replace(/:key/g, key))\n            )}`;\n\n            const page = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"type\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) {\n              app.pages.push(page);\n            } else if (app.pages[index].key !== page.key) {\n              app.pages.splice(index, 1, page);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n\n            pageKeys.push(page.key);\n\n            typeMap[localePath] = { path: page.path, keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: path: ${page.path}; items: ${keys.length}\\n`\n              );\n          } else {\n            typeMap[localePath] = { path: \"\", keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: items: ${keys.length}\\n`\n              );\n          }\n        }\n\n        return {\n          key,\n          map: typeMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, TypeMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: TypeMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/type.js`,\n      `\\\nexport const typeMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All types generated.\");\n\n    return keys;\n  });\n","import type { PluginFunction } from \"@vuepress/core\";\nimport {\n  preparePageComponent,\n  preparePageData,\n  preparePagesComponents,\n  preparePagesData,\n  preparePagesRoutes,\n} from \"@vuepress/core\";\nimport { watch } from \"chokidar\";\nimport { checkVersion, getPageExcerpt } from \"vuepress-shared/node\";\n\nimport { prepareCategory } from \"./category.js\";\nimport { convertOptions } from \"./compact.js\";\nimport type { BlogOptions, PageWithExcerpt } from \"./options.js\";\nimport { prepareType } from \"./type.js\";\nimport { PLUGIN_NAME, getPageMap, logger } from \"./utils.js\";\n\nexport const blogPlugin =\n  (options: BlogOptions, legacy = true): PluginFunction =>\n  (app) => {\n    // TODO: Remove this in v2 stable\n    if (legacy)\n      convertOptions(options as BlogOptions & Record<string, unknown>);\n\n    checkVersion(app, PLUGIN_NAME, \"2.0.0-beta.63\");\n\n    const {\n      getInfo = (): Record<string, never> => ({}),\n      filter = (page): boolean =>\n        Boolean(page.filePathRelative) && !page.frontmatter[\"home\"],\n      metaScope = \"_blog\",\n      excerpt = true,\n      excerptSeparator = \"<!-- more -->\",\n      excerptLength = 300,\n      excerptFilter = filter,\n      isCustomElement = (): boolean => false,\n      category = [],\n      type = [],\n      slugify = (name: string): string =>\n        name\n          .replace(/[ _]/g, \"-\")\n          .replace(/[:?*|\\\\/<>]/g, \"\")\n          .toLowerCase(),\n    } = options;\n\n    let generatePageKeys: string[] = [];\n\n    if (app.env.isDebug) logger.info(\"Options:\", options);\n\n    return {\n      name: PLUGIN_NAME,\n\n      define: () => ({\n        BLOG_META_SCOPE: metaScope,\n      }),\n\n      extendsPage: (page): void => {\n        // generate page excerpt\n        if (excerpt && excerptFilter(page))\n          (<PageWithExcerpt>page).data[\"excerpt\"] = getPageExcerpt(app, page, {\n            isCustomElement,\n            excerptSeparator,\n            excerptLength,\n          });\n      },\n\n      onInitialized: (app): Promise<void> => {\n        const pageMap = getPageMap(app, filter);\n\n        // inject meta information\n        app.pages.filter(filter).forEach((page) => {\n          page.routeMeta = {\n            ...(metaScope === \"\"\n              ? getInfo(page)\n              : { [metaScope]: getInfo(page) }),\n            ...page.routeMeta,\n          };\n        });\n\n        return Promise.all([\n          prepareCategory(app, { category, slugify }, pageMap, true).then(\n            (pageKeys) => {\n              generatePageKeys.push(...pageKeys);\n            }\n          ),\n          prepareType(app, { type, slugify }, pageMap, true).then(\n            (pageKeys) => {\n              generatePageKeys.push(...pageKeys);\n            }\n          ),\n        ]).then(() => {\n          if (app.env.isDebug) logger.info(\"temp file generated\");\n        });\n      },\n\n      onWatched: (app, watchers): void => {\n        const hotReload =\n          \"hotReload\" in options ? options.hotReload : app.env.isDebug;\n\n        if (hotReload) {\n          const pageDataWatcher = watch(\"pages/**/*.js\", {\n            cwd: app.dir.temp(),\n            ignoreInitial: true,\n          });\n\n          const updateBlog = (): Promise<void> => {\n            const newGeneratedPageKeys: string[] = [];\n\n            const pageMap = getPageMap(app, filter);\n\n            return Promise.all([\n              prepareCategory(app, { category, slugify }, pageMap).then(\n                (pageKeys) => {\n                  newGeneratedPageKeys.push(...pageKeys);\n                }\n              ),\n              prepareType(app, { type, slugify }, pageMap).then((pageKeys) => {\n                newGeneratedPageKeys.push(...pageKeys);\n              }),\n            ]).then(async () => {\n              const pagesToBeRemoved = generatePageKeys.filter(\n                (key) => !newGeneratedPageKeys.includes(key)\n              );\n              const pagesToBeAdded = newGeneratedPageKeys.filter(\n                (key) => !generatePageKeys.includes(key)\n              );\n\n              if (pagesToBeAdded.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `New pages detected: ${pagesToBeAdded.toString()}`\n                  );\n\n                // prepare page files\n                await Promise.all(\n                  pagesToBeAdded.map(async (pageKey) => {\n                    await preparePageComponent(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                    await preparePageData(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                  })\n                );\n              }\n\n              // remove pages\n              if (pagesToBeRemoved.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `Removing following pages: ${pagesToBeRemoved.toString()}`\n                  );\n\n                pagesToBeRemoved.forEach((pageKey) => {\n                  app.pages.splice(\n                    app.pages.findIndex(({ key }) => key === pageKey),\n                    1\n                  );\n                });\n              }\n\n              // prepare pages entry\n              if (pagesToBeRemoved.length || pagesToBeAdded.length) {\n                await preparePagesComponents(app);\n                await preparePagesData(app);\n                await preparePagesRoutes(app);\n              }\n\n              generatePageKeys = newGeneratedPageKeys;\n\n              if (app.env.isDebug) logger.info(\"temp file updated\");\n            });\n          };\n\n          pageDataWatcher.on(\"add\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"change\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"unlink\", () => {\n            void updateBlog();\n          });\n\n          watchers.push(pageDataWatcher);\n        }\n      },\n    };\n  };\n"],"names":["PLUGIN_NAME","logger","Logger","getPageMap","options","pages","filter","localePaths","keys","pageMap","path","page","HMR_CODE","prepareCategory","app","category","slugify","init","key","getter","sorter","layout","frontmatter","itemPath","itemLayout","itemFrontmatter","index","isString","colors","isFunction","categoryMap","pageKeys","getItemPath","name","localePath","pagePath","removeLeadingSlash","mainPage","createPage","map","pageMapStore","categories","infoMessage","result","finalMap","item","convertOptions","prepareType","type","typeMap","blogPlugin","legacy","checkVersion","getInfo","metaScope","excerpt","excerptSeparator","excerptLength","excerptFilter","isCustomElement","generatePageKeys","getPageExcerpt","watchers","pageDataWatcher","watch","updateBlog","newGeneratedPageKeys","pagesToBeRemoved","pagesToBeAdded","pageKey","preparePageComponent","preparePageData","preparePagesComponents","preparePagesData","preparePagesRoutes"],"mappings":"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"}