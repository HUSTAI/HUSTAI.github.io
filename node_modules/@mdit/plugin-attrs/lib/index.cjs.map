{"version":3,"file":"index.cjs","sources":["../src/attrs.ts","../src/utils.ts","../src/helper.ts","../src/rules/rules.ts","../src/rules/test.ts","../src/plugin.ts"],"sourcesContent":["import type Token from \"markdown-it/lib/token.js\";\n\nimport { type MarkdownItAttrsOptions } from \"./options.js\";\n\nexport type Attr = [key: string, value: string];\n\n// not tab, line feed, form feed, space, solidus, greater than sign, quotation mark, apostrophe and equals sign\nexport const ALLOWED_KEY_CHARS = /[^\\t\\n\\f />\"'=]/;\nexport const PAIR_SEPARATOR = \" \";\nexport const KEY_SEPARATOR = \"=\";\nexport const CLASS_MARKER = \".\";\nexport const ID_MARKER = \"#\";\n\nexport const getAttrs = (\n  str: string,\n  start: number,\n  { left, right, allowed }: Required<Omit<MarkdownItAttrsOptions, \"rule\">>\n): Attr[] => {\n  let key = \"\";\n  let value = \"\";\n  let parsingKey = true;\n  let valueInsideQuotes = false;\n\n  const attrs: Attr[] = [];\n\n  // read inside {}\n  // start + left delimiter length to avoid beginning {\n  // breaks when } is found or end of string\n  for (let index = start + left.length; index < str.length; index++) {\n    if (str.slice(index, index + right.length) === right) {\n      if (key !== \"\") attrs.push([key, value]);\n      break;\n    }\n\n    const char = str.charAt(index);\n\n    // switch to reading value if equal sign\n    if (char === KEY_SEPARATOR && parsingKey) {\n      parsingKey = false;\n      continue;\n    }\n\n    // {.class} {..css-module}\n    if (char === CLASS_MARKER && key === \"\") {\n      if (str.charAt(index + 1) === CLASS_MARKER) {\n        key = \"css-module\";\n        index += 1;\n      } else {\n        key = \"class\";\n      }\n\n      parsingKey = false;\n      continue;\n    }\n\n    // {#id}\n    if (char === ID_MARKER && key === \"\") {\n      key = \"id\";\n      parsingKey = false;\n      continue;\n    }\n\n    // {value=\"inside quotes\"}\n    if (char === '\"' && value === \"\") {\n      valueInsideQuotes = true;\n      continue;\n    }\n\n    if (char === '\"' && valueInsideQuotes) {\n      valueInsideQuotes = false;\n      continue;\n    }\n\n    // read next key/value pair\n    if (char === PAIR_SEPARATOR && !valueInsideQuotes) {\n      if (key === \"\")\n        // beginning or ending space: { .red } vs {.red}\n        continue;\n\n      attrs.push([key, value]);\n      key = \"\";\n      value = \"\";\n      parsingKey = true;\n\n      continue;\n    }\n\n    // continue if character not allowed\n    if (parsingKey && char.search(ALLOWED_KEY_CHARS) === -1) continue;\n\n    // no other conditions met; append to key/value\n    if (parsingKey) {\n      key += char;\n      continue;\n    }\n\n    value += char;\n  }\n\n  return allowed.length\n    ? attrs.filter(([attr]) =>\n        allowed.some((item) =>\n          item instanceof RegExp ? item.test(attr) : item === attr\n        )\n      )\n    : attrs;\n};\n\nexport const addAttrs = (attrs: Attr[], token: Token | null): void => {\n  if (token)\n    attrs.forEach((attrItem) => {\n      const [key, value] = attrItem;\n\n      if (key === \"class\") token.attrJoin(\"class\", value);\n      else if (key === \"css-module\") token.attrJoin(\"css-module\", value);\n      else token.attrPush(attrItem);\n    });\n};\n","/**\n * Get amount item of array. Supports negative amount, where -1 is last\n * element in array.\n */\nexport const getElements = <T>(arr: T[], amount: number): T =>\n  amount >= 0 ? arr[amount] : arr[arr.length + amount];\n\n/**\n * Escapes special characters in string s such that the string\n * can be used in `new RegExp`. For example \"[\" becomes \"\\\\[\".\n */\nexport const escapeRegExp = (regexp: string): string =>\n  regexp.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isArrayOfFunctions = (arr: unknown): arr is Function[] =>\n  Array.isArray(arr) &&\n  Boolean(arr.length) &&\n  arr.every((item) => typeof item === \"function\");\n\nexport const isArrayOfObjects = (arr: unknown): arr is object[] =>\n  Array.isArray(arr) &&\n  Boolean(arr.length) &&\n  arr.every((item) => typeof item === \"object\");\n","import type Token from \"markdown-it/lib/token.js\";\n\nimport { escapeRegExp } from \"./utils.js\";\n\nexport const hasDelimiters =\n  (\n    where: \"start\" | \"end\" | \"only\",\n    left: string,\n    right: string\n  ): ((content: string) => boolean) =>\n  (content: string): boolean => {\n    const leftLength = left.length;\n    const rightLength = right.length;\n    // we need minimum three chars, for example {b}\n    const minCurlyLength = leftLength + 1 + rightLength;\n\n    if (\n      !content ||\n      typeof content !== \"string\" ||\n      content.length < minCurlyLength\n    )\n      return false;\n\n    const validCurlyLength = (curly: string): boolean => {\n      const isClass = curly.charAt(leftLength) === \".\";\n      const isId = curly.charAt(leftLength) === \"#\";\n\n      return isClass || isId\n        ? curly.length >= minCurlyLength + 1\n        : curly.length >= minCurlyLength;\n    };\n\n    let start, end, slice, nextChar;\n    const rightDelimiterMinimumShift = minCurlyLength - rightLength;\n\n    switch (where) {\n      case \"start\":\n        // first char should be {, } found in char 2 or more\n        slice = content.slice(0, leftLength);\n        start = slice === left ? 0 : -1;\n        end =\n          start === -1\n            ? -1\n            : content.indexOf(right, rightDelimiterMinimumShift);\n        // check if next character is not one of the delimiters\n        nextChar = content.charAt(end + rightLength);\n        if (nextChar && right.indexOf(nextChar) !== -1) end = -1;\n        break;\n\n      case \"end\":\n        // last char should be }\n        start = content.lastIndexOf(left);\n        end =\n          start === -1\n            ? -1\n            : content.indexOf(right, start + rightDelimiterMinimumShift);\n        end = end === content.length - rightLength ? end : -1;\n        break;\n\n      case \"only\":\n        // '{.a}'\n        slice = content.slice(0, leftLength);\n        start = slice === left ? 0 : -1;\n        slice = content.slice(content.length - rightLength);\n        end = slice === right ? content.length - rightLength : -1;\n        break;\n    }\n\n    return (\n      start !== -1 &&\n      end !== -1 &&\n      validCurlyLength(content.substring(start, end + rightLength))\n    );\n  };\n\nexport const removeDelimiter = (\n  str: string,\n  left: string,\n  right: string\n): string => {\n  const start = escapeRegExp(left);\n  const end = escapeRegExp(right);\n  const pos = str.search(\n    new RegExp(`[ \\\\n]?${start}[^${start}${end}]+${end}$`)\n  );\n\n  return pos !== -1 ? str.slice(0, pos) : str;\n};\n\nexport const getMatchingOpeningToken = (\n  tokens: Token[],\n  index: number\n): Token | null => {\n  if (tokens[index].type === \"softbreak\") return null;\n\n  // non closing blocks, example img\n  if (tokens[index].nesting === 0) return tokens[index];\n\n  const level = tokens[index].level;\n  const type = tokens[index].type.replace(\"_close\", \"_open\");\n\n  for (; index >= 0; --index)\n    if (tokens[index].type === type && tokens[index].level === level)\n      return tokens[index];\n\n  return null;\n};\n","import { type Rule } from \"./types.js\";\nimport { addAttrs, getAttrs } from \"../attrs.js\";\nimport {\n  getMatchingOpeningToken,\n  hasDelimiters,\n  removeDelimiter,\n} from \"../helper.js\";\nimport {\n  type MarkdownItAttrRuleName,\n  type MarkdownItAttrsOptions,\n} from \"../options.js\";\nimport { escapeRegExp } from \"../utils.js\";\n\nconst getFenceRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * fenced code blocks\n   *\n   * ```python {.cls}\n   * for i in range(10):\n   *     print(i)\n   * ```\n   */\n\n  // fenced code blocks\n  name: \"code-block\",\n  tests: [\n    {\n      shift: 0,\n      block: true,\n      info: hasDelimiters(\"end\", options.left, options.right),\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index];\n    let lineNumber = \"\";\n\n    // special handler for VuePress line number\n    const results = token.info.match(/{(?:[\\d,-]+)}/);\n\n    if (results) {\n      token.info = token.info.replace(results[0], \"\");\n      lineNumber = results[0];\n    }\n\n    const start = token.info.lastIndexOf(options.left);\n    const attrs = getAttrs(token.info, start, options);\n\n    addAttrs(attrs, token);\n    token.info = `${removeDelimiter(\n      token.info,\n      options.left,\n      options.right\n    )} ${lineNumber}`;\n  },\n});\n\nconst getInlineRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => [\n  /**\n   * bla `click()`{.c} ![](img.png){.d}\n   *\n   * differs from 'inline attributes' as it does\n   * not have a closing tag (nesting: -1)\n   */\n  {\n    name: \"inline nesting 0\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            type: (str) => str === \"image\" || str === \"code_inline\",\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: hasDelimiters(\"start\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      const token = tokens[index].children![childIndex];\n\n      const endChar = token.content.indexOf(options.right);\n      const attrToken = tokens[index].children![childIndex - 1];\n      const attrs = getAttrs(token.content, 0, options);\n\n      addAttrs(attrs, attrToken);\n      if (token.content.length === endChar + options.right.length)\n        tokens[index].children!.splice(childIndex, 1);\n      else token.content = token.content.slice(endChar + options.right.length);\n    },\n  },\n\n  /**\n   * *emphasis*{.with attrs=1}\n   */\n  {\n    name: \"inline attributes\",\n    tests: [\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            shift: -1,\n            nesting: -1, // closing inline tag, </em>{.a}\n          },\n          {\n            shift: 0,\n            type: \"text\",\n            content: hasDelimiters(\"start\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrs = getAttrs(content, 0, options);\n      const openingToken = getMatchingOpeningToken(\n        tokens[index].children!,\n        childIndex - 1\n      );\n\n      addAttrs(attrs, openingToken);\n      token.content = content.slice(\n        content.indexOf(options.right) + options.right.length\n      );\n    },\n  },\n];\n\nconst getTableRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * | h1 |\n   * | -- |\n   * | c1 |\n   *\n   * {.c}\n   */\n  name: \"table\",\n  tests: [\n    {\n      // let this token be i, such that for-loop continues at\n      // next token after tokens.splice\n      shift: 0,\n      type: \"table_close\",\n    },\n    {\n      shift: 1,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 2,\n      type: \"inline\",\n      content: hasDelimiters(\"only\", options.left, options.right),\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index + 2];\n    const tableOpen = getMatchingOpeningToken(tokens, index);\n    const attrs = getAttrs(token.content, 0, options);\n\n    // add attributes\n    addAttrs(attrs, tableOpen);\n    // remove <p>{.c}</p>\n    tokens.splice(index + 1, 3);\n  },\n});\n\nconst getListRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => [\n  /**\n   * - item\n   * {.a}\n   */\n  {\n    name: \"list softbreak\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -2,\n            type: \"softbreak\",\n          },\n          {\n            position: -1,\n            type: \"text\",\n            content: hasDelimiters(\"only\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, indx, childIndex): void => {\n      const token = tokens[indx].children![childIndex];\n      const attrs = getAttrs(token.content, 0, options);\n      let ii = indx - 2;\n\n      while (\n        tokens[ii - 1] &&\n        tokens[ii - 1].type !== \"ordered_list_open\" &&\n        tokens[ii - 1].type !== \"bullet_list_open\"\n      )\n        ii--;\n\n      addAttrs(attrs, tokens[ii - 1]);\n      tokens[indx].children = tokens[indx].children!.slice(0, -2);\n    },\n  },\n\n  /**\n   * - nested list\n   *   - with double \\n\n   *   {.a} <-- apply to nested ul\n   *\n   * {.b} <-- apply to root <ul>\n   */\n  {\n    name: \"list double softbreak\",\n    tests: [\n      {\n        // let this token be i = 0 so that we can erase\n        // the <p>{.a}</p> tokens below\n        shift: 0,\n        type: (type) =>\n          type === \"bullet_list_close\" || type === \"ordered_list_close\",\n      },\n      {\n        shift: 1,\n        type: \"paragraph_open\",\n      },\n      {\n        shift: 2,\n        type: \"inline\",\n        content: hasDelimiters(\"only\", options.left, options.right),\n        children: (children) => children.length === 1,\n      },\n      {\n        shift: 3,\n        type: \"paragraph_close\",\n      },\n    ],\n    transform: (tokens, index): void => {\n      const token = tokens[index + 2];\n      const attrs = getAttrs(token.content, 0, options);\n      const openingToken = getMatchingOpeningToken(tokens, index);\n\n      addAttrs(attrs, openingToken);\n      tokens.splice(index + 1, 3);\n    },\n  },\n\n  /**\n   * - end of {.list-item}\n   */\n  {\n    name: \"list item end\",\n    tests: [\n      {\n        shift: -2,\n        type: \"list_item_open\",\n      },\n      {\n        shift: 0,\n        type: \"inline\",\n        children: [\n          {\n            position: -1,\n            type: \"text\",\n            content: hasDelimiters(\"end\", options.left, options.right),\n          },\n        ],\n      },\n    ],\n    transform: (tokens, index, childIndex): void => {\n      const token = tokens[index].children![childIndex];\n      const { content } = token;\n      const attrs = getAttrs(\n        content,\n        content.lastIndexOf(options.left),\n        options\n      );\n\n      addAttrs(attrs, tokens[index - 2]);\n\n      const trimmed = content.slice(0, content.lastIndexOf(options.left));\n\n      token.content =\n        trimmed[trimmed.length - 1] === \" \" ? trimmed.slice(0, -1) : trimmed;\n    },\n  },\n];\n\nconst getSoftBreakRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * something with softbreak\n   * {.cls}\n   */\n\n  name: \"\\n{.a} softbreak then curly in start\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -2,\n          type: \"softbreak\",\n        },\n        {\n          position: -1,\n          type: \"text\",\n          content: hasDelimiters(\"only\", options.left, options.right),\n        },\n      ],\n    },\n  ],\n  transform: (tokens, index, childIndex): void => {\n    const token = tokens[index].children![childIndex];\n    const attrs = getAttrs(token.content, 0, options);\n\n    // find last closing tag\n    let ii = index + 1;\n\n    while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) ii++;\n\n    const openingToken = getMatchingOpeningToken(tokens, ii);\n\n    addAttrs(attrs, openingToken);\n    tokens[index].children = tokens[index].children!.slice(0, -2);\n  },\n});\n\nconst getHrRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * horizontal rule --- {#id}\n   */\n  name: \"horizontal rule\",\n  tests: [\n    {\n      shift: 0,\n      type: \"paragraph_open\",\n    },\n    {\n      shift: 1,\n      type: \"inline\",\n      children: (children) => children.length === 1,\n      content: (content) =>\n        content.match(\n          new RegExp(\n            `^ {0,3}[-*_]{3,} ?${escapeRegExp(options.left)}[^${escapeRegExp(\n              options.right\n            )}]`\n          )\n        ) !== null,\n    },\n    {\n      shift: 2,\n      type: \"paragraph_close\",\n    },\n  ],\n  transform: (tokens, index): void => {\n    const token = tokens[index];\n\n    token.type = \"hr\";\n    token.tag = \"hr\";\n    token.nesting = 0;\n\n    const { content } = tokens[index + 1];\n    const start = content.lastIndexOf(options.left);\n    const attrs = getAttrs(content, start, options);\n\n    addAttrs(attrs, token);\n    token.markup = content;\n    tokens.splice(index + 1, 2);\n  },\n});\n\nconst getBlockRule = (options: Required<MarkdownItAttrsOptions>): Rule => ({\n  /**\n   * end of {.block}\n   */\n\n  name: \"end of block\",\n  tests: [\n    {\n      shift: 0,\n      type: \"inline\",\n      children: [\n        {\n          position: -1,\n          content: hasDelimiters(\"end\", options.left, options.right),\n          type: (type) => type !== \"code_inline\" && type !== \"math_inline\",\n        },\n      ],\n    },\n  ],\n  transform: (tokens, indx, childIndex): void => {\n    const token = tokens[indx].children![childIndex];\n    const { content } = token;\n    const attrs = getAttrs(content, content.lastIndexOf(options.left), options);\n    let ii = indx + 1;\n\n    while (tokens[ii + 1] && tokens[ii + 1].nesting === -1) ii++;\n\n    const openingToken = getMatchingOpeningToken(tokens, ii);\n\n    addAttrs(attrs, openingToken);\n\n    const trimmed = content.slice(0, content.lastIndexOf(options.left));\n\n    token.content =\n      trimmed[trimmed.length - 1] === \" \" ? trimmed.slice(0, -1) : trimmed;\n  },\n});\n\nconst availableRules: MarkdownItAttrRuleName[] = [\n  \"fence\",\n  \"inline\",\n  \"table\",\n  \"list\",\n  \"hr\",\n  \"softbreak\",\n  \"block\",\n];\n\nexport const getRules = (options: Required<MarkdownItAttrsOptions>): Rule[] => {\n  const enabledRules =\n    // disable\n    options.rule === false\n      ? []\n      : Array.isArray(options.rule)\n      ? // user specific rules\n        options.rule.filter((item) => availableRules.includes(item))\n      : availableRules;\n\n  const rules: Rule[] = [];\n\n  if (enabledRules.includes(\"fence\")) rules.push(getFenceRule(options));\n  if (enabledRules.includes(\"inline\")) rules.push(...getInlineRules(options));\n  if (enabledRules.includes(\"list\")) rules.push(...getListRules(options));\n  if (enabledRules.includes(\"table\")) rules.push(getTableRule(options));\n  if (enabledRules.includes(\"softbreak\")) rules.push(getSoftBreakRule(options));\n  if (enabledRules.includes(\"hr\")) rules.push(getHrRule(options));\n  if (enabledRules.includes(\"block\")) rules.push(getBlockRule(options));\n\n  return rules;\n};\n","import type Token from \"markdown-it/lib/token.js\";\n\nimport { type RuleSet } from \"./types.js\";\nimport { getElements, isArrayOfFunctions, isArrayOfObjects } from \"../utils.js\";\n\n/**\n * Test if rule matches token stream.\n *\n */\nexport const testRule = (\n  tokens: Token[],\n  index: number,\n  rule: RuleSet\n): { match: boolean; position: null | number } => {\n  const res = {\n    match: false,\n    position: null as number | null, // position of child\n  };\n\n  const ii = rule.shift !== undefined ? index + rule.shift : rule.position!;\n\n  // we should never shift to negative indexes (rolling around to back of array)\n  if (rule.shift !== undefined && ii < 0) return res;\n\n  // supports negative ii\n  const token = getElements(tokens, ii);\n\n  if (token === undefined) return res;\n\n  for (const key of Object.keys(rule) as (keyof typeof rule)[]) {\n    if (key === \"shift\" || key === \"position\") continue;\n\n    if (token[key as keyof Token] === undefined) return res;\n\n    if (key === \"children\" && isArrayOfObjects(rule.children)) {\n      if (token.children?.length === 0) return res;\n\n      let match;\n      const childTests = rule.children;\n      const children = token.children!;\n\n      if (childTests?.every((tt) => tt.position !== undefined)) {\n        // positions instead of shifts, do not loop all children\n        match = childTests.every(\n          (tt) => testRule(children, tt.position!, tt).match\n        );\n\n        if (match) {\n          // we may need position of child in transform\n          const j = childTests[childTests.length - 1]?.position || 0;\n\n          res.position = j >= 0 ? j : children.length + j;\n        }\n      } else {\n        for (let j = 0; j < children.length; j++) {\n          match = childTests.every((tt) => testRule(children, j, tt).match);\n\n          if (match) {\n            res.position = j;\n            // all tests true, continue with next key of pattern t\n            break;\n          }\n        }\n      }\n\n      if (match === false) return res;\n\n      continue;\n    }\n\n    const ruleDetail = rule[key];\n\n    switch (typeof ruleDetail) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        if (token[key] !== ruleDetail) return res;\n\n        break;\n\n      case \"function\":\n        // @ts-ignore\n        if (!ruleDetail(token[key])) return res;\n\n        break;\n\n      case \"object\":\n        if (isArrayOfFunctions(ruleDetail)) {\n          const r = ruleDetail.every((tt) =>\n            (tt as (key: unknown) => boolean)(token[key])\n          );\n\n          if (r === false) return res;\n\n          break;\n        }\n\n        continue;\n\n      // fall through for objects !== arrays of functions\n      default:\n        throw new Error(\n          `Unknown type of pattern test (key: ${key}). Test should be of type boolean, number, string, function or array of functions.`\n        );\n    }\n  }\n\n  // no tests returned false -> all tests returns true\n  res.match = true;\n\n  return res;\n};\n","/**\n * Forked and modified from https://github.com/arve0/markdown-it-attrs/\n */\n\nimport { type PluginWithOptions } from \"markdown-it\";\nimport { type RuleCore } from \"markdown-it/lib/parser_core.js\";\n\nimport { type MarkdownItAttrsOptions } from \"./options.js\";\nimport { getRules, testRule } from \"./rules/index.js\";\n\nexport const attrs: PluginWithOptions<MarkdownItAttrsOptions> = (\n  md,\n  { left = \"{\", right = \"}\", allowed = [], rule = \"all\" } = {}\n) => {\n  const rules = getRules({\n    left,\n    right,\n    allowed,\n    rule,\n  });\n\n  const attrsRule: RuleCore = ({ tokens }) => {\n    for (let index = 0; index < tokens.length; index++)\n      for (let ruleIndex = 0; ruleIndex < rules.length; ruleIndex++) {\n        const pattern = rules[ruleIndex];\n        // position of child with offset 0\n        let position: null | number = null;\n\n        const match = pattern.tests.every((t) => {\n          const result = testRule(tokens, index, t);\n\n          if (result.position !== null) ({ position } = result);\n\n          return result.match;\n        });\n\n        if (match) {\n          pattern.transform(tokens, index, position!);\n\n          if (\n            pattern.name === \"inline attributes\" ||\n            pattern.name === \"inline nesting 0\"\n          )\n            // retry, may be several inline attributes\n            ruleIndex -= 1;\n        }\n      }\n  };\n\n  md.core.ruler.before(\"linkify\", \"attrs\", attrsRule);\n};\n"],"names":["ALLOWED_KEY_CHARS","PAIR_SEPARATOR","KEY_SEPARATOR","CLASS_MARKER","ID_MARKER","getAttrs","str","start","left","right","allowed","key","value","parsingKey","valueInsideQuotes","attrs","index","char","attr","item","addAttrs","token","attrItem","getElements","arr","amount","escapeRegExp","regexp","isArrayOfFunctions","isArrayOfObjects","hasDelimiters","where","content","leftLength","rightLength","minCurlyLength","validCurlyLength","curly","isClass","isId","end","slice","nextChar","rightDelimiterMinimumShift","removeDelimiter","pos","getMatchingOpeningToken","tokens","level","type","getFenceRule","options","lineNumber","results","getInlineRules","childIndex","endChar","attrToken","openingToken","getTableRule","tableOpen","getListRules","indx","ii","children","trimmed","getSoftBreakRule","getHrRule","getBlockRule","availableRules","getRules","enabledRules","rules","testRule","rule","_a","_b","res","match","childTests","tt","j","ruleDetail","md","attrsRule","ruleIndex","pattern","position","t","result"],"mappings":"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"}