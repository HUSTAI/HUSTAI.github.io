{"version":3,"file":"index.mjs","sources":["../src/plugin.ts"],"sourcesContent":["import { type PluginWithOptions } from \"markdown-it\";\nimport { type RuleBlock } from \"markdown-it/lib/parser_block.js\";\n\nimport { type MarkdownItUMLOptions } from \"./options.js\";\n\nexport const uml: PluginWithOptions<MarkdownItUMLOptions> = (\n  md,\n  { name, open, close, render } = {\n    name: \"uml\",\n    open: \"start\",\n    close: \"end\",\n    render: (tokens, index): string => {\n      const token = tokens[index];\n      const { content, info, type } = token;\n\n      return `<div class=\"${type}\" title=\"${info}\">${content}</div>`;\n    },\n  }\n) => {\n  const OPEN_MARKER = `@${open}`;\n  const CLOSE_MARKER = `@${close}`;\n\n  const umlRule: RuleBlock = (state, startLine, endLine, silent) => {\n    let i;\n    let autoClosed = false;\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    /*\n     * Check out the first character quickly,\n     * this should filter out most of non-uml blocks\n     */\n    if (state.src.charAt(start) !== \"@\") return false;\n\n    // Check out the rest of the marker string\n    for (i = 0; i < OPEN_MARKER.length; ++i)\n      if (OPEN_MARKER[i] !== state.src[start + i]) return false;\n\n    const markup = state.src.slice(start, start + i);\n    const params = state.src.slice(start + i, max);\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine;\n\n    // Search for the end of the block\n    while (\n      /*\n       * unclosed block should be auto closed by end of document.\n       * also block seems to be auto closed by end of parent\n       */\n      nextLine < endLine\n    ) {\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        /*\n         * non-empty line with negative indent should stop the list:\n         * - ```\n         *  test\n         */\n        break;\n\n      if (\n        // didnâ€™t find the closing fence\n        state.src.charAt(start) === \"@\" &&\n        // closing fence should not be indented with respect of opening fence\n        state.sCount[nextLine] <= state.sCount[startLine]\n      ) {\n        let closeMarkerMatched = true;\n\n        for (i = 0; i < CLOSE_MARKER.length; ++i)\n          if (CLOSE_MARKER[i] !== state.src[start + i]) {\n            closeMarkerMatched = false;\n            break;\n          }\n\n        if (\n          closeMarkerMatched &&\n          // make sure tail has spaces only\n          state.skipSpaces(start + i) >= max\n        ) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n\n      nextLine += 1;\n    }\n\n    const contents = state.src\n      .split(\"\\n\")\n      .slice(startLine + 1, nextLine)\n      .join(\"\\n\");\n\n    const token = state.push(name, \"fence\", 0);\n\n    token.block = true;\n    token.info = params;\n    token.content = contents;\n    token.map = [startLine, nextLine];\n    token.markup = markup;\n\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", name, umlRule, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[name] = render;\n};\n"],"names":["uml","md","name","open","close","render","tokens","index","token","content","info","type","OPEN_MARKER","CLOSE_MARKER","umlRule","state","startLine","endLine","silent","i","autoClosed","start","max","markup","params","nextLine","closeMarkerMatched","contents"],"mappings":"AAKa,MAAAA,EAA+C,CAC1DC,EACA,CAAE,KAAAC,EAAM,KAAAC,EAAM,MAAAC,EAAO,OAAAC,CAAO,EAAI,CAC9B,KAAM,MACN,KAAM,QACN,MAAO,MACP,OAAQ,CAACC,EAAQC,IAAkB,CACjC,MAAMC,EAAQF,EAAOC,CAAK,EACpB,CAAE,QAAAE,EAAS,KAAAC,EAAM,KAAAC,CAAK,EAAIH,EAEhC,MAAO,eAAeG,aAAgBD,MAASD,SACjD,CACF,IACG,CACH,MAAMG,EAAc,IAAIT,IAClBU,EAAe,IAAIT,IAEnBU,EAAqB,CAACC,EAAOC,EAAWC,EAASC,IAAW,CAChE,IAAIC,EACAC,EAAa,GACbC,EAAQN,EAAM,OAAOC,CAAS,EAAID,EAAM,OAAOC,CAAS,EACxDM,EAAMP,EAAM,OAAOC,CAAS,EAMhC,GAAID,EAAM,IAAI,OAAOM,CAAK,IAAM,IAAK,MAAO,GAG5C,IAAKF,EAAI,EAAGA,EAAIP,EAAY,OAAQ,EAAEO,EACpC,GAAIP,EAAYO,CAAC,IAAMJ,EAAM,IAAIM,EAAQF,CAAC,EAAG,MAAO,GAEtD,MAAMI,EAASR,EAAM,IAAI,MAAMM,EAAOA,EAAQF,CAAC,EACzCK,EAAST,EAAM,IAAI,MAAMM,EAAQF,EAAGG,CAAG,EAG7C,GAAIJ,EAAQ,MAAO,GAEnB,IAAIO,EAAWT,EAGf,KAKES,EAAWR,IAEXI,EAAQN,EAAM,OAAOU,CAAQ,EAAIV,EAAM,OAAOU,CAAQ,EACtDH,EAAMP,EAAM,OAAOU,CAAQ,EAEvB,EAAAJ,EAAQC,GAAOP,EAAM,OAAOU,CAAQ,EAAIV,EAAM,aAJlD,CAYA,GAEEA,EAAM,IAAI,OAAOM,CAAK,IAAM,KAE5BN,EAAM,OAAOU,CAAQ,GAAKV,EAAM,OAAOC,CAAS,EAChD,CACA,IAAIU,EAAqB,GAEzB,IAAKP,EAAI,EAAGA,EAAIN,EAAa,OAAQ,EAAEM,EACrC,GAAIN,EAAaM,CAAC,IAAMJ,EAAM,IAAIM,EAAQF,CAAC,EAAG,CAC5CO,EAAqB,GACrB,MAGJ,GACEA,GAEAX,EAAM,WAAWM,EAAQF,CAAC,GAAKG,EAC/B,CAEAF,EAAa,GACb,OAIJK,GAAY,EAGd,MAAME,EAAWZ,EAAM,IACpB,MAAM;AAAA,CAAI,EACV,MAAMC,EAAY,EAAGS,CAAQ,EAC7B,KAAK;AAAA,CAAI,EAENjB,EAAQO,EAAM,KAAKb,EAAM,QAAS,CAAC,EAEzC,OAAAM,EAAM,MAAQ,GACdA,EAAM,KAAOgB,EACbhB,EAAM,QAAUmB,EAChBnB,EAAM,IAAM,CAACQ,EAAWS,CAAQ,EAChCjB,EAAM,OAASe,EAEfR,EAAM,KAAOU,GAAYL,EAAa,EAAI,GAEnC,EACT,EAEAnB,EAAG,MAAM,MAAM,OAAO,QAASC,EAAMY,EAAS,CAC5C,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,CAAC,EAEDb,EAAG,SAAS,MAAMC,CAAI,EAAIG,CAC5B"}