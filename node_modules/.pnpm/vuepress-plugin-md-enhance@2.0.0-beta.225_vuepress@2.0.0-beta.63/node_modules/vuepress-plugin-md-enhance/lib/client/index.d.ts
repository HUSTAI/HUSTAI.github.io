import { MermaidConfig } from 'mermaid';
import { App } from 'vue';
import { SFCOptions } from '@vue/repl';
import Babel from '@babel/core';
import * as reveal_js_dist_reveal_esm_js from 'reveal.js/dist/reveal.esm.js';

interface MermaidThemeVariables {
    dark?: boolean;
    background?: string;
    primaryColor?: string;
    primaryBorderColor?: string;
    primaryTextColor?: string;
    secondaryColor?: string;
    secondaryBorderColor?: string;
    secondaryTextColor?: string;
    tertiaryColor?: string;
    tertiaryBorderColor?: string;
    tertiaryTextColor?: string;
    noteBkgColor?: string;
    noteTextColor?: string;
    noteBorderColor?: string;
    lineColor?: string;
    textColor?: string;
    mainBkg?: string;
    errorBkgColor?: string;
    errorTextColor?: string;
    nodeBorder?: string;
    nodeTextColor?: string;
    signalTextColor?: string;
    classText?: string;
    labelColor?: string;
    fillType0?: string;
    fillType1?: string;
    fillType2?: string;
    fillType3?: string;
    fillType4?: string;
    fillType5?: string;
    fillType6?: string;
    fillType7?: string;
}
type MermaidOptions = Omit<MermaidConfig, "startOnLoad" | "themeVariables"> & {
    themeVariables?: MermaidThemeVariables | ((isDarkmode: boolean) => MermaidThemeVariables);
};
declare const defineMermaidConfig: (options: MermaidOptions) => void;
declare const injectMermaidConfig: (app: App) => void;

/**
 * @description This is added just because reveal.js do not have official type declaration files
 */
interface RevealOptions$1 {
    /**
     * The "normal" size of the presentation, aspect ratio will be preserved when the presentation is scaled to fit different resolutions.
     *
     * Can be specified using percentage units.
     */
    width: number;
    /**
     * The "normal" size of the presentation, aspect ratio will be preserved when the presentation is scaled to fit different resolutions.
     *
     * Can be specified using percentage units.
     */
    height: number;
    /** Factor of the display size that should remain empty around the content */
    margin: number;
    /** Bounds for smallest/largest possible scale to apply to content */
    minScale: number;
    maxScale: number;
    /** Display presentation control arrows */
    controls: boolean;
    /** Help the user learn the controls by providing hints, for example by bouncing the down arrow when they first encounter a vertical slide */
    controlsTutorial: boolean;
    /** Determines where controls appear */
    controlsLayout: "bottom-right" | "edges";
    /** Visibility rule for backwards navigation arrows */
    controlsBackArrows: "faded" | "hidden" | "visible";
    /** Display a presentation progress bar */
    progress: boolean;
    /**
     * Display the page number of the current slide
     * - true:    Show slide number
     * - false:   Hide slide number
     *
     * Can optionally be set as a string that specifies the number formatting:
     * - "h.v":   Horizontal . vertical slide number (default)
     * - "h/v":   Horizontal / vertical slide number
     * - "c":   Flattened slide number
     * - "c/t":   Flattened slide number / total slides
     *
     * Alternatively, you can provide a function that returns the slide
     * number for the current slide. The function should take in a slide
     * object and return an array with one string [slideNumber] or
     * three strings [n1,delimiter,n2]. See #formatSlideNumber().
     */
    slideNumber: boolean | "h.v" | "h/v" | "c" | "c/t" | ((slideObject: any) => [string] | [string, string, string]);
    /**
     * Can be used to limit the contexts in which the slide number appears
     *
     * - "all":      Always show the slide number
     * - "print":    Only when printing to PDF
     * - "speaker":  Only in the speaker view
     */
    showSlideNumber: "all" | "print" | "speaker";
    /**
     * Use 1 based indexing for # links to match slide number (default is zero based)
     */
    hashOneBasedIndex: boolean;
    /**
     * Add the current slide number to the URL hash
     * so that reloading the page/copying the URL will return you to the same slide
     */
    hash: boolean;
    /**
     * Flags if we should monitor the hash and change slides accordingly
     */
    respondToHashChanges: boolean;
    /**
     * Push each slide change to the browser history.  Implies `hash: true`
     */
    history: boolean;
    /** Enable keyboard shortcuts for navigation */
    keyboard: boolean;
    /**
     * Optional function that blocks keyboard events when retuning false
     *
     * If you set this to "focused", we will only capture keyboard events
     * for embedded decks when they are in focus
     */
    keyboardCondition: null | "focused" | ((event: KeyboardEvent) => boolean);
    /**
     * Disables the default reveal.js slide layout (scaling and centering)
     * so that you can use custom CSS layout
     */
    disableLayout: boolean;
    /**
     * Enable the slide overview mode
     */
    overview: boolean;
    /**
     * Vertical centering of slides
     */
    center: boolean;
    /**
     * Enables touch navigation on devices with touch input
     */
    touch: boolean;
    /**
     * Loop the presentation
     */
    loop: boolean;
    /**
     * Change the presentation direction to be RTL
     */
    rtl: boolean;
    /**
     * Changes the behavior of our navigation directions.
     *
     * "default"
     * Left/right arrow keys step between horizontal slides, up/down
     * arrow keys step between vertical slides. Space key steps through
     * all slides (both horizontal and vertical).
     *
     * "linear"
     * Removes the up/down arrows. Left/right arrows step through all
     * slides (both horizontal and vertical).
     *
     * "grid"
     * When this is enabled, stepping left/right from a vertical stack
     * to an adjacent vertical stack will land you at the same vertical
     * index.
     *
     * Consider a deck with six slides ordered in two vertical stacks:
     * 1.1    2.1
     * 1.2    2.2
     * 1.3    2.3
     *
     * If you’re on slide 1.3 and navigate right, you will normally move
     * from 1.3 -> 2.1. If "grid" is used, the same navigation takes you
     * from 1.3 -> 2.3.
     */
    navigationMode: "default" | "linear" | "grid";
    /**
     * Randomizes the order of slides each time the presentation loads
     */
    shuffle: boolean;
    /**
     * Turns fragments on and off globally
     */
    fragments: boolean;
    /**
     * Flags whether to include the current fragment in the URL,
     * so that reloading brings you to the same fragment position
     */
    fragmentInURL: boolean;
    /**
     * Flags if the presentation is running in an embedded mode,
     * i.e. contained within a limited portion of the screen
     */
    embedded: boolean;
    /**
     * Flags if we should show a help overlay when the question-mark key is pressed
     */
    help: boolean;
    /**
     * Flags if it should be possible to pause the presentation (blackout)
     */
    pause: boolean;
    /**
     * Flags if speaker notes should be visible to all viewers
     */
    showNotes: boolean;
    /**
     * Global override for auto playing embedded media (video/audio/iframe)
     *
     * - `null`: Media will only autoplay if data-autoplay is present
     * - `true`: All media will autoplay, regardless of individual setting
     * - `false`: No media will autoplay, regardless of individual setting
     */
    autoPlayMedia: null | boolean;
    /**
     * Global override for preloading lazy-loaded iframes
     *
     * - `null`: Iframes with data-src AND data-preload will be loaded when within the viewDistance,
     *   iframes with only data-src will be loaded when visible
     * - `true`: All iframes with data-src will be loaded when within the viewDistance
     * - `false`: All iframes with data-src will be loaded only when visible
     */
    preloadIframes: null | boolean;
    /**
     * Can be used to globally disable auto-animation
     */
    autoAnimate: boolean;
    /**
     * Optionally provide a custom element matcher
     * that will be used to dictate which elements we can animate between.
     */
    autoAnimateMatcher: null;
    /**
     * Default settings for our auto-animate transitions,
     * can be overridden per-slide or per-element via data arguments
     */
    autoAnimateEasing: "ease" | "ease-in" | "ease-out" | "linear";
    autoAnimateDuration: number;
    autoAnimateUnmatched: boolean;
    /**
     * CSS properties that can be auto-animated.
     *
     * Position & scale is matched separately
     * so there's no need to include styles like top/right/bottom/left, width/height or margin
     */
    autoAnimateStyles: string[];
    /**
     * Controls automatic progression to the next slide
     * - `0`: Auto-sliding only happens if the data-autoslide HTML attribute
     *  is present on the current slide or fragment
     * - `1+`: All slides will progress automatically at the given interval
     * - `false`: No auto-sliding, even if data-autoslide is present
     */
    autoSlide: number | false;
    /**
     * Stop auto-sliding after user input
     */
    autoSlideStoppable: boolean;
    /**
     * Use this method for navigation when auto-sliding (defaults to navigateNext)
     */
    autoSlideMethod: null | any;
    /**
     * Specify the average time in seconds that you think you will spend presenting each slide. This is used to show a pacing timer in the speaker view
     */
    defaultTiming: null | number;
    /**
     * Enable slide navigation via mouse wheel
     */
    mouseWheel: boolean;
    /**
     * Opens links in an iframe preview overlay
     *
     * Add `data-preview-link` and `data-preview-link="false"` to customize each link individually
     */
    previewLinks: boolean;
    /**
     * Exposes the reveal.js API through window.postMessage
     */
    postMessage: boolean;
    /**
     * Dispatches all reveal.js events to the parent window through postMessage
     */
    postMessageEvents: boolean;
    /**
     * Focuses body when page changes visibility to ensure keyboard shortcuts work
     */
    focusBodyOnPageVisibilityChange: boolean;
    /**
     * Transition style
     */
    transition: "none" | "slide" | "fade" | "convex" | "concave" | "zoom";
    /**
     * Transition speed
     */
    transitionSpeed: "default" | "fast" | "slow";
    /**
     * Transition style for full page slide backgrounds
     */
    backgroundTransition: "none" | "fade" | "slide" | "convex" | "concave" | "zoom";
    /**
     * The maximum number of pages a single slide can expand onto when printing to PDF, unlimited by default
     */
    pdfMaxPagesPerSlide: number;
    /**
     * Prints each fragment on a separate slide
     */
    pdfSeparateFragments: boolean;
    /**
     * Offset used to reduce the height of content within exported PDF pages.
     * This exists to account for environment differences based on how you
     * print to PDF. CLI printing options, like phantomjs and wkpdf, can end
     * on precisely the total height of the document whereas in-browser
     * printing has to end one pixel before.
     */
    pdfPageHeightOffset: number;
    /**
     * Number of slides away from the current that are visible
     */
    viewDistance: number;
    /**
     * Number of slides away from the current that are visible on mobile devices.
     *
     * It is advisable to set this to a lower number than viewDistance in order to save resources.
     */
    mobileViewDistance: number;
    /**
     * The display mode that will be used to show slides
     */
    display: "block";
    /**
     * Hide cursor if inactive
     */
    hideInactiveCursor: boolean;
    /**
     * Time before the cursor is hidden (in ms)
     */
    hideCursorTime: number;
    plugins: any[];
}

/**
 * Vue Playground options
 *
 * @description Vue playground is using [`@vue/repl`](https://github.com/vuejs/repl)
 *
 * Vue 交互演示配置
 *
 * @description Vue playground 使用 [`@vue/repl`](https://github.com/vuejs/repl)
 */
interface VuePlaygroundOptions {
    /**
     * specify the version of vue
     *
     * 指定 vue 版本
     */
    vueVersion?: string;
    /**
     * specify default URL to import Vue runtime from in the sandbox
     *
     * 指定默认的 Vue 运行时
     *
     * @default "https://unpkg.com/@vue/runtime-dom@${version}/dist/runtime-dom.esm-browser.js"
     */
    defaultVueRuntimeURL?: string;
    /**
     * Specify default URL to import Vue Server Renderer from in the sandbox
     *
     * 指定默认的 Vue 服务端渲染器
     *
     * @default "https://unpkg.com/@vue/server-renderer@${version}/dist/server-renderer.esm-browser.js"
     */
    defaultVueServerRendererURL?: string;
    /**
     * Whether to enable repl's editor resizable
     *
     * 是否启用自动调整大小
     *
     * @default true
     */
    autoResize?: boolean;
    /**
     * Whether to show JS, CSS, SSR panel
     *
     * 是否显示 JS, CSS, SSR 面板
     *
     * @default false
     */
    showCompileOutput?: boolean;
    /**
     * Whether to show import map
     *
     * 是否显示 import map
     *
     * @default true
     */
    showImportMap?: boolean;
    /**
     * Whether to clear console
     *
     * 是否清空控制台
     *
     * @default false
     */
    clearConsole?: boolean;
    /**
     * Layout
     *
     * 布局
     *
     * @default "horizontal"
     */
    layout?: "horizontal" | "vertical";
    /**
     * Options to configure the `vue/compiler-sfc`
     *
     * `vue/compiler-sfc` 配置项
     */
    sfcOptions?: SFCOptions;
    /**
     * Whether to enable SSR
     *
     * 是否启用 SSR
     *
     * @default true
     */
    ssr?: boolean;
}

type RevealOptions = Omit<RevealOptions$1, "embedded">;
declare const defineRevealConfig: (options: Partial<RevealOptions>) => void;
declare const injectRevealConfig: (app: App) => void;

declare const defineVuePlaygroundConfig: (options: VuePlaygroundOptions) => void;
declare const injectVuePlaygroundConfig: (app: App) => void;

declare global {
    interface Window {
        Babel: typeof Babel;
    }
}

/**
 * Forked from https://github.com/ulivz/vuepress-plugin-flowchart/tree/master/lib/presets
 *
 * MIT LICENSED
 */
declare const flowchartPresets: {
    ant: {
        symbols: {
            start: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            end: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            operation: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            inputoutput: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            subroutine: {
                class: string;
                "font-color": string;
                fill: string;
                "element-color": string;
                "line-color": string;
            };
            condition: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            parallel: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
        };
        x: number;
        y: number;
        "line-width": number;
        "line-length": number;
        "text-margin": number;
        "font-size": number;
        "font-color": string;
        "line-color": string;
        "element-color": string;
        fill: string;
        "yes-text": string;
        "no-text": string;
        "arrow-end": string;
        scale: number;
    };
    vue: {
        symbols: {
            start: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            end: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            operation: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            inputoutput: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            subroutine: {
                class: string;
                "font-color": string;
                fill: string;
                "element-color": string;
                "line-color": string;
            };
            condition: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
            parallel: {
                class: string;
                "font-color": string;
                fill: string;
                "line-width": string;
            };
        };
        x: number;
        y: number;
        "line-width": number;
        "line-length": number;
        "text-margin": number;
        "font-size": number;
        "font-color": string;
        "line-color": string;
        "element-color": string;
        fill: string;
        "yes-text": string;
        "no-text": string;
        "arrow-end": string;
        scale: number;
    };
    pie: {
        "line-width": number;
        symbols: {
            start: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            end: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            operation: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            inputoutput: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            subroutine: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            condition: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
            parallel: {
                class: string;
                fill: string;
                "line-color": string;
                "font-color": string;
            };
        };
        x: number;
        y: number;
        "line-length": number;
        "text-margin": number;
        "font-size": number;
        "font-color": string;
        "line-color": string;
        "element-color": string;
        fill: string;
        "yes-text": string;
        "no-text": string;
        "arrow-end": string;
        scale: number;
    };
};

declare const revealHighlight: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const revealMarkdown: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const revealMath: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const revealNotes: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const reveal: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const revealSearch: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

declare const revealZoom: () => Promise<typeof reveal_js_dist_reveal_esm_js>;

export { defineMermaidConfig, defineRevealConfig, defineVuePlaygroundConfig, flowchartPresets, injectMermaidConfig, injectRevealConfig, injectVuePlaygroundConfig, reveal, revealHighlight, revealMarkdown, revealMath, revealNotes, revealSearch, revealZoom };
