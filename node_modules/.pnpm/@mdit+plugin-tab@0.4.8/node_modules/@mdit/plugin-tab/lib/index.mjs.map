{"version":3,"file":"index.mjs","sources":["../src/utils.ts","../src/plugin.ts"],"sourcesContent":["export const escapeHtml = (unsafeHTML: string): string =>\n  unsafeHTML\n    .replace(/&/gu, \"&amp;\")\n    .replace(/</gu, \"&lt;\")\n    .replace(/>/gu, \"&gt;\")\n    .replace(/\"/gu, \"&quot;\")\n    .replace(/'/gu, \"&#039;\");\n","import { type Options, type PluginWithOptions } from \"markdown-it\";\nimport { type RuleBlock } from \"markdown-it/lib/parser_block.js\";\nimport type Renderer from \"markdown-it/lib/renderer.js\";\nimport type Token from \"markdown-it/lib/token.js\";\n\nimport {\n  type MarkdownItTabData,\n  type MarkdownItTabInfo,\n  type MarkdownItTabOptions,\n} from \"./options\";\nimport { escapeHtml } from \"./utils.js\";\n\nconst TAB_MARKER = `@tab`;\n\nconst getTabRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    if (store.state !== name) return false;\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    /*\n     * Check out the first character quickly,\n     * this should filter out most of non-uml blocks\n     */\n    if (state.src.charAt(start) !== \"@\") return false;\n\n    let index;\n\n    // Check out the rest of the marker string\n    for (index = 0; index < TAB_MARKER.length; index++)\n      if (TAB_MARKER[index] !== state.src[start + index]) return false;\n\n    const markup = state.src.slice(start, start + index);\n    const info = state.src.slice(start + index, max);\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    while (\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine\n    ) {\n      nextLine += 1;\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n\n      if (\n        // match start\n        state.src[start] === \"@\" &&\n        // marker should not be indented with respect of opening fence\n        state.sCount[nextLine] <= state.sCount[startLine]\n      ) {\n        let openMakerMatched = true;\n\n        for (index = 0; index < TAB_MARKER.length; index++)\n          if (TAB_MARKER[index] !== state.src[start + index]) {\n            openMakerMatched = false;\n            break;\n          }\n\n        if (openMakerMatched) {\n          // found!\n          autoClosed = true;\n          break;\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n\n    // @ts-expect-error\n    state.parentType = `tab`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    const openToken = state.push(`${name}_tab_open`, \"\", 1);\n\n    const [, title, id] = /^(.*?)(?:(?<!\\\\)#([^#]*))?$/.exec(\n      info.replace(/^:active/, \"\")\n    )!;\n\n    openToken.block = true;\n    openToken.markup = markup;\n    openToken.info = title.trim().replace(/\\\\#/g, \"#\");\n    openToken.meta = {\n      active: info.includes(\":active\"),\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (id) openToken.meta.id = id.trim();\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine + (autoClosed ? 0 : 1)\n    );\n\n    const closeToken = state.push(`${name}_tab_close`, \"\", -1);\n\n    closeToken.block = true;\n    closeToken.markup = \"\";\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + (autoClosed ? 0 : 1);\n\n    return true;\n  };\n\nconst getTabsRule =\n  (name: string, store: { state: string | null }): RuleBlock =>\n  (state, startLine, endLine, silent) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    if (state.src[start] !== \":\") return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (state.src[pos] !== \":\") break;\n      pos += 1;\n    }\n\n    const markerCount = pos - start;\n\n    if (markerCount < 3) return false;\n\n    const markup = state.src.slice(start, pos);\n    const params = state.src.slice(pos, max);\n\n    const [containerName, id = \"\"] = params.split(\"#\", 2);\n\n    if (containerName.trim() !== name) return false;\n\n    // Since start is found, we can report success here in validation mode\n    if (silent) return true;\n\n    let nextLine = startLine;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    while (\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine\n    ) {\n      nextLine += 1;\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n\n      if (\n        // match start\n        state.src[start] === \":\" &&\n        // closing fence should be indented less than 4 spaces\n        state.sCount[nextLine] - state.blkIndent < 4\n      ) {\n        // check rest of marker\n        for (pos = start + 1; pos <= max; pos++)\n          if (state.src[pos] !== \":\") break;\n\n        // closing code fence must be at least as long as the opening one\n        if (pos - start >= markerCount) {\n          // make sure tail has spaces only\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n\n    // @ts-expect-error\n    state.parentType = `${name}_tabs`;\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine - (autoClosed ? 1 : 0);\n\n    const openToken = state.push(`${name}_tabs_open`, \"\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = containerName;\n    openToken.meta = { id: id.trim() };\n    openToken.map = [startLine, nextLine - (autoClosed ? 1 : 0)];\n\n    const originalState = store.state;\n\n    store.state = name;\n\n    state.md.block.tokenize(\n      state,\n      startLine + 1,\n      nextLine - (autoClosed ? 1 : 0)\n    );\n\n    store.state = originalState;\n\n    const closeToken = state.push(`${name}_tabs_close`, \"\", -1);\n\n    closeToken.markup = state.src.slice(start, pos);\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\nconst getTabsDataGetter =\n  (name: string): ((tokens: Token[], index: number) => MarkdownItTabInfo) =>\n  (tokens, index) => {\n    const tabData: MarkdownItTabData[] = [];\n    let activeIndex = -1;\n    let isTabStart = false;\n    let nestingDepth = -1;\n\n    for (let i = index; i < tokens.length; i++) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      const { block, meta, type, info } = tokens[i];\n\n      if (block) {\n        if (type === `${name}_tabs_open`) {\n          nestingDepth += 1;\n          continue;\n        }\n\n        if (type === `${name}_tabs_close`)\n          if (nestingDepth === 0) {\n            break;\n          } else {\n            nestingDepth -= 1;\n            continue;\n          }\n\n        if (nestingDepth > 0) continue;\n\n        if (type === `${name}_tab_open`) {\n          isTabStart = true;\n\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          meta.index = tabData.length;\n\n          // tab is active\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          if (meta.active)\n            if (activeIndex === -1) activeIndex = tabData.length;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            else meta.active = false;\n\n          tabData.push({\n            title: info,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            index: meta.index as number,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            ...(meta.id ? { id: meta.id as string } : {}),\n          });\n\n          continue;\n        }\n\n        if (type === `${name}_tab_close`) continue;\n\n        if (!isTabStart) {\n          tokens[i].type = `${name}_tabs_empty`;\n          tokens[i].hidden = true;\n        }\n      }\n    }\n\n    return {\n      active: activeIndex,\n      data: tabData.map((data, index) => ({\n        ...data,\n        active: index === activeIndex,\n      })),\n    };\n  };\n\nconst tabDataGetter = (tokens: Token[], index: number): MarkdownItTabData => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const { info, meta } = tokens[index];\n\n  return {\n    title: info,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    index: meta.index as number,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    ...(meta.id ? { id: meta.id as string } : {}),\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    isActive: Boolean(meta.active),\n  };\n};\n\nconst store = { state: null };\n\nexport const tab: PluginWithOptions<MarkdownItTabOptions> = (md, options) => {\n  const {\n    name = \"tabs\",\n\n    tabsOpenRenderer = (\n      info: MarkdownItTabInfo,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer\n    ): string => {\n      const { active, data } = info;\n      const token = tokens[index];\n\n      token.attrJoin(\"class\", `${name}-tabs-wrapper`);\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (token.meta.id) token.attrJoin(\"data-id\", token.meta.id as string);\n\n      const tabs = data.map(\n        ({ title, id }, index) =>\n          `<button type=\"button\" class=\"${name}-tab-button${\n            active === index ? \" active\" : \"\"\n          }\" data-tab=\"${index}\"${id ? ` data-id=\"${escapeHtml(id)}\"` : \"\"}${\n            active === index ? \" data-active\" : \"\"\n          }>${escapeHtml(title)}</button>`\n      );\n\n      return `\\\n<div${self.renderAttrs(token)}>\n  <div class=\"${name}-tabs-header\">\n    ${tabs.join(\"\\n    \")}\n  </div>\n  <div class=\"${name}-tabs-container\">\\n`;\n    },\n\n    tabsCloseRenderer = (): string => `\n  </div>\n</div>`,\n\n    tabOpenRenderer = (\n      info: MarkdownItTabData,\n      tokens: Token[],\n      index: number,\n      _options: Options,\n      _env: unknown,\n      self: Renderer\n    ): string => {\n      const token = tokens[index];\n\n      token.attrJoin(\n        \"class\",\n        `${name}-tab-content${info.isActive ? \" active\" : \"\"}`\n      );\n      token.attrSet(\"data-index\", info.index.toString());\n      if (info.id) token.attrSet(\"data-id\", info.id.toString());\n\n      if (info.isActive) token.attrJoin(\"data-active\", \"\");\n\n      return `<div${self.renderAttrs(tokens[index])}>`;\n    },\n\n    tabCloseRenderer = (): string => `</div>`,\n  } = options || {};\n\n  const tabsDataGetter = getTabsDataGetter(name);\n\n  md.block.ruler.before(\"fence\", `${name}_tabs`, getTabsRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.block.ruler.before(\"paragraph\", `${name}_tab`, getTabRule(name, store), {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n\n  md.renderer.rules[`${name}_tabs_open`] = (\n    tokens,\n    index,\n    options,\n    env,\n    self\n  ): string => {\n    const info = tabsDataGetter(tokens, index);\n\n    return tabsOpenRenderer(info, tokens, index, options, env, self);\n  };\n\n  md.renderer.rules[`${name}_tabs_close`] = tabsCloseRenderer;\n\n  md.renderer.rules[`${name}_tab_open`] = (tokens, index, ...args): string => {\n    const data = tabDataGetter(tokens, index);\n\n    return tabOpenRenderer(data, tokens, index, ...args);\n  };\n\n  md.renderer.rules[`${name}_tab_close`] = tabCloseRenderer;\n};\n"],"names":["escapeHtml","unsafeHTML","TAB_MARKER","getTabRule","name","store","state","startLine","endLine","silent","start","max","index","markup","info","nextLine","autoClosed","openMakerMatched","oldParent","oldLineMax","openToken","title","id","closeToken","getTabsRule","pos","markerCount","params","containerName","originalState","getTabsDataGetter","tokens","tabData","activeIndex","isTabStart","nestingDepth","i","block","meta","type","data","tabDataGetter","tab","md","options","tabsOpenRenderer","_options","_env","self","active","token","tabs","tabsCloseRenderer","tabOpenRenderer","tabCloseRenderer","tabsDataGetter","env","args"],"mappings":"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"}