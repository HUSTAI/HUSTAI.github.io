import type { PickReadonly } from '../std/types';
import type { PickWritable } from '../std/types';
import { type ReadSignal, type WriteSignal } from './reactivity';
import type { AnyRecord, ReadSignalRecord } from './types';
/**
 * Converts objects into stores. A store stores the initial object and enables producing new
 * objects where each value in the provided object becomes a signal.
 *
 * @example
 * ```ts
 * const factory = new StoreFactory({
 *   foo: 0,
 *   bar: '...',
 *   get baz() {
 *     return this.foo + 1;
 *   }
 * });
 *
 * console.log(factory.record); // logs `{ foo: 0, bar: '...' }`
 *
 * const $state = factory.create();
 *
 * effect(() => console.log($state.foo()));
 * // Run effect ^
 * $state.foo.set(1);
 *
 * // Reset all values
 * factory.reset($state);
 * ```
 */
export declare class StoreFactory<Record extends AnyRecord> {
    readonly id: symbol;
    readonly record: Record;
    private _descriptors;
    constructor(record: Record);
    create(): Store<Record>;
    reset(record: Store<Record>, filter?: (key: keyof Record) => boolean): void;
}
export type Store<T> = {
    readonly [P in keyof PickReadonly<T>]: ReadSignal<T[P]>;
} & {
    readonly [P in keyof PickWritable<T>]: WriteSignal<T[P]>;
};
export type InferStore<T> = T extends StoreFactory<infer Record> ? Store<Record> : T extends Store<any> ? T : never;
export type InferStoreRecord<T> = T extends StoreFactory<infer Record> ? Record : T extends Store<infer Record> ? Record : never;
export type StoreContext<T> = ReadSignalRecord<T extends StoreFactory<infer Record> ? Record : T>;
/**
 * Returns the store record context value for the current component tree.
 */
export declare function useStore<Record extends AnyRecord>(store: StoreFactory<Record>): StoreContext<Record>;
