import { $$_attach_declarative_shadow_dom, createComponent, registerCustomElement, registerLiteCustomElement } from './chunks/chunk-XC5AOFRA.js';
import { kebabToPascalCase } from './chunks/chunk-XPDWGPRV.js';
import { provideContext } from './chunks/chunk-OJRMMG75.js';
import { getContext, createScope, tick } from '@maverick-js/signals';
import * as React2 from 'react';

var ReactComputeScopeContext = React2.createContext(null);
function WithScope(scope, children) {
  return React2.createElement(ReactComputeScopeContext.Provider, { value: scope }, children);
}
function useReactScope() {
  return React2.useContext(ReactComputeScopeContext);
}
function useReactContext(context) {
  const scope = useReactScope();
  return React2.useMemo(() => {
    return getContext(context.id, scope);
  }, [scope]);
}
function createReactScopeProvider() {
  return ScopeProvider;
}
function createReactContextProvider(context, provide) {
  var _a;
  return _a = class extends ScopeProvider {
  }, _a.C = context, _a.K = provide, _a;
}
var ScopeProvider = class extends React2.Component {
  constructor(props, context) {
    super(props);
    const scope = createScope();
    this.c = scope;
    if (context)
      context.append(scope);
    const ctor = this.constructor;
    if (ctor.C)
      provideContext(ctor.C, ctor.K?.(), scope);
  }
  render() {
    return WithScope(this.c, this.props?.children);
  }
};
ScopeProvider.contextType = ReactComputeScopeContext;

// src/react/utils.ts
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}

// src/react/create-react-element.ts
function createReactElement(Component3, init) {
  return createReactClientElement(registerCustomElement, Component3, init);
}
function createLiteReactElement(Component3, init) {
  return createReactClientElement(registerLiteCustomElement, Component3, init);
}
function createReactClientElement(registerCustomElement2, Component3, init) {
  registerCustomElement2(Component3);
  class CustomElement extends ReactCustomElement {
  }
  CustomElement.displayName = init?.displayName ?? kebabToPascalCase(Component3.el.tagName);
  CustomElement.contextType = ReactComputeScopeContext;
  CustomElement.a = Component3;
  CustomElement.e = new Set(Object.keys(Component3.el.props ?? {}));
  const ForwardedComponent = React2.forwardRef(
    (props, ref) => React2.createElement(CustomElement, { ...props, O: ref }, props?.children)
  );
  ForwardedComponent.displayName = "ForwardRef_" + CustomElement.displayName;
  return ForwardedComponent;
}
var ReactCustomElement = class extends React2.Component {
  constructor() {
    super(...arguments);
    this.g = null;
  }
  componentDidMount() {
    if (!this.g || this.g.component)
      return;
    $$_attach_declarative_shadow_dom(this.g);
    this.g.onEventDispatch((eventType) => {
      const callbackName = `on${kebabToPascalCase(eventType)}`;
      const callback = this.props[callbackName];
      const ctor = this.constructor;
      ctor.D.set(callbackName, eventType);
      if (callback)
        this.M(eventType, callback);
    });
    this.g.attachComponent(this.a);
  }
  componentWillUnmount() {
    window.requestAnimationFrame(() => {
      if (!this.g)
        this.a.destroy();
    });
  }
  render() {
    const ctor = this.constructor;
    const { O: __forwardedRef, className, children, ...restProps } = this.props;
    if (!this.a) {
      this.u = /* @__PURE__ */ new Map();
      this.a = createComponent(ctor.a, {
        props: this.props,
        scope: this.context
      });
    }
    if (!this.E || this.L !== __forwardedRef) {
      this.E = (value) => {
        this.g = value;
        if (__forwardedRef)
          setRef(__forwardedRef, value);
        this.L = __forwardedRef;
      };
    }
    const props = { class: className, ref: this.E };
    const $props = this.a.instance.e;
    for (const prop of Object.keys(restProps)) {
      const value = restProps[prop];
      if (ctor.D.has(prop)) {
        this.M(ctor.D.get(prop), value);
      } else if (ctor.e.has(prop)) {
        $props[prop].set(value);
      } else {
        props[prop] = value;
      }
    }
    tick();
    return WithScope(
      this.a.instance.c,
      React2.createElement(
        ctor.a.el.tagName,
        { ...props, "mk-d": true, suppressHydrationWarning: true },
        React2.createElement(ShadowRoot, {
          shadow: ctor.a.el.shadowRoot
        }),
        children
      )
    );
  }
  M(eventType, listener) {
    let handler = this.u.get(eventType);
    if (!this.g || handler?.handleEvent === listener)
      return;
    if (listener) {
      if (!handler) {
        this.u.set(eventType, handler = { handleEvent: listener });
        this.g.addEventListener(eventType, handler);
      } else {
        handler.handleEvent = listener;
      }
    } else if (handler) {
      this.u.delete(eventType);
      this.g.removeEventListener(eventType, handler);
    }
  }
};
ReactCustomElement.D = /* @__PURE__ */ new Map();
function ShadowRoot(props) {
  return React2.createElement(props.shadow ? "template" : "shadow-root", {
    dangerouslySetInnerHTML: { __html: "" },
    suppressHydrationWarning: true
  });
}

export { ReactComputeScopeContext, WithScope, createLiteReactElement, createReactContextProvider, createReactElement, createReactScopeProvider, useReactContext, useReactScope };
