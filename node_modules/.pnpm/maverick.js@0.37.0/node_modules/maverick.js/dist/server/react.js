import { $$_attach_declarative_shadow_dom, createComponent, createServerElement } from './chunks/chunk-IRKHAFGD.js';
import { kebabToPascalCase, kebabToCamelCase } from './chunks/chunk-UQUIIFVF.js';
import { provideContext } from './chunks/chunk-3GPUVQSV.js';
import { getContext, createScope, tick } from '@maverick-js/signals';
import * as React from 'react';
import { renderToStaticMarkup } from 'react-dom/server';

var ReactComputeScopeContext = React.createContext(null);
function WithScope(scope, children) {
  return React.createElement(ReactComputeScopeContext.Provider, { value: scope }, children);
}
function useReactScope() {
  return React.useContext(ReactComputeScopeContext);
}
function useReactContext(context) {
  const scope = useReactScope();
  return React.useMemo(() => {
    return getContext(context.id, scope);
  }, [scope]);
}
function createReactScopeProvider() {
  return ScopeProvider;
}
function createReactContextProvider(context, provide) {
  var _a;
  return _a = class extends ScopeProvider {
  }, _a._context = context, _a._provide = provide, _a;
}
var ScopeProvider = class extends React.Component {
  constructor(props, context) {
    var _a;
    super(props);
    const scope = createScope();
    this._scope = scope;
    if (context)
      context.append(scope);
    const ctor = this.constructor;
    if (ctor._context)
      provideContext(ctor._context, (_a = ctor._provide) == null ? void 0 : _a.call(ctor), scope);
  }
  render() {
    var _a;
    return WithScope(this._scope, (_a = this.props) == null ? void 0 : _a.children);
  }
};
ScopeProvider.contextType = ReactComputeScopeContext;

// src/react/create-react-server-element.ts
var stylesRE = /style="(.*?)"/;
function createReactServerElement(Component3) {
  const ServerElement = createServerElement(Component3);
  const propDefs = Component3.el.props ?? {};
  return ({ className, style, ...props } = {}) => {
    var _a;
    const host = new ServerElement();
    const _attrs = {};
    const _props = {};
    if (className) {
      host.setAttribute("class", className + "");
    }
    if (style) {
      const markup = renderToStaticMarkup(React.createElement("a", { style }));
      const styles = (_a = markup.match(stylesRE)) == null ? void 0 : _a[1];
      if (styles)
        host.setAttribute("style", styles);
    }
    for (const prop of Object.keys(props)) {
      if (prop in propDefs) {
        _props[prop] = props[prop];
      } else {
        _attrs[prop] = props[prop];
      }
    }
    const parentScope = useReactScope(), component = createComponent(Component3, {
      props: _props,
      scope: parentScope
    });
    host.attachComponent(component);
    const innerHTML = host.renderInnerHTML();
    if (host.hasAttribute("style")) {
      _attrs.style = {};
      for (const [name, value] of host.style.tokens) {
        _attrs.style[name.startsWith("--") ? name : kebabToCamelCase(name)] = value;
      }
      host.removeAttribute("style");
    }
    return WithScope(
      component.instance._scope,
      React.createElement(
        Component3.el.tagName,
        {
          ..._attrs,
          ...Object.fromEntries(host.attributes.tokens),
          "mk-d": "",
          "mk-h": ""
        },
        Component3.el.shadowRoot ? React.createElement("template", {
          shadowroot: host.getShadowRootMode(),
          dangerouslySetInnerHTML: { __html: innerHTML }
        }) : React.createElement("shadow-root", {
          dangerouslySetInnerHTML: { __html: innerHTML }
        }),
        props.children,
        React.createElement(() => {
          if (!parentScope)
            host.destroy();
          return null;
        })
      )
    );
  };
}

// src/react/utils.ts
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else {
    ref.current = value;
  }
}

// src/react/create-react-element.ts
function createReactElement(Component3, init) {
  return createReactServerElement(Component3) ;
}
function createLiteReactElement(Component3, init) {
  return createReactServerElement(Component3) ;
}
var ReactCustomElement = class extends React.Component {
  constructor() {
    super(...arguments);
    this._element = null;
  }
  componentDidMount() {
    if (!this._element || this._element.component)
      return;
    $$_attach_declarative_shadow_dom(this._element);
    this._element.onEventDispatch((eventType) => {
      const callbackName = `on${kebabToPascalCase(eventType)}`;
      const callback = this.props[callbackName];
      const ctor = this.constructor;
      ctor._callbacks.set(callbackName, eventType);
      if (callback)
        this._updateEventListener(eventType, callback);
    });
    this._element.attachComponent(this._component);
  }
  componentWillUnmount() {
    window.requestAnimationFrame(() => {
      if (!this._element)
        this._component.destroy();
    });
  }
  render() {
    const ctor = this.constructor;
    const { __forwardedRef, className, children, ...restProps } = this.props;
    if (!this._component) {
      this._listeners = /* @__PURE__ */ new Map();
      this._component = createComponent(ctor._component, {
        props: this.props,
        scope: this.context
      });
    }
    if (!this._ref || this._forwardedRef !== __forwardedRef) {
      this._ref = (value) => {
        this._element = value;
        if (__forwardedRef)
          setRef(__forwardedRef, value);
        this._forwardedRef = __forwardedRef;
      };
    }
    const props = { class: className, ref: this._ref };
    const $props = this._component.instance._props;
    for (const prop of Object.keys(restProps)) {
      const value = restProps[prop];
      if (ctor._callbacks.has(prop)) {
        this._updateEventListener(ctor._callbacks.get(prop), value);
      } else if (ctor._props.has(prop)) {
        $props[prop].set(value);
      } else {
        props[prop] = value;
      }
    }
    tick();
    return WithScope(
      this._component.instance._scope,
      React.createElement(
        ctor._component.el.tagName,
        { ...props, "mk-d": true, suppressHydrationWarning: true },
        React.createElement(ShadowRoot, {
          shadow: ctor._component.el.shadowRoot
        }),
        children
      )
    );
  }
  _updateEventListener(eventType, listener) {
    let handler = this._listeners.get(eventType);
    if (!this._element || (handler == null ? void 0 : handler.handleEvent) === listener)
      return;
    if (listener) {
      if (!handler) {
        this._listeners.set(eventType, handler = { handleEvent: listener });
        this._element.addEventListener(eventType, handler);
      } else {
        handler.handleEvent = listener;
      }
    } else if (handler) {
      this._listeners.delete(eventType);
      this._element.removeEventListener(eventType, handler);
    }
  }
};
ReactCustomElement._callbacks = /* @__PURE__ */ new Map();
function ShadowRoot(props) {
  return React.createElement(props.shadow ? "template" : "shadow-root", {
    dangerouslySetInnerHTML: { __html: "" },
    suppressHydrationWarning: true
  });
}

export { ReactComputeScopeContext, WithScope, createLiteReactElement, createReactContextProvider, createReactElement, createReactScopeProvider, useReactContext, useReactScope };
