import { RaphaelElement, RaphaelPath, RaphaelSet, RaphaelPaper } from 'raphael';

interface Position {
    x: number;
    y: number;
}

declare class FlowChartSymbol {
    chart: FlowChart;
    text: RaphaelElement<"SVG" | "VML", Element | SVGTextElement>;
    params: Record<string, string>;
    connectedTo: FlowChartSymbol[];
    leftLines: RaphaelPath<"SVG" | "VML">[];
    rightLines: RaphaelPath<"SVG" | "VML">[];
    topLines: RaphaelPath<"SVG" | "VML">[];
    bottomLines: RaphaelPath<"SVG" | "VML">[];
    group: RaphaelSet<"SVG" | "VML">;
    symbol?: RaphaelElement<"SVG" | "VML", Element | SVGRectElement>;
    symbolType?: SymbolType;
    flowstate: string;
    key: string;
    lineStyle: Record<string, any>;
    bottomStart?: boolean;
    next?: FlowChartSymbol;
    next_direction: Direction | undefined;
    isPositioned?: boolean;
    width: number;
    height: number;
    topStart?: boolean;
    topEnd?: boolean;
    rightStart?: boolean;
    leftStart?: boolean;
    leftEnd?: boolean;
    rightEnd?: boolean;
    pathOk?: boolean;
    constructor(chart: FlowChart, options: Partial<SymbolOptions>, symbol?: RaphaelElement<"SVG" | "VML", Element | SVGRectElement>);
    getAttr<T>(attName: string): T | undefined;
    initialize(): void;
    getCenter(): Position;
    getX(): number;
    getY(): number;
    shiftX(x: number): void;
    setX(x: number): void;
    shiftY(y: number): void;
    setY(y: number): void;
    getTop(): Position;
    getBottom(): Position;
    getLeft(): Position;
    getRight(): Position;
    render(): void;
    renderLines(): void;
    drawLineTo(symbol: FlowChartSymbol, text: string, direction?: Direction): void;
}

type SymbolType = "start" | "end" | "operation" | "inputoutput" | "subroutine" | "condition" | "parallel";
interface SVGOptions {
    x: number;
    y: number;
    "text-margin": number;
    font?: string;
    "font-family"?: string;
    "font-weight"?: string;
    "font-size": number;
    "font-color": string;
    "line-width": number;
    "line-length": number;
    "line-color": string;
    "element-color": string;
    fill: string;
    "yes-text": string;
    "no-text": string;
    "arrow-end": string;
    class: string;
    scale: number;
    [props: string]: any;
}
interface DrawOptions extends Partial<SVGOptions> {
    width?: number;
    height?: number;
    /** Symbol Styles */
    symbols?: Record<string, Partial<SVGOptions>>;
    /** FlowState config */
    flowstate?: string;
}
interface ParsedDrawOptions extends Partial<SVGOptions> {
    width?: number;
    height?: number;
    /** Stymbol Styles */
    symbols: Record<string, Partial<SVGOptions>>;
    /** FlowState config */
    flowstate?: string | null;
}
type Direction = "top" | "right" | "left" | "bottom" | "path1" | "path2" | "path3";
interface SymbolOptions extends ParsedDrawOptions {
    symbolType: SymbolType;
    key: string;
    text: string | null;
    link: string | null;
    target: string | null;
    function: null | string;
    lineStyle: Record<string, string>;
    params: Record<string, string>;
    direction_next?: Direction;
    next?: FlowChartSymbol;
    path1?: FlowChartSymbol;
    path2?: FlowChartSymbol;
    path3?: FlowChartSymbol;
    direction_path1: Direction;
    direction_path2: Direction;
    direction_path3: Direction;
}

declare class FlowChart {
    options: ParsedDrawOptions;
    symbols: FlowChartSymbol[];
    lines: RaphaelPath<"SVG" | "VML">[];
    start: null | FlowChartSymbol;
    paper: RaphaelPaper<"SVG" | "VML"> & RaphaelSet<"SVG" | "VML">;
    minXFromSymbols: number;
    maxXFromLine: number;
    constructor(container: string | HTMLElement, options?: ParsedDrawOptions);
    handle(symbol: FlowChartSymbol): FlowChartSymbol;
    startWith(symbol: FlowChartSymbol): FlowChartSymbol;
    render(): void;
    clean(): void;
}

interface Chart {
    symbols: Record<string, SymbolOptions>;
    start: SymbolOptions | null;
    diagram: FlowChart | null;
    draw: (container: HTMLElement | string, options?: DrawOptions) => void;
    clean: () => void;
    options: () => ParsedDrawOptions | Record<string, never>;
}
declare const parse: (input?: string) => Chart;

export { Chart, parse };
