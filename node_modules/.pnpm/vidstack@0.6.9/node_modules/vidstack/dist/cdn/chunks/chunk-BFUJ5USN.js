// ../../node_modules/.pnpm/@maverick-js+signals@5.10.3/node_modules/@maverick-js/signals/dist/dev/chunks/chunk-RDXOW6QS.js
var SCOPE = Symbol("SCOPE");
var scheduledEffects = false;
var runningEffects = false;
var currentScope = null;
var currentObserver = null;
var currentObservers = null;
var currentObserversIndex = 0;
var effects = [];
var NOOP = () => {
};
var STATE_CLEAN = 0;
var STATE_CHECK = 1;
var STATE_DIRTY = 2;
var STATE_DISPOSED = 3;
function flushEffects() {
  scheduledEffects = true;
  queueMicrotask(runEffects);
}
function runEffects() {
  if (!effects.length) {
    scheduledEffects = false;
    return;
  }
  runningEffects = true;
  for (let i = 0; i < effects.length; i++) {
    if (effects[i]._state !== STATE_CLEAN)
      runTop(effects[i]);
  }
  effects = [];
  scheduledEffects = false;
  runningEffects = false;
}
function runTop(node) {
  let ancestors = [node];
  while (node = node[SCOPE]) {
    if (node._effect && node._state !== STATE_CLEAN)
      ancestors.push(node);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    updateCheck(ancestors[i]);
  }
}
function root(init) {
  const scope = createScope();
  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);
}
function peek(fn) {
  return compute(currentScope, fn, null);
}
function untrack(fn) {
  return compute(null, fn, null);
}
function tick() {
  if (!runningEffects)
    runEffects();
}
function getScope() {
  return currentScope;
}
function scoped(run2, scope) {
  try {
    return compute(scope, run2, null);
  } catch (error) {
    handleError(scope, error);
    return;
  }
}
function getContext(key, scope = currentScope) {
  return scope?._context[key];
}
function setContext(key, value, scope = currentScope) {
  if (scope)
    scope._context = { ...scope._context, [key]: value };
}
function onDispose(disposable) {
  if (!disposable || !currentScope)
    return disposable || NOOP;
  const node = currentScope;
  if (!node._disposal) {
    node._disposal = disposable;
  } else if (Array.isArray(node._disposal)) {
    node._disposal.push(disposable);
  } else {
    node._disposal = [node._disposal, disposable];
  }
  return function removeDispose() {
    if (node._state === STATE_DISPOSED)
      return;
    disposable.call(null);
    if (isFunction(node._disposal)) {
      node._disposal = null;
    } else if (Array.isArray(node._disposal)) {
      node._disposal.splice(node._disposal.indexOf(disposable), 1);
    }
  };
}
function dispose(self = true) {
  if (this._state === STATE_DISPOSED)
    return;
  let head = self ? this._prevSibling ?? this[SCOPE] : this, current = this._nextSibling;
  while (current && current[SCOPE] === this) {
    dispose.call(current, true);
    disposeNode(current);
    current = current._nextSibling;
  }
  if (self)
    disposeNode(this);
  if (current)
    current._prevSibling = !self ? this : this._prevSibling;
  if (head)
    head._nextSibling = current;
}
function disposeNode(node) {
  node._state = STATE_DISPOSED;
  if (node._disposal)
    emptyDisposal(node);
  if (node._sources)
    removeSourceObservers(node, 0);
  if (node._prevSibling)
    node._prevSibling._nextSibling = null;
  node[SCOPE] = null;
  node._sources = null;
  node._observers = null;
  node._prevSibling = null;
  node._context = null;
  node._handlers = null;
}
function emptyDisposal(scope) {
  try {
    if (Array.isArray(scope._disposal)) {
      for (let i = 0; i < scope._disposal.length; i++) {
        const callable = scope._disposal[i];
        callable.call(callable);
      }
    } else {
      scope._disposal.call(scope._disposal);
    }
    scope._disposal = null;
  } catch (error) {
    handleError(scope, error);
  }
}
function compute(scope, compute2, observer) {
  const prevScope = currentScope, prevObserver = currentObserver;
  currentScope = scope;
  currentObserver = observer;
  try {
    return compute2.call(scope);
  } finally {
    currentScope = prevScope;
    currentObserver = prevObserver;
  }
}
function handleError(scope, error) {
  if (!scope)
    throw error;
  let i = 0, len = scope._handlers.length, coercedError = coerceError(error);
  for (i = 0; i < len; i++) {
    try {
      scope._handlers[i](coercedError);
      break;
    } catch (error2) {
      coercedError = coerceError(error2);
    }
  }
  if (i === len)
    throw coercedError;
}
function coerceError(error) {
  return error instanceof Error ? error : Error(JSON.stringify(error));
}
function read() {
  if (this._state === STATE_DISPOSED)
    return this._value;
  if (currentObserver && !this._effect) {
    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {
      currentObserversIndex++;
    } else if (!currentObservers)
      currentObservers = [this];
    else
      currentObservers.push(this);
  }
  if (this._compute)
    updateCheck(this);
  return this._value;
}
function write(newValue) {
  const value = isFunction(newValue) ? newValue(this._value) : newValue;
  if (this._changed(this._value, value)) {
    this._value = value;
    if (this._observers) {
      for (let i = 0; i < this._observers.length; i++) {
        notify(this._observers[i], STATE_DIRTY);
      }
    }
  }
  return this._value;
}
var ScopeNode = function Scope() {
  this[SCOPE] = null;
  this._nextSibling = null;
  this._prevSibling = null;
  if (currentScope)
    currentScope.append(this);
};
var ScopeProto = ScopeNode.prototype;
ScopeProto._context = {};
ScopeProto._handlers = [];
ScopeProto._compute = null;
ScopeProto._disposal = null;
ScopeProto.append = function appendScope(scope) {
  scope[SCOPE] = this;
  scope._prevSibling = this;
  scope._context = this._context;
  scope._handlers = this._handlers;
  if (this._nextSibling)
    this._nextSibling._prevSibling = scope;
  scope._nextSibling = this._nextSibling;
  this._nextSibling = scope;
};
function createScope() {
  return new ScopeNode();
}
var ComputeNode = function Computation(initialValue, compute2, options) {
  ScopeNode.call(this);
  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;
  this._init = false;
  this._effect = false;
  this._sources = null;
  this._observers = null;
  this._value = initialValue;
  this.id = options?.id ?? (this._compute ? "computed" : "signal");
  if (compute2)
    this._compute = compute2;
  if (options && options.dirty)
    this._changed = options.dirty;
};
var ComputeProto = ComputeNode.prototype;
Object.setPrototypeOf(ComputeProto, ScopeProto);
ComputeProto._changed = isNotEqual;
ComputeProto.call = read;
function createComputation(initialValue, compute2, options) {
  return new ComputeNode(initialValue, compute2, options);
}
function isNotEqual(a, b) {
  return a !== b;
}
function isFunction(value) {
  return typeof value === "function";
}
function updateCheck(node) {
  if (node._state === STATE_CHECK) {
    for (let i = 0; i < node._sources.length; i++) {
      updateCheck(node._sources[i]);
      if (node._state === STATE_DIRTY) {
        break;
      }
    }
  }
  if (node._state === STATE_DIRTY)
    update(node);
  else
    node._state = STATE_CLEAN;
}
function cleanup(node) {
  if (node._nextSibling && node._nextSibling[SCOPE] === node)
    dispose.call(node, false);
  if (node._disposal)
    emptyDisposal(node);
  node._handlers = node[SCOPE]?._handlers || [];
}
function update(node) {
  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;
  currentObservers = null;
  currentObserversIndex = 0;
  try {
    cleanup(node);
    const result = compute(node, node._compute, node);
    if (currentObservers) {
      if (node._sources)
        removeSourceObservers(node, currentObserversIndex);
      if (node._sources && currentObserversIndex > 0) {
        node._sources.length = currentObserversIndex + currentObservers.length;
        for (let i = 0; i < currentObservers.length; i++) {
          node._sources[currentObserversIndex + i] = currentObservers[i];
        }
      } else {
        node._sources = currentObservers;
      }
      let source;
      for (let i = currentObserversIndex; i < node._sources.length; i++) {
        source = node._sources[i];
        if (!source._observers)
          source._observers = [node];
        else
          source._observers.push(node);
      }
    } else if (node._sources && currentObserversIndex < node._sources.length) {
      removeSourceObservers(node, currentObserversIndex);
      node._sources.length = currentObserversIndex;
    }
    if (!node._effect && node._init) {
      write.call(node, result);
    } else {
      node._value = result;
      node._init = true;
    }
  } catch (error) {
    if (!node._init && typeof node._value === "undefined") {
      console.error(
        `computed \`${node.id}\` threw error during first run, this can be fatal.

Solutions:

1. Set the \`initial\` option to silence this error`,
        "\n2. Or, use an `effect` if the return value is not being used",
        "\n\n",
        error
      );
    }
    handleError(node, error);
    if (node._state === STATE_DIRTY) {
      cleanup(node);
      if (node._sources)
        removeSourceObservers(node, 0);
    }
    return;
  }
  currentObservers = prevObservers;
  currentObserversIndex = prevObserversIndex;
  node._state = STATE_CLEAN;
}
function notify(node, state) {
  if (node._state >= state)
    return;
  if (node._effect && node._state === STATE_CLEAN) {
    effects.push(node);
    if (!scheduledEffects)
      flushEffects();
  }
  node._state = state;
  if (node._observers) {
    for (let i = 0; i < node._observers.length; i++) {
      notify(node._observers[i], STATE_CHECK);
    }
  }
}
function removeSourceObservers(node, index) {
  let source, swap;
  for (let i = index; i < node._sources.length; i++) {
    source = node._sources[i];
    if (source._observers) {
      swap = source._observers.indexOf(node);
      source._observers[swap] = source._observers[source._observers.length - 1];
      source._observers.pop();
    }
  }
}
function signal(initialValue, options) {
  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);
  signal2.node = node;
  signal2.set = write.bind(node);
  return signal2;
}
function isReadSignal(fn) {
  return isFunction(fn);
}
function computed(compute2, options) {
  {
    const node = createComputation(
      options?.initial,
      compute2,
      options
    );
    const signal2 = read.bind(node);
    signal2.node = node;
    return signal2;
  }
}
function effect(effect22, options) {
  const signal2 = createComputation(
    null,
    function runEffect() {
      let effectResult = effect22();
      isFunction(effectResult) && onDispose(effectResult);
      return null;
    },
    { id: options?.id ?? "effect" }
  );
  signal2._effect = true;
  update(signal2);
  {
    return function stopEffect() {
      dispose.call(signal2, true);
    };
  }
}
function isWriteSignal(fn) {
  return isReadSignal(fn) && "set" in fn;
}

// ../../node_modules/.pnpm/maverick.js@0.37.0/node_modules/maverick.js/dist/dev/chunks/chunk-NQ7TQAU7.js
function noop(...args) {
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return value?.constructor === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction2(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return value === window;
}
function createContext(provide) {
  return { id: Symbol(), provide };
}
function provideContext(context, value, scope = getScope()) {
  if (!scope) {
    throw Error("[maverick] attempting to provide context outside `root` or `setup` function");
  }
  const hasProvidedValue = !isUndefined(value);
  if (!hasProvidedValue && !context.provide) {
    throw Error("[maverick] context can not be provided without a value or `provide` function");
  }
  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);
}
function useContext(context) {
  const value = getContext(context.id);
  if (isUndefined(value)) {
    throw Error("[maverick] attempting to use context without providing first");
  }
  return value;
}
function hasProvidedContext(context) {
  return !isUndefined(getContext(context.id));
}
var StoreFactory = class {
  constructor(record) {
    this.id = Symbol("STORE");
    this.record = record;
    this._descriptors = Object.getOwnPropertyDescriptors(record);
  }
  create() {
    const store = {}, state = new Proxy(store, { get: (_, prop) => store[prop]() });
    for (const name of Object.keys(this.record)) {
      const getter = this._descriptors[name].get;
      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);
    }
    return store;
  }
  reset(record, filter) {
    for (const name of Object.keys(record)) {
      if (!this._descriptors[name].get && (!filter || filter(name))) {
        record[name].set(this.record[name]);
      }
    }
  }
};
function useStore(store) {
  return useContext(store);
}
var effect2 = effect;
function unwrap(fn) {
  return isFunction2(fn) ? fn() : fn;
}
function unwrapDeep(fn) {
  let value = fn;
  while (typeof value === "function")
    value = value();
  return value;
}

// ../../node_modules/.pnpm/maverick.js@0.37.0/node_modules/maverick.js/dist/dev/chunks/chunk-VABDA4SA.js
var EVENT = Event;
var DOM_EVENT = Symbol("DOM_EVENT");
var _a;
var DOMEvent = class extends EVENT {
  constructor(type, ...init) {
    super(type, init[0]);
    this[_a] = true;
    this.detail = init[0]?.detail;
    this.trigger = init[0]?.trigger;
  }
  /**
   * Walks up the event chain (following each `trigger`) and returns the origin event
   * that started the chain.
   */
  get originEvent() {
    return getOriginEvent(this) ?? this;
  }
  /**
   * Walks up the event chain (following each `trigger`) and determines whether the initial
   * event was triggered by the end user (ie: check whether `isTrusted` on the `originEvent` `true`).
   */
  get isOriginTrusted() {
    return getOriginEvent(this)?.isTrusted ?? false;
  }
};
_a = DOM_EVENT;
function isDOMEvent(event) {
  return !!event?.[DOM_EVENT];
}
function getOriginEvent(event) {
  let trigger = event.trigger;
  while (trigger && trigger.trigger) {
    trigger = trigger.trigger;
  }
  return trigger;
}
function walkTriggerEventChain(event, callback) {
  if (!isDOMEvent(event))
    return;
  let trigger = event.trigger;
  while (trigger) {
    const returnValue = callback(trigger);
    if (returnValue)
      return [trigger, returnValue];
    trigger = trigger.trigger;
  }
  return;
}
function findTriggerEvent(event, type) {
  return walkTriggerEventChain(event, (e) => e.type === type)?.[0];
}
function hasTriggerEvent(event, type) {
  return !!findTriggerEvent(event, type);
}
function appendTriggerEvent(event, trigger) {
  const origin = getOriginEvent(event) ?? event;
  if (origin === trigger) {
    throw Error(
      "[maverick] attemping to append event as a trigger on itself (cyclic)"
    );
  }
  if (typeof origin.trigger !== "undefined") {
    console.warn(
      `[maverick] overwriting existing trigger event: \`${origin.trigger.type}\` -> \`${trigger?.type}\`

`,
      "Event:\n",
      event,
      "Origin Event:\n",
      origin,
      "Trigger Event:\n",
      trigger
    );
  }
  Object.defineProperty(origin, "trigger", {
    configurable: true,
    enumerable: true,
    get: () => trigger
  });
}
var EventsTarget = class extends EventTarget {
  addEventListener(type, callback, options) {
    return super.addEventListener(type, callback, options);
  }
  removeEventListener(type, callback, options) {
    return super.removeEventListener(type, callback, options);
  }
};
function listenEvent(target, type, handler, options) {
  target.addEventListener(type, handler, options);
  return onDispose(() => target.removeEventListener(type, handler, options));
}
function isPointerEvent(event) {
  return !!event?.type.startsWith("pointer");
}
function isTouchEvent(event) {
  return !!event?.type.startsWith("touch");
}
function isMouseEvent(event) {
  return /^(click|mouse)/.test(event?.type ?? "");
}
function isKeyboardEvent(event) {
  return !!event?.type.startsWith("key");
}
function wasEnterKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Enter";
}
function wasEscapeKeyPressed(event) {
  return isKeyboardEvent(event) && event.key === "Escape";
}
function isKeyboardClick(event) {
  return isKeyboardEvent(event) && (event.key === "Enter" || event.key === " ");
}
function isDOMNode(node) {
  return node instanceof Node;
}
function isDOMElement(node) {
  return isDOMNode(node) && node.nodeType === 1;
}
function isDOMFragment(node) {
  return isDOMNode(node) && node.nodeType === 11;
}
function createFragment() {
  return document.createDocumentFragment();
}
function createComment(data) {
  return document.createComment(data);
}
function setAttribute(host, name, value) {
  if (!value && value !== "" && value !== 0) {
    host.removeAttribute(name);
  } else {
    const attrValue = value + "";
    if (host.getAttribute(name) !== attrValue) {
      host.setAttribute(name, attrValue);
    }
  }
}
function setStyle(host, property, value) {
  if (!value && value !== 0) {
    host.style.removeProperty(property);
  } else {
    host.style.setProperty(property, value + "");
  }
}
function toggleClass(host, name, value) {
  host.classList[value ? "add" : "remove"](name);
}
function getSlottedChildren(el, name) {
  const selector = name ? `slot[name="${name}"]` : "slot:not([name])";
  const slot = el.shadowRoot?.querySelector(selector);
  const childNodes = slot?.assignedNodes({ flatten: true }) ?? [];
  return Array.prototype.filter.call(childNodes, (node) => node.nodeType == 1);
}
function attachDeclarativeShadowDOM(element) {
  const template = element.firstChild;
  const mode = template.getAttribute("shadowroot");
  const shadowRoot = template.parentNode.attachShadow({ mode });
  shadowRoot.appendChild(template.content);
  template.remove();
}
function run(fn) {
  return fn();
}
function runAll(fns, arg) {
  for (const fn of fns)
    fn(arg);
}
function camelToKebabCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function camelToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/([A-Z])/g, " $1"));
}
function kebabToCamelCase(str) {
  return str.replace(/-./g, (x) => x[1].toUpperCase());
}
function kebabToPascalCase(str) {
  return kebabToTitleCase(str).replace(/\s/g, "");
}
function kebabToTitleCase(str) {
  return uppercaseFirstChar(str.replace(/-./g, (x) => " " + x[1].toUpperCase()));
}
function uppercaseFirstChar(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function lowercaseFirstLetter(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
var trailingSemicolon = /;\s*$/;
function trimTrailingSemicolon(text) {
  return text.replace(trailingSemicolon, "");
}
function flattenArray(array) {
  const flat = [];
  for (let i = 0; i < array.length; i++) {
    if (isArray(array[i])) {
      flat.push(...flattenArray(array[i]));
    } else if (array[i] || array[i] === 0) {
      flat.push(array[i]);
    }
  }
  return flat;
}

// ../../node_modules/.pnpm/maverick.js@0.37.0/node_modules/maverick.js/dist/dev/std.js
function ariaBool(value) {
  return value ? "true" : "false";
}
function createDisposalBin() {
  const disposal = /* @__PURE__ */ new Set();
  return {
    add(...callbacks) {
      for (const callback of callbacks)
        disposal.add(callback);
    },
    empty() {
      for (const callback of disposal)
        callback();
      disposal.clear();
    }
  };
}
function useDisposalBin() {
  const disposal = createDisposalBin();
  onDispose(disposal.empty);
  return disposal;
}
function keysOf(obj) {
  return Object.keys(obj);
}
function mergeProperties(...sources) {
  const target = {};
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
  }
  return target;
}
function pick(source, props) {
  const target = {};
  for (const prop of props) {
    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
  }
  return target;
}
function omit(source, props) {
  return pick(
    source,
    keysOf(source).filter((key) => !props.includes(key))
  );
}
function deferredPromise() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function timedPromise(promise, timeout, timeoutMsg) {
  const timer = new Promise((_, reject) => {
    const timerId = setTimeout(() => {
      clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}
function waitTimeout(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function waitAnimationFrame(callback) {
  return new Promise((resolve) => {
    window.requestAnimationFrame((time) => {
      callback?.(time);
      resolve();
    });
  });
}
function animationFrameThrottle(func) {
  let id = -1, lastArgs;
  function throttle(...args) {
    lastArgs = args;
    if (id >= 0)
      return;
    id = window.requestAnimationFrame(() => {
      func.apply(this, lastArgs);
      id = -1;
      lastArgs = void 0;
    });
  }
  return throttle;
}
var requestIdleCallback = "requestIdleCallback" in window ? window.requestIdleCallback : (cb) => window.requestAnimationFrame(cb);
function waitIdlePeriod(callback, options) {
  return new Promise((resolve) => {
    requestIdleCallback((deadline) => {
      callback?.(deadline);
      resolve();
    }, options);
  });
}

export { DOMEvent, EventsTarget, StoreFactory, animationFrameThrottle, appendTriggerEvent, ariaBool, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, computed, createComment, createContext, createDisposalBin, createFragment, createRegex, deferredPromise, effect, effect2, findTriggerEvent, flattenArray, getOriginEvent, getScope, getSlottedChildren, hasProvidedContext, hasTriggerEvent, isArray, isBoolean, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isFunction, isFunction2, isKeyboardClick, isKeyboardEvent, isMouseEvent, isNil, isNull, isNumber, isObject, isPointerEvent, isString, isTouchEvent, isUndefined, isWindow, isWriteSignal, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, keysOf, listenEvent, lowercaseFirstLetter, mergeProperties, noop, omit, onDispose, peek, pick, provideContext, root, run, runAll, scoped, setAttribute, setStyle, signal, tick, timedPromise, toggleClass, trimTrailingSemicolon, untrack, unwrap, unwrapDeep, uppercaseFirstChar, useContext, useDisposalBin, useStore, waitAnimationFrame, waitIdlePeriod, waitTimeout, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed };
