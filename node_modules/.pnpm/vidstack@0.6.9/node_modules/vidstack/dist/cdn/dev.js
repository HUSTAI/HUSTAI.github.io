import { SET_AUTO_QUALITY, ENABLE_AUTO_QUALITY, coerceToError } from './chunks/chunk-7QOJR2JC.js';
import { TEXT_TRACK_CROSSORIGIN, isTrackCaptionKind, findActiveCue, isCueActive, onTrackChapterChange, preconnect, TEXT_TRACK_CAN_LOAD, TEXT_TRACK_UPDATE_ACTIVE_CUES, getRequestCredentials, ATTACH_VIDEO, TEXT_TRACK_NATIVE_HLS, TextTrack, TEXT_TRACK_ON_MODE_CHANGE, TEXT_TRACK_NATIVE } from './chunks/chunk-NE32YW7I.js';
import './chunks/chunk-Q2XL2SHG.js';
import './chunks/chunk-LHDAEDSM.js';
import { isHLSSupported, canOrientScreen, IS_IPHONE, clampNumber, round, canChangeVolume, IS_SAFARI, LIST_ON_USER_SELECT, LIST_ON_RESET, LIST_RESET, LIST_ADD, LIST_REMOVE, getNumberOfDecimalPlaces, LIST_READONLY, LIST_ON_REMOVE, LIST_SET_READONLY, LIST_SELECT, AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, canPlayHLSNatively, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunks/chunk-XBYQR33W.js';
import { createComment, createContext, signal, listenEvent, StoreFactory, isArray, camelToKebabCase, isUndefined, isNumber, getScope, effect2, computed, provideContext, setAttribute, uppercaseFirstChar, peek, isWriteSignal, ariaBool, isPointerEvent, isMouseEvent, isTouchEvent, kebabToCamelCase, useContext, hasProvidedContext, animationFrameThrottle, isKeyboardEvent, setStyle, scoped, tick, onDispose, useStore, isNull, isFunction2, root, isFunction, effect, runAll, isBoolean, noop, untrack, isDOMElement, isKeyboardClick, isString, deferredPromise, DOMEvent, appendTriggerEvent, createDisposalBin, isDOMEvent, isDOMNode, unwrapDeep, flattenArray, createFragment, isObject, EventsTarget } from './chunks/chunk-BFUJ5USN.js';
import { CaptionsRenderer, renderVTTCueString, updateTimedVTTCueNodes } from './chunks/chunk-3SNURE54.js';
import './chunks/chunk-MPQD3WXJ.js';
import './chunks/chunk-7SNUKWCT.js';
import './chunks/chunk-WPVULLF5.js';
import './chunks/chunk-WNZBENRE.js';
import './chunks/chunk-TYOX6JVW.js';
import './chunks/chunk-ZUP6VWH2.js';
import './chunks/chunk-MF43X3Y3.js';
import './chunks/chunk-LBH32PRG.js';
import { volume_high_default } from './chunks/chunk-KQUCP2EG.js';
import { volume_low_default } from './chunks/chunk-DZHDFPQR.js';
import './chunks/chunk-5AX42AEN.js';
import './chunks/chunk-I5ZNHUW2.js';
import './chunks/chunk-W4QNKYWE.js';
import './chunks/chunk-YGXIG4UH.js';
import './chunks/chunk-Z3R7IJO3.js';
import './chunks/chunk-2IK7NGIX.js';
import './chunks/chunk-KITPHWQZ.js';
import './chunks/chunk-HKZBS6I2.js';
import './chunks/chunk-RKG5SB2X.js';
import './chunks/chunk-IDM7ODL5.js';
import { seek_forward_default } from './chunks/chunk-CPWHUQBL.js';
import './chunks/chunk-EOTLQ6GG.js';
import { settings_menu_default } from './chunks/chunk-TT5YQ2JU.js';
import './chunks/chunk-3V72BDJY.js';
import { settings_default } from './chunks/chunk-764WJ7YC.js';
import './chunks/chunk-J24QS7SA.js';
import { replay_default } from './chunks/chunk-NRSSXRVS.js';
import './chunks/chunk-QKK3NKYN.js';
import './chunks/chunk-VTSXHYMT.js';
import { seek_backward_10_default } from './chunks/chunk-FNH5S7FD.js';
import './chunks/chunk-DJRMQYAX.js';
import './chunks/chunk-KU5TXDFG.js';
import { seek_backward_default } from './chunks/chunk-PDX6CZZG.js';
import { seek_forward_10_default } from './chunks/chunk-B37QG5XE.js';
import './chunks/chunk-NVFMRJVN.js';
import './chunks/chunk-HZSUQI6T.js';
import './chunks/chunk-MHHAGIRI.js';
import './chunks/chunk-4EBMB2HT.js';
import './chunks/chunk-BQ2XLH4F.js';
import './chunks/chunk-E23QUJXR.js';
import './chunks/chunk-BM7OTNV5.js';
import './chunks/chunk-H4SJAY3E.js';
import { odometer_default } from './chunks/chunk-QYSGNYZ4.js';
import { pause_default } from './chunks/chunk-2DGYZ3AT.js';
import { picture_in_picture_exit_default } from './chunks/chunk-U6WW63HQ.js';
import { picture_in_picture_default } from './chunks/chunk-KMLSRSZ2.js';
import { play_default } from './chunks/chunk-N7ILVN7U.js';
import './chunks/chunk-GE45ZFMY.js';
import './chunks/chunk-7FVMKTUJ.js';
import './chunks/chunk-4WEPWNB2.js';
import './chunks/chunk-4YWO2LEM.js';
import './chunks/chunk-S7OQOFKY.js';
import './chunks/chunk-3A3NMPK7.js';
import './chunks/chunk-KAWCVYT7.js';
import { music_default } from './chunks/chunk-YKIOTB2J.js';
import { mute_default } from './chunks/chunk-IVWVADOA.js';
import './chunks/chunk-FGT5HSCH.js';
import './chunks/chunk-UBC7ZJMJ.js';
import './chunks/chunk-56GYOYH6.js';
import './chunks/chunk-EZNG2RX5.js';
import './chunks/chunk-4XZ5VLZQ.js';
import './chunks/chunk-OBWYPIXU.js';
import './chunks/chunk-YR2WIJFK.js';
import './chunks/chunk-OBC7ZDNY.js';
import './chunks/chunk-DQEIJ6AA.js';
import './chunks/chunk-HVROBH6S.js';
import './chunks/chunk-26ZQYIUZ.js';
import './chunks/chunk-BUNPCUTG.js';
import './chunks/chunk-L6L3JFBG.js';
import './chunks/chunk-WQYSIU7X.js';
import './chunks/chunk-Y2E5LSRA.js';
import './chunks/chunk-MH2CV2WS.js';
import { fullscreen_exit_default } from './chunks/chunk-UXSS3YXT.js';
import { fullscreen_default } from './chunks/chunk-A6X7WAFA.js';
import './chunks/chunk-6SVCWHLM.js';
import { closed_captions_on_default } from './chunks/chunk-FJ2OEY6P.js';
import { closed_captions_default } from './chunks/chunk-3XSNY5HY.js';
import './chunks/chunk-YFCPYTCS.js';
import './chunks/chunk-IGIIT6ND.js';
import './chunks/chunk-APKNUUBH.js';
import './chunks/chunk-W47WM6LO.js';
import './chunks/chunk-LINOWMLN.js';
import { chapters_default } from './chunks/chunk-FPO3FMZ7.js';
import './chunks/chunk-HZPJZWMN.js';
import './chunks/chunk-4OVZOH72.js';
import './chunks/chunk-DJG366PE.js';
import './chunks/chunk-KGIJMXAP.js';
import { chevron_right_default } from './chunks/chunk-LBXYQH7K.js';
import './chunks/chunk-DT22F76Z.js';
import './chunks/chunk-OTPQATWR.js';
import './chunks/chunk-7JCXTZWI.js';
import './chunks/chunk-RBPUEIYY.js';
import './chunks/chunk-A7U6TVNK.js';
import { arrow_left_default } from './chunks/chunk-AJFBO2QS.js';
import './chunks/chunk-M2YWWI52.js';
import './chunks/chunk-TCFNQMIV.js';
import './chunks/chunk-ZGFCCRQO.js';
import './chunks/chunk-ZB2Y4MES.js';
import './chunks/chunk-X3SG235Y.js';
import './chunks/chunk-A3KOXRAG.js';
import './chunks/chunk-VE4U5GVE.js';
import './chunks/chunk-NCWLE3EN.js';
import './chunks/chunk-5CFDMIAZ.js';
import './chunks/chunk-PTJHYVQF.js';
import './chunks/chunk-6WF5PHO2.js';
import { __decorateClass } from './chunks/chunk-VPSTUDLO.js';

// ../../node_modules/.pnpm/maverick.js@0.37.0/node_modules/maverick.js/dist/dev/chunks/chunk-FIEGXSET.js
var ComponentController = class {
  /**
   * The custom element this component is attached to. This is safe to use server-side with the
   * limited API listed below.
   *
   * **Important:** Only specific DOM APIs are safe to call server-side. This includes:
   *
   * - Attributes: `getAttribute`, `setAttribute`, `removeAttribute`, and `hasAttribute`
   * - Classes: `classList` API
   * - Styles: `style` API
   * - Events (noop): `addEventListener`, `removeEventListener`, and `dispatchEvent`
   */
  get el() {
    return this.instance._el;
  }
  /**
   * Reactive component properties.
   */
  get $props() {
    return this.instance._props;
  }
  /**
   * Reactive component store.
   */
  get $store() {
    return this.instance._store;
  }
  constructor(instance) {
    this.instance = instance;
    if (this.onAttach)
      instance._attachCallbacks.push(this.onAttach.bind(this));
    if (this.onConnect)
      instance._connectCallbacks.push(this.onConnect.bind(this));
    if (this.onDisconnect)
      instance._disconnectCallbacks.push(this.onDisconnect.bind(this));
    if (this.onDestroy)
      instance._destroyCallbacks.push(this.onDestroy.bind(this));
  }
  /**
   * This method can be used to specify attributes that should be set on the host element. Any
   * attributes that are assigned to a function will be considered a signal and updated accordingly.
   */
  setAttributes(attributes) {
    if (this.instance._attrs)
      Object.assign(this.instance._attrs, attributes);
  }
  /**
   * This method can be used to specify styles that should set be set on the host element. Any
   * styles that are assigned to a function will be considered a signal and updated accordingly.
   */
  setStyles(styles) {
    if (this.instance._styles)
      Object.assign(this.instance._styles, styles);
  }
  /**
   * This method is used to satisfy the CSS variables contract specified on the current
   * custom element definition. Other CSS variables can be set via the `setStyles` method.
   */
  setCSSVars(vars) {
    this.setStyles(vars);
  }
  /**
   * Type-safe utility for creating component DOM events.
   */
  createEvent(type, ...init2) {
    return new DOMEvent(type, init2[0]);
  }
  /**
   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
   * match all component events.
   */
  dispatch(type, ...init2) {
    if (!this.el)
      return;
    const event = new DOMEvent(type, init2[0]);
    this.el.dispatchEvent(event);
  }
  /**
   * Adds an event listener for the given `type` and returns a function which can be invoked to
   * remove the event listener.
   *
   * - The listener is removed if the current scope is disposed.
   * - This method is safe to use on the server (noop).
   */
  listen(type, handler, options) {
    if (!this.el)
      return noop;
    return listenEvent(this.el, type, handler, options);
  }
};
var Component = class extends ComponentController {
  constructor(instance) {
    super(instance);
    if (this.render && !instance._innerHTML && !instance._renderer) {
      instance._renderer = this.render.bind(this);
    }
  }
  destroy() {
    this.instance._destroy();
  }
};
var createMarkerWalker = (root4) => (
  // @ts-expect-error - filter accepts `boolean` but not typed.
  document.createTreeWalker(root4, NodeFilter.SHOW_COMMENT, (node) => node.nodeValue === "$")
);
var hydration = null;
function runHydration(run, options) {
  const prev = hydration;
  hydration = { w: createMarkerWalker(options.target) };
  const result = run();
  hydration = prev;
  return result;
}
var CONNECTED = /* @__PURE__ */ Symbol("CONNECTED");
var INSERT_MARKER_NODE = createComment("$$");
var END_MARKER = /* @__PURE__ */ Symbol("END_MARKER");
var END_MARKER_NODE = /* @__PURE__ */ createComment("/$");
var ARRAY_END_MARKER_VALUE = "/[]";
function insertLite(parent, value, before) {
  let isSignal = isFunction2(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction2(value);
  }
  if (isSignal) {
    insertEffect(parent, value, before);
  } else if (!hydration && (value || value === 0)) {
    addChild(
      parent,
      isArray(value) ? resolveArray2(value) : isDOMNode(value) ? value : document.createTextNode(value + ""),
      before
    );
  }
}
function addChild(parent, node, before) {
  if (!node)
    return;
  if (before)
    parent.insertBefore(node, before);
  else
    parent.appendChild(node);
}
function insertEffect(parent, value, before) {
  const marker = before && before.nodeType === 8 ? before : INSERT_MARKER_NODE.cloneNode();
  if (marker !== before)
    addChild(parent, marker, before);
  effect2(() => void insertExpression2(marker, unwrapDeep(value)));
}
function insertExpression2(start, value) {
  const end = start[END_MARKER];
  if (isArray(value)) {
    if (hydration) {
      start[END_MARKER] = findArrayEndMarker(start);
    } else {
      if (end)
        removeOldNodes(start, end);
      const fragment = resolveArray2(value);
      if (!fragment)
        return;
      if (!end)
        fragment.appendChild(createEndMarker(start));
      start.after(fragment);
    }
  } else if (isDOMNode(value)) {
    if (end)
      removeOldNodes(start, end);
    if (!hydration)
      start.after(value);
    if (!end)
      value.after(createEndMarker(start));
  } else if (isString(value) || isNumber(value)) {
    if (start[CONNECTED]) {
      start.nextSibling.data = value + "";
      return;
    }
    if (end)
      removeOldNodes(start, end);
    let text;
    if (!hydration) {
      text = document.createTextNode(value + "");
      start.after(text);
    } else {
      text = start.nextSibling;
    }
    start[CONNECTED] = true;
    if (!end)
      text.after(createEndMarker(start));
  } else if (end) {
    removeOldNodes(start, end);
  }
}
function createEndMarker(start) {
  return start[END_MARKER] = END_MARKER_NODE.cloneNode();
}
function findArrayEndMarker(node) {
  while (node) {
    if (node.nodeType === 8 && node.nodeValue === ARRAY_END_MARKER_VALUE)
      return node;
    node = node.nextSibling;
  }
}
function removeOldNodes(start, end) {
  while (start.nextSibling !== end)
    start.nextSibling.remove();
  start[CONNECTED] = false;
}
function resolveArray2(value) {
  const flattened = flattenArray(value);
  if (!flattened.length)
    return null;
  const fragment = createFragment();
  for (let i = 0; i < flattened.length; i++) {
    const child = flattened[i];
    if (isFunction2(child)) {
      insertEffect(fragment, child);
    } else {
      fragment.append(child);
    }
  }
  return fragment;
}
function registerLiteCustomElement(Component2) {
  register(Component2, {
    insert: insertLite
  });
}
var DOM_ELEMENT_REGISTRY = Symbol("MAVERICK_REGISTRY");
function register(Component2, init2) {
  const tagName = Component2.el.tagName;
  if (!window.customElements.get(tagName)) {
    if (!window[DOM_ELEMENT_REGISTRY])
      window[DOM_ELEMENT_REGISTRY] = /* @__PURE__ */ new Map();
    window[DOM_ELEMENT_REGISTRY].set(tagName, Component2);
    window.customElements.define(tagName, createHTMLElement(Component2, init2));
  }
}
function $$_create_template(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
function $$_setup_custom_element(host, props) {
  const Component2 = window[DOM_ELEMENT_REGISTRY]?.get(host.localName);
  if (!Component2) {
    throw Error(
      `[maverick] custom element not registered: ${host.localName}`
    );
  }
  const component = createComponent(Component2, { props });
  host.attachComponent(component);
  return component.instance._scope;
}
function $$_clone(fragment) {
  const clone = document.importNode(fragment, true);
  return clone.firstElementChild;
}
function $$_create_element(tagName) {
  return document.createElement(tagName);
}
var $$_insert_lite = insertLite;
function $$_create_component(component, props = {}) {
  return peek(() => component(props));
}
var $$CHILDREN = /* @__PURE__ */ Symbol("$$CHILDREN");
function $$_ref(element, ref) {
  if (isArray(ref)) {
    ref.filter(isFunction2).forEach((ref2) => ref2(element));
  } else if (isFunction2(ref)) {
    ref(element);
  }
}
var $$_attr = setAttribute;
function $$_listen(target, type, handler, capture = false) {
  if (isFunction2(handler)) {
    listenEvent(target, type, handler, { capture });
  }
}
var $$_peek = peek;
var $$_scoped = scoped;
var $$_effect = effect2;
var CONNECT = /* @__PURE__ */ Symbol("CONNECT");
var PROPS = /* @__PURE__ */ Symbol("PROPS");
var METHODS = /* @__PURE__ */ Symbol("METHODS");
function createComponent(Component2, init2) {
  const instance = new ComponentInstance(Component2, init2);
  return scoped(() => new Component2(instance), instance._scope);
}
var ComponentInstance = class {
  constructor(Component2, init2 = {}) {
    this._el = null;
    this._renderer = null;
    this._innerHTML = false;
    this._destroyed = false;
    this._attrs = {};
    this._styles = {};
    this._props = {};
    this._state = null;
    this._store = null;
    this._attachCallbacks = [];
    this._connectCallbacks = [];
    this._disconnectCallbacks = [];
    this._destroyCallbacks = [];
    root((dispose) => {
      this._scope = getScope();
      this._dispose = dispose;
      if (init2.scope)
        init2.scope.append(this._scope);
      const store = Component2.el.store;
      if (store) {
        this._store = store.create();
        this._state = new Proxy(this._store, {
          get: (_, prop2) => this._store[prop2]()
        });
        provideContext(store, this._store);
      }
      const props = Component2.el.props;
      if (props) {
        this._props = createInstanceProps(props);
        if (init2.props) {
          for (const prop2 of Object.keys(init2.props)) {
            if (prop2 in props) {
              const value = init2.props[prop2];
              if (isFunction(value)) {
                effect(() => void this._props[prop2].set(value()));
              } else {
                this._props[prop2].set(value);
              }
            }
          }
        }
      }
      if (init2.props?.innerHTML) {
        this._innerHTML = true;
      }
      onDispose(this._destroy.bind(this));
    });
  }
  _destroy() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    for (const destroy of this._destroyCallbacks) {
      scoped(() => destroy(this._el), this._scope);
    }
    this._el?.destroy();
    this._attachCallbacks.length = 0;
    this._connectCallbacks.length = 0;
    this._disconnectCallbacks.length = 0;
    this._destroyCallbacks.length = 0;
    tick();
    this._dispose();
    this._el = null;
    this._renderer = null;
  }
};
function createInstanceProps(defs) {
  const props = {};
  for (const name of Object.keys(defs)) {
    const def = defs[name];
    props[name] = signal(def.value, def);
  }
  return props;
}
async function setup(host) {
  const parent = findParent(host);
  const hostCtor = host.constructor, componentCtor = hostCtor._component;
  if (parent) {
    await customElements.whenDefined(parent.localName);
    parent[CONNECT] === true || await new Promise((res) => parent[CONNECT].push(res));
  }
  if (host.isConnected) {
    if (parent?.keepAlive)
      host.keepAlive = true;
    host.attachComponent(
      createComponent(componentCtor, {
        scope: parent?.component?.instance._scope
      })
    );
  }
}
function resolvePropsFromAttrs(host) {
  const hostCtor = host.constructor, componentCtor = hostCtor._component, props = {};
  if (!hostCtor._attrs)
    return props;
  for (const attr of host.attributes) {
    let propName = hostCtor._attrs.get(attr.name), convert = propName && componentCtor.el.props[propName].type?.from;
    if (convert) {
      let attrValue = host.getAttribute(attr.name);
      props[propName] = convert(attrValue);
    }
  }
  return props;
}
function findParent(host) {
  let hostCtor = host.constructor, componentCtor = hostCtor._component, node = host.parentNode, prefix = componentCtor.el.tagName.split("-", 1)[0] + "-";
  while (node) {
    if (node.nodeType === 1 && node.localName.startsWith(prefix)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function createHTMLElement(Component2, init2) {
  const _register = Component2.register;
  if (Component2.register) {
    const result = isArray(_register) ? _register : _register?.();
    if (isArray(result))
      for (const Component3 of result)
        register(Component3, init2);
  }
  let attrs;
  if (Component2.el.props) {
    attrs = /* @__PURE__ */ new Map();
    for (const propName of Object.keys(Component2.el.props)) {
      const def = Component2.el.props[propName];
      const attr = def.attribute;
      if (attr !== false) {
        const attrName = attr ?? camelToKebabCase(propName);
        attrs.set(attrName, propName);
      }
    }
  }
  class MaverickElement extends HTMLCustomElement {
    static get _component() {
      return Component2;
    }
  }
  MaverickElement._init = init2;
  MaverickElement._attrs = attrs;
  const proto = MaverickElement.prototype, componentProto = Component2.prototype;
  if (Component2.el.props) {
    for (const prop2 of Object.keys(Component2.el.props)) {
      Object.defineProperty(proto, prop2, {
        enumerable: true,
        configurable: true,
        get() {
          return !this.component ? Component2.el.props[prop2].value : this.component.instance._props[prop2]();
        },
        set(value) {
          const fn = () => this.component.instance._props[prop2].set(value);
          if (!this.component) {
            this._queuedActions.delete(prop2);
            this._queuedActions.set(prop2, fn);
            return;
          }
          fn();
        }
      });
    }
  }
  if (componentProto[PROPS]) {
    for (const name of componentProto[PROPS]) {
      Object.defineProperty(proto, name, {
        enumerable: true,
        configurable: true,
        get() {
          return this.component ? this.component[name] : void 0;
        },
        set(value) {
          if (!this.component) {
            this._queuedActions.delete(name);
            this._queuedActions.set(name, () => {
              this.component[name] = value;
            });
            return;
          }
          this.component[name] = value;
        }
      });
    }
  }
  if (componentProto[METHODS]) {
    for (const name of componentProto[METHODS]) {
      proto[name] = function(...args) {
        if (!this.component)
          this._throwAttachError([`el.${name}(...)`]);
        return this.component[name](...args);
      };
    }
  }
  return MaverickElement;
}
var HTML_ELEMENT = HTMLElement;
var _a;
var HTMLCustomElement = class extends HTML_ELEMENT {
  constructor() {
    super(...arguments);
    this._connected = false;
    this._destroyed = false;
    this._component = null;
    this._connectScope = null;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this._disconnectCallbacks = [];
    this._queuedActions = /* @__PURE__ */ new Map();
    this.keepAlive = false;
    this[_a] = [];
    this._pendingSetup = false;
  }
  get _delegate() {
    return this.hasAttribute("mk-d");
  }
  get component() {
    return this._component;
  }
  get $store() {
    return this._component?.instance._store;
  }
  get state() {
    if (!this._component) {
      this._throwAttachError(["el.state.foo"]);
    }
    return this._component.instance._state;
  }
  static get observedAttributes() {
    return this._attrs ? Array.from(this._attrs.keys()) : [];
  }
  attributeChangedCallback(name, _, newValue) {
    const ctor = this.constructor;
    if (!this._component || !ctor._attrs)
      return;
    const propName = ctor._attrs.get(name);
    const from = ctor._component.el.props[propName]?.type?.from;
    if (from)
      this._component.instance._props[propName].set(from(newValue));
  }
  connectedCallback() {
    const instance = this._component?.instance;
    if (!this._delegate && !instance)
      return this._setup();
    if (!instance || !this.isConnected || this._connected)
      return;
    if (this._destroyed) {
      {
        throw Error(
          "[maverick] attempting to connect an element that has been destroyed"
        );
      }
    }
    if (this.hasAttribute("keep-alive"))
      this.keepAlive = true;
    this._connected = true;
    if (instance._connectCallbacks.length) {
      scoped(() => {
        root((dispose) => {
          this._connectScope = getScope();
          for (const connectCallback of instance._connectCallbacks) {
            scoped(() => {
              const disconnectCallback = connectCallback(this);
              if (isFunction(disconnectCallback)) {
                this._disconnectCallbacks.push(disconnectCallback);
              }
            }, this._connectScope);
          }
          this._disconnectCallbacks.push(dispose);
        });
      }, instance._scope);
    }
    if (isArray(this[CONNECT])) {
      runAll(this[CONNECT], this);
      this[CONNECT] = true;
    }
    return;
  }
  disconnectedCallback() {
    const instance = this._component?.instance;
    if (!this._connected || this._destroyed)
      return;
    this._connected = false;
    for (const callback of this._disconnectCallbacks) {
      scoped(callback, this._connectScope);
    }
    if (instance?._disconnectCallbacks.length) {
      for (const callback of instance._disconnectCallbacks) {
        scoped(() => callback(this), instance._scope);
      }
    }
    this._connectScope = null;
    if (!this._delegate && !this.keepAlive) {
      requestAnimationFrame(() => {
        if (!this.isConnected) {
          instance?._destroy();
          this._destroyed = true;
        }
      });
    }
  }
  attachComponent(component) {
    const instance = component.instance, ctor = this.constructor, def = ctor._component.el, init2 = ctor._init;
    if (this._component) {
      console.warn(`[maverick] element \`${def.tagName}\` already has attached component`);
    }
    if (this._destroyed) {
      console.warn(`[maverick] attempted attaching to destroyed element \`${def.tagName}\``);
    }
    if (this._component || this._destroyed)
      return;
    scoped(() => {
      this._root = instance._renderer ? def.shadowRoot ? this.shadowRoot ?? this.attachShadow(isBoolean(def.shadowRoot) ? { mode: "open" } : def.shadowRoot) : resolveShadowRootElement(this) : null;
      if (def.css && !init2?.adoptCSS) {
        console.warn(
          `[maverick] \`css\` was provided for \`${def.tagName}\` but element registration doesn't support adopting stylesheets. Resolve this by registering element with \`registerElement\` instead of lite or headless.`
        );
      }
      if (!hydration && def.shadowRoot && def.css && init2?.adoptCSS) {
        init2.adoptCSS(this._root, def.css);
      }
      instance._el = this;
      this._component = component;
      const attrValues = resolvePropsFromAttrs(this);
      for (const name of Object.keys(attrValues)) {
        instance._props[name].set(attrValues[name]);
      }
      if (this._queuedActions?.size) {
        for (const action of this._queuedActions.values())
          action();
      }
      this._queuedActions = null;
      for (const callback of [...instance._attachCallbacks, ...this._attachCallbacks]) {
        scoped(() => callback(this), instance._scope);
      }
      instance._attachCallbacks.length = 0;
      this._attachCallbacks = null;
      const $attrs = instance._attrs, $styles = instance._styles;
      if ($attrs) {
        for (const name of Object.keys($attrs)) {
          if (isFunction($attrs[name])) {
            effect(() => setAttribute(this, name, $attrs[name]()));
          } else {
            setAttribute(this, name, $attrs[name]);
          }
        }
      }
      if ($styles) {
        for (const name of Object.keys($styles)) {
          if (isFunction($styles[name])) {
            effect(() => setStyle(this, name, $styles[name]()));
          } else {
            setStyle(this, name, $styles[name]);
          }
        }
      }
      this.dispatchEvent(new Event("attached"));
      if (this._root && init2 && instance._renderer) {
        const insert2 = () => init2.insert(this._root, instance._renderer);
        if (this.hasAttribute("mk-h") && !ctor._component.el.nohydrate) {
          runHydration(insert2, { target: this._root });
        } else {
          insert2();
        }
      }
      this.connectedCallback();
    }, instance._scope);
  }
  subscribe(callback) {
    if (!this._component) {
      this._throwAttachError(["el.subscribe(({ foo, bar }) => {", "  // ...", "});"]);
    }
    if (!this._component?.instance._state) {
      const ctor = this.constructor;
      const tagName = ctor._component.el.tagName;
      throw Error(`[maverick] \`${tagName}\` element does not have a store to subscribe to`);
    }
    return scoped(() => {
      return effect(() => callback(this._component.instance._state));
    }, this._component.instance._scope);
  }
  onAttach(callback) {
    if (this._component) {
      callback(this);
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => this._attachCallbacks?.delete(callback);
    }
  }
  onEventDispatch(callback) {
    const ctor = this.constructor;
    if (ctor._dispatchedEvents)
      for (const eventType of ctor._dispatchedEvents)
        callback(eventType);
    this._onEventDispatch = callback;
  }
  destroy() {
    this.disconnectedCallback();
    this._component?.destroy();
    this._component = null;
    this._destroyed = true;
  }
  dispatchEvent(event) {
    if (this._delegate) {
      const ctor = this.constructor;
      if (!ctor._dispatchedEvents)
        ctor._dispatchedEvents = /* @__PURE__ */ new Set();
      if (!ctor._dispatchedEvents.has(event.type)) {
        this._onEventDispatch?.(event.type);
        ctor._dispatchedEvents.add(event.type);
      }
    }
    return untrack(() => super.dispatchEvent(event));
  }
  async _setup() {
    if (this._pendingSetup)
      return;
    this._pendingSetup = true;
    await setup(this);
    this._pendingSetup = false;
  }
  _throwAttachError(code) {
    {
      const ctor = this.constructor;
      const tagName = ctor._component.el.tagName;
      throw Error(
        `[maverick] component instance has not attached yet, wait for event like so:

const el = document.querySelector('${tagName}');
el.addEventListener('attached', () => {
` + ("  " + code.join("\n  ")) + `
}, { once: true });
`
      );
    }
  }
};
_a = CONNECT;
function resolveShadowRootElement(root4) {
  if (root4.firstChild && isDOMElement(root4.firstChild) && root4.firstChild.localName === "shadow-root") {
    return root4.firstChild;
  } else {
    const shadowRoot = $$_create_element("shadow-root");
    root4.prepend(shadowRoot);
    return shadowRoot;
  }
}
var PROP_DEF = Symbol("PROP_DEF");
function defineProp(definition) {
  return { [PROP_DEF]: true, ...definition };
}
function defineElement(declaration) {
  if ("props" in declaration) {
    const props = declaration.props;
    for (const name of Object.keys(props)) {
      const def = props[name]?.[PROP_DEF] ? props[name] : { [PROP_DEF]: true, value: props[name] };
      if (def.attribute !== false && !def.type)
        def.type = inferAttributeType(def.value);
      props[name] = def;
    }
  }
  return declaration;
}
var STRING = {
  from: (v) => v === null ? "" : v + ""
};
var NUMBER = {
  from: (v) => v === null ? 0 : Number(v)
};
var BOOLEAN = {
  from: (v) => v !== null,
  to: (v) => v ? "" : null
};
var FUNCTION = {
  from: false,
  to: () => null
};
var ARRAY = {
  from: (v) => v === null ? [] : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
var OBJECT = {
  from: (v) => v === null ? {} : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
function inferAttributeType(value) {
  if (value === null)
    return STRING;
  switch (typeof value) {
    case "undefined":
      return STRING;
    case "string":
      return STRING;
    case "boolean":
      return BOOLEAN;
    case "number":
      return NUMBER;
    case "function":
      return FUNCTION;
    case "object":
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}
function prop(target, propertyKey, descriptor) {
  if (!target[PROPS])
    target[PROPS] = /* @__PURE__ */ new Set();
  target[PROPS].add(propertyKey);
}
function method(target, propertyKey, descriptor) {
  if (!target[METHODS])
    target[METHODS] = /* @__PURE__ */ new Set();
  target[METHODS].add(propertyKey);
}

// ../../node_modules/.pnpm/media-icons@0.7.0/node_modules/media-icons/dist/browser/index.js
var lazyPaths = {
  "add-note": () => import('./chunks/add-note-K6LY3JVJ-RO3RI5Q4.js'),
  "add-playlist": () => import('./chunks/add-playlist-V2PDG55Q-HPI4XU45.js'),
  "add-user": () => import('./chunks/add-user-UODFHPUX-KZGJCKCX.js'),
  "add": () => import('./chunks/add-MKWDO7OI-5G2DYNUJ.js'),
  "airplay": () => import('./chunks/airplay-BBSPJ74C-HALPKIYI.js'),
  "arrow-collapse-in": () => import('./chunks/arrow-collapse-in-YL2IDAI3-LQZNLRW6.js'),
  "arrow-collapse": () => import('./chunks/arrow-collapse-NIQ3FMMB-LLNWGBLO.js'),
  "arrow-down": () => import('./chunks/arrow-down-7WUOHUQ5-ISRMB3NK.js'),
  "arrow-expand-out": () => import('./chunks/arrow-expand-out-5VKWMS7M-M76W3YFL.js'),
  "arrow-expand": () => import('./chunks/arrow-expand-GB4FQX53-R7WAKNZ7.js'),
  "arrow-left": () => import('./chunks/arrow-left-VMFA4MD3-C6E56QCW.js'),
  "arrow-right": () => import('./chunks/arrow-right-JJ6UR3W5-FMBKRKRM.js'),
  "arrow-up": () => import('./chunks/arrow-up-VHPTXNME-K5TZIKDT.js'),
  "bookmark": () => import('./chunks/bookmark-2HY3747X-ZWIZHBLL.js'),
  "camera": () => import('./chunks/camera-MCHD22GI-4MBJ3EA7.js'),
  "chapters": () => import('./chunks/chapters-WZ5VBDWL-QUWTIPJ7.js'),
  "chat-collapse": () => import('./chunks/chat-collapse-HT2BVQBQ-6N3FL2IM.js'),
  "chat": () => import('./chunks/chat-7SNHMFOE-YANZWSZU.js'),
  "chevron-down": () => import('./chunks/chevron-down-GHFOTKXU-ZVB2SGGM.js'),
  "chevron-left": () => import('./chunks/chevron-left-4GJP2ZIG-BLDIDPWS.js'),
  "chevron-right": () => import('./chunks/chevron-right-RDCYIUTF-B5DVSES3.js'),
  "chevron-up": () => import('./chunks/chevron-up-WW566PEU-2Z5XOIEE.js'),
  "chromecast": () => import('./chunks/chromecast-YZXROZN5-2GON4HE2.js'),
  "clip": () => import('./chunks/clip-UTUVK5ZJ-W7RB5EEH.js'),
  "closed-captions-on": () => import('./chunks/closed-captions-on-AWV5GKOR-774RU5UI.js'),
  "closed-captions": () => import('./chunks/closed-captions-OL3H52PB-CGDFNAD7.js'),
  "comment": () => import('./chunks/comment-RHVNAV2Z-U4FGEIO6.js'),
  "computer": () => import('./chunks/computer-PDN53TBJ-MS7GQDE3.js'),
  "device": () => import('./chunks/device-2Q4T5LRZ-N5RPTZRI.js'),
  "download": () => import('./chunks/download-VRWBBFI5-4HSASCAP.js'),
  "episodes": () => import('./chunks/episodes-6LWZNPNN-FBUKLTWX.js'),
  "eye": () => import('./chunks/eye-ARGO4OXU-TYHET4FZ.js'),
  "fast-backward": () => import('./chunks/fast-backward-KOWPJ77P-O3GOEI76.js'),
  "fast-forward": () => import('./chunks/fast-forward-YHUA2RUX-7UWCPAZT.js'),
  "flag": () => import('./chunks/flag-7NS553YQ-GDTXGJLD.js'),
  "fullscreen-arrow-exit": () => import('./chunks/fullscreen-arrow-exit-UMGNEUBY-OUIRXRY6.js'),
  "fullscreen-arrow": () => import('./chunks/fullscreen-arrow-EAOJK5V6-N3PZR5NB.js'),
  "fullscreen-exit": () => import('./chunks/fullscreen-exit-5I5CX33N-42RQ3ZU2.js'),
  "fullscreen": () => import('./chunks/fullscreen-6QBZ3YMF-QKMIVAST.js'),
  "heart": () => import('./chunks/heart-QFV2QDNC-QW5KVJDJ.js'),
  "info": () => import('./chunks/info-WIOFGZIX-QXNO67VJ.js'),
  "language": () => import('./chunks/language-6XZJKRI2-6AAILVUV.js'),
  "link": () => import('./chunks/link-ML244RKU-MGSI4EM6.js'),
  "lock-closed": () => import('./chunks/lock-closed-7PVUSTAD-PBHOL22Y.js'),
  "lock-open": () => import('./chunks/lock-open-QLOH2QVT-V7AIGPIE.js'),
  "menu-horizontal": () => import('./chunks/menu-horizontal-KMADVH2U-VJ6XEJP4.js'),
  "menu-vertical": () => import('./chunks/menu-vertical-VWVRRCQ4-YKFYZ5J3.js'),
  "microphone": () => import('./chunks/microphone-UVDVU7A5-GP2I3ANH.js'),
  "mobile": () => import('./chunks/mobile-R5RKTMDN-QB2IHAQV.js'),
  "moon": () => import('./chunks/moon-LLSORKH7-BKX4HSDX.js'),
  "music-off": () => import('./chunks/music-off-DYEDFBO2-HHP2CJRZ.js'),
  "music": () => import('./chunks/music-SMN7SFSX-MSSVL2UF.js'),
  "mute": () => import('./chunks/mute-5ALLANKA-TAT3SES2.js'),
  "next": () => import('./chunks/next-ADSQ667Q-SI2J7AJJ.js'),
  "notification": () => import('./chunks/notification-5C3KPKVZ-AZJUP6FG.js'),
  "odometer": () => import('./chunks/odometer-VYJPIAWL-HDDNWR7Y.js'),
  "pause": () => import('./chunks/pause-KFO7OQUJ-FV6TWU6T.js'),
  "picture-in-picture-exit": () => import('./chunks/picture-in-picture-exit-74KJR6FY-IB5QN4QV.js'),
  "picture-in-picture": () => import('./chunks/picture-in-picture-KJZV43E4-QJLJFZJ2.js'),
  "play": () => import('./chunks/play-JBRWVFR6-TSERODR5.js'),
  "playback-speed-circle": () => import('./chunks/playback-speed-circle-ZOSXV76B-PCXAB4UV.js'),
  "playlist": () => import('./chunks/playlist-NECHL7LX-ZQJEVBQ2.js'),
  "previous": () => import('./chunks/previous-OZJVKMBD-RUD2B44Y.js'),
  "question-mark": () => import('./chunks/question-mark-TIDUQQLU-PFNTF6P2.js'),
  "queue-list": () => import('./chunks/queue-list-6AMVOMWO-G6XO7HDG.js'),
  "radio-button-selected": () => import('./chunks/radio-button-selected-DXL7XNW2-PW4IXGJI.js'),
  "radio-button": () => import('./chunks/radio-button-Q3ADRHH7-OQVTFDCJ.js'),
  "repeat-on": () => import('./chunks/repeat-on-AUI56XZD-VO4IPW2N.js'),
  "repeat-square-on": () => import('./chunks/repeat-square-on-RXTHU34M-DXACKKYL.js'),
  "repeat-square": () => import('./chunks/repeat-square-GMF4W5HF-7YBUJK2F.js'),
  "repeat": () => import('./chunks/repeat-QT2XRFPW-4EQCN6ZA.js'),
  "replay": () => import('./chunks/replay-T2RUVYAH-MXQHS5KK.js'),
  "rotate": () => import('./chunks/rotate-KX4CNFR3-B7S4HKU4.js'),
  "search": () => import('./chunks/search-2JYKNW4X-N7DCU6MF.js'),
  "seek-backward-10": () => import('./chunks/seek-backward-10-Z6KZ4QTT-DQTVQAIQ.js'),
  "seek-backward-15": () => import('./chunks/seek-backward-15-Y4M7ZUTB-JM7QBGCC.js'),
  "seek-backward-30": () => import('./chunks/seek-backward-30-KL5HTV4A-VECU56KZ.js'),
  "seek-backward": () => import('./chunks/seek-backward-725VG7KT-A7KADZKB.js'),
  "seek-forward-10": () => import('./chunks/seek-forward-10-KH6RHT7A-VT4N4NBO.js'),
  "seek-forward-15": () => import('./chunks/seek-forward-15-RHQSPHCS-TA4FXTNT.js'),
  "seek-forward-30": () => import('./chunks/seek-forward-30-BJUOSAZO-QSFH2LI6.js'),
  "seek-forward": () => import('./chunks/seek-forward-PT5LOJZQ-HSKSH7UP.js'),
  "send": () => import('./chunks/send-LM6WLRAI-FEUI5IV5.js'),
  "settings-menu": () => import('./chunks/settings-menu-TPGMH5JT-E3GDO2BH.js'),
  "settings-switch": () => import('./chunks/settings-switch-TUFPX7FQ-T47SYMEQ.js'),
  "settings": () => import('./chunks/settings-NIOTEDBE-TIZBOMYA.js'),
  "share-arrow": () => import('./chunks/share-arrow-QWD5PQVS-JPHCCL3M.js'),
  "share": () => import('./chunks/share-HMHTXN7I-USVUTZUE.js'),
  "shuffle-on": () => import('./chunks/shuffle-on-CKD7E2HN-TFS2NSQU.js'),
  "shuffle": () => import('./chunks/shuffle-BUFG4YJQ-DFYQCO35.js'),
  "stop": () => import('./chunks/stop-ZU2CJPIA-CCBFXCAZ.js'),
  "subtitles": () => import('./chunks/subtitles-DXOKQAOQ-5UZCLGPG.js'),
  "sun": () => import('./chunks/sun-3URLHARM-62OG5KV6.js'),
  "theatre-mode-exit": () => import('./chunks/theatre-mode-exit-NYUOZTLG-R7M2DF4B.js'),
  "theatre-mode": () => import('./chunks/theatre-mode-YZ37QE62-IPSKUKZA.js'),
  "thumbs-down": () => import('./chunks/thumbs-down-PB3QBVDG-CYST3J65.js'),
  "thumbs-up": () => import('./chunks/thumbs-up-KR3RGBXP-CMYTFBUT.js'),
  "timer": () => import('./chunks/timer-LEKSHLMO-7LR27PIP.js'),
  "transcript": () => import('./chunks/transcript-WBVAFRPP-PEI2ZW4B.js'),
  "tv": () => import('./chunks/tv-BBPMIKYK-YWCE3FRI.js'),
  "user": () => import('./chunks/user-XLENPSJP-ZTJXQTQT.js'),
  "volume-high": () => import('./chunks/volume-high-QFIQXACF-63VTAD6F.js'),
  "volume-low": () => import('./chunks/volume-low-7G4R22Y3-HJYO7XZV.js'),
  "x-mark": () => import('./chunks/x-mark-ORJKYZQ2-SJMIGBHA.js')
};

// src/icons/component.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" data-media-icon="true"></svg>`);
var Icon = class extends Component {
  constructor() {
    super(...arguments);
    this._hydrate = false;
    this._paths = signal("");
  }
  onAttach(el) {
    this._hydrate = el.hasAttribute("mk-h");
    effect2(this._loadIcon.bind(this));
  }
  _loadIcon() {
    const type = this.$props.type();
    if (this._hydrate) {
      this._hydrate = false;
      return;
    }
    if (type && lazyPaths[type]) {
      lazyPaths[type]().then(({ default: paths2 }) => {
        if (type === peek(this.$props.type))
          this._paths.set(paths2);
      });
    } else {
      this._paths.set("");
    }
  }
  render() {
    return (() => {
      const $$_root = $$_clone($$_templ);
      $$_effect(() => void ($$_root.innerHTML = this._paths()));
      return $$_root;
    })();
  }
};
Icon.el = defineElement({
  tagName: "media-icon",
  props: { type: void 0 }
});

// src/utils/dom.ts
function setAttributeIfEmpty(target, name, value) {
  if (!target.hasAttribute(name))
    target.setAttribute(name, value);
}
function setARIALabel(target, label) {
  if (target.hasAttribute("aria-label") || target.hasAttribute("aria-describedby"))
    return;
  function updateAriaDescription() {
    setAttribute(target, "aria-label", label());
  }
  effect2(updateAriaDescription);
}
function isElementParent(owner, node, test) {
  while (node) {
    if (node === owner) {
      return true;
    } else if (node.localName === owner.localName || test?.(node)) {
      break;
    } else {
      node = node.parentElement;
    }
  }
  return false;
}
function onPress(target, handler) {
  listenEvent(target, "pointerup", (event) => {
    if (event.button === 0)
      handler(event);
  });
  listenEvent(target, "keydown", (event) => {
    if (isKeyboardClick(event))
      handler(event);
  });
}
function scopedRaf(callback) {
  const scope = getScope();
  requestAnimationFrame(() => scoped(callback, scope));
}

// src/player/core/api/context.ts
var mediaContext = createContext();
function useMedia() {
  return useContext(mediaContext);
}

// src/player/core/providers/audio/loader.tsx
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<audio preload="none" aria-hidden="true"></audio>`);
var $$_templ_2 = $$_templ2;
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    if (!this._audio) {
      throw Error(
        "[vidstack] `<audio>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-D5V7PKKB.js')).AudioProvider(this._audio);
  }
  render($store) {
    return (() => {
      const $$_root = $$_clone($$_templ_2);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_ref($$_root, (el) => void (this._audio = el));
      return $$_root;
    })();
  }
};

// src/player/core/providers/video/loader.tsx
var $$_templ3 = /* @__PURE__ */ $$_create_template(`<video preload="none" aria-hidden="true"></video>`);
var $$_templ_22 = $$_templ3;
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-JFRVUWMW.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const $poster = computed(() => $store.poster() && $store.controls() ? $store.poster() : null);
    return (() => {
      const $$_root = $$_clone($$_templ_22);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_effect(() => $$_attr($$_root, "poster", $poster()));
      $$_ref($$_root, (el) => void (this._video = el));
      return $$_root;
    })();
  }
};

// src/player/core/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./chunks/provider-YRDPWWPB.js')).HLSProvider(this._video, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/core/outlet/source-select.ts
var warned = /* @__PURE__ */ new Set() ;
var SourceSelection = class {
  constructor(_domSources, _media, _loader) {
    this._domSources = _domSources;
    this._media = _media;
    this._loader = _loader;
    const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
    this._loaders = computed(() => {
      return _media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
    });
    effect2(this._onSourcesChange.bind(this));
    effect2(this._onSourceChange.bind(this));
    effect2(this._onPreconnect.bind(this));
    effect2(this._onLoadSource.bind(this));
  }
  _onSourcesChange() {
    this._media.delegate._dispatch("sources-change", {
      detail: [...normalizeSrc(this._media.$props.src()), ...this._domSources()]
    });
  }
  _onSourceChange() {
    const { $store } = this._media;
    const sources = $store.sources(), currentSource = peek($store.source), newSource = this._findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
    if (noMatch && !warned.has(newSource.src) && !peek(this._loader)) {
      const source = sources[0];
      console.warn(
        `[vidstack] could not find a loader for any of the given media sources, consider providing \`type\`:

<media-outlet>
  <source src="${source.src}" type="video/mp4" />
</media-outlet>"

Falling back to fetching source headers...`
      );
      warned.add(newSource.src);
    }
    if (noMatch) {
      const { crossorigin } = $store, credentials = getRequestCredentials(crossorigin()), abort = new AbortController();
      Promise.all(
        sources.map(
          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
            method: "HEAD",
            credentials,
            signal: abort.signal
          }).then((res) => {
            source.type = res.headers.get("content-type") || "??";
            return source;
          }).catch(() => source) : source
        )
      ).then((sources2) => {
        if (abort.signal.aborted)
          return;
        this._findNewSource(peek($store.source), sources2);
        tick();
      });
      return () => abort.abort();
    }
    tick();
  }
  _findNewSource(currentSource, sources) {
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek(this._loaders).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    this._notifySourceChange(currentSource, newSource, newLoader);
    this._notifyLoaderChange(peek(this._loader), newLoader);
    return newSource;
  }
  _notifySourceChange(currentSource, newSource, newLoader) {
    if (newSource.src === currentSource.src && newSource.type === currentSource.type)
      return;
    this._media.delegate._dispatch("source-change", { detail: newSource });
    this._media.delegate._dispatch("media-type-change", {
      detail: newLoader?.mediaType(newSource) || "unknown"
    });
  }
  _notifyLoaderChange(currentLoader, newLoader) {
    if (newLoader === currentLoader)
      return;
    this._media.delegate._dispatch("provider-change", { detail: null });
    newLoader && peek(() => newLoader.preconnect?.(this._media));
    this._loader.set(newLoader);
    this._media.delegate._dispatch("provider-loader-change", { detail: newLoader });
  }
  _onPreconnect() {
    const provider = this._media.$provider();
    if (!provider)
      return;
    if (this._media.$store.canLoad()) {
      peek(
        () => provider.setup({
          ...this._media,
          player: this._media.player
        })
      );
      return;
    }
    peek(() => provider.preconnect?.(this._media));
  }
  _onLoadSource() {
    const provider = this._media.$provider(), source = this._media.$store.source();
    if (this._media.$store.canLoad()) {
      peek(() => provider?.loadSource(source, peek(this._media.$store.preload)));
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
      {
        this._media.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", e).dispatch();
      }
    }
  }
};
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}

// src/player/core/outlet/tracks.ts
var Tracks = class {
  constructor(_domTracks, _media) {
    this._domTracks = _domTracks;
    this._media = _media;
    this._prevTracks = [];
    effect2(this._onTracksChange.bind(this));
  }
  _onTracksChange() {
    const newTracks = [...this._media.$props.textTracks(), ...this._domTracks()];
    for (const oldTrack of this._prevTracks) {
      if (!newTracks.some((t) => t.id === oldTrack.id)) {
        const track = oldTrack.id && this._media.textTracks.getById(oldTrack.id);
        if (track)
          this._media.textTracks.remove(track);
      }
    }
    for (const newTrack of newTracks) {
      const id2 = newTrack.id || TextTrack.createId(newTrack);
      if (!this._media.textTracks.getById(id2)) {
        newTrack.id = id2;
        this._media.textTracks.add(newTrack);
      }
    }
    this._prevTracks = newTracks;
  }
};

// src/player/core/outlet/outlet.tsx
var Outlet = class extends Component {
  constructor(instance) {
    super(instance);
    this._domSources = signal([]);
    this._domTracks = signal([]);
    this._loader = signal(null);
    this._media = useMedia();
    new SourceSelection(this._domSources, this._media, this._loader);
    new Tracks(this._domTracks, this._media);
  }
  onAttach(el) {
    el.setAttribute("keep-alive", "");
  }
  onConnect(el) {
    const resize = new ResizeObserver(animationFrameThrottle(this._onResize.bind(this)));
    resize.observe(el);
    const mutation = new MutationObserver(this._onMutation.bind(this));
    mutation.observe(el, { attributes: true, childList: true });
    if (IS_SAFARI) {
      listenEvent(el, "touchstart", (e) => e.preventDefault(), { passive: false });
    }
    scopedRaf(() => {
      this._onResize();
      this._onMutation();
    });
    return () => {
      resize.disconnect();
      mutation.disconnect();
    };
  }
  onDestroy() {
    this._media.$store.currentTime.set(0);
  }
  _onResize() {
    const player = this._media.player, width = this.el.offsetWidth, height = this.el.offsetHeight;
    if (!player)
      return;
    player.$store.mediaWidth.set(width);
    player.$store.mediaHeight.set(height);
    setStyle(player, "--media-width", width + "px");
    setStyle(player, "--media-height", height + "px");
  }
  _onMutation() {
    const sources = [], tracks = [], children = this.el.children;
    for (const el of children) {
      if (el instanceof HTMLSourceElement) {
        sources.push({
          src: el.src,
          type: el.type
        });
      } else if (el instanceof HTMLTrackElement) {
        tracks.push({
          id: el.id,
          src: el.src,
          kind: el.track.kind,
          language: el.srclang,
          label: el.label,
          default: el.default,
          type: el.getAttribute("data-type")
        });
      }
    }
    this._domSources.set(sources);
    this._domTracks.set(tracks);
    tick();
  }
  render() {
    let currentProvider;
    onDispose(() => currentProvider?.destroy?.());
    return () => {
      currentProvider?.destroy();
      const loader = this._loader();
      if (!loader)
        return null;
      const el = loader.render(this._media.$store);
      peek(() => {
        loader.load(this._media).then((provider) => {
          if (peek(this._loader) !== loader)
            return;
          this._media.delegate._dispatch("provider-change", {
            detail: provider
          });
          currentProvider = provider;
        });
      });
      return el;
    };
  }
};
Outlet.el = defineElement({
  tagName: "media-outlet"
});

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document2[vendor[key.exitFullscreen]].bind(document2);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document2.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document2.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document2[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document2[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;

// src/foundation/fullscreen/controller.ts
var CAN_FULLSCREEN = fscreen_esm_default.fullscreenEnabled;
var FullscreenController = class extends ComponentController {
  constructor() {
    super(...arguments);
    /**
     * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
     * listened to globally on the document so we need to know if they relate to the current host
     * element or not.
     */
    this._listening = false;
    this._active = false;
  }
  get active() {
    return this._active;
  }
  get supported() {
    return CAN_FULLSCREEN;
  }
  onConnect() {
    listenEvent(fscreen_esm_default, "fullscreenchange", this._onFullscreenChange.bind(this));
    listenEvent(fscreen_esm_default, "fullscreenerror", this._onFullscreenError.bind(this));
  }
  async onDisconnect() {
    if (CAN_FULLSCREEN)
      await this.exit();
  }
  _onFullscreenChange(event) {
    const active = isFullscreen(this.el);
    if (active === this._active)
      return;
    if (!active)
      this._listening = false;
    this._active = active;
    this.dispatch("fullscreen-change", { detail: active, trigger: event });
  }
  _onFullscreenError(event) {
    if (!this._listening)
      return;
    this.dispatch("fullscreen-error", { detail: null, trigger: event });
    this._listening = false;
  }
  async enter() {
    try {
      this._listening = true;
      if (!this.el || isFullscreen(this.el))
        return;
      assertFullscreenAPI();
      return fscreen_esm_default.requestFullscreen(this.el);
    } catch (error) {
      this._listening = false;
      throw error;
    }
  }
  async exit() {
    if (!this.el || !isFullscreen(this.el))
      return;
    assertFullscreenAPI();
    return fscreen_esm_default.exitFullscreen();
  }
};
function canFullscreen() {
  return CAN_FULLSCREEN;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
function assertFullscreenAPI() {
  if (CAN_FULLSCREEN)
    return;
  throw Error(
    "[vidstack] fullscreen API is not enabled or supported in this environment" 
  );
}

// src/foundation/logger/grouped-log.ts
var GROUPED_LOG = Symbol("GROUPED_LOG" );
var _a2;
var _GroupedLog = class {
  constructor(logger, level, title, root2, parent) {
    this.logger = logger;
    this.level = level;
    this.title = title;
    this.root = root2;
    this.parent = parent;
    this[_a2] = true;
    this.logs = [];
  }
  log(...data) {
    this.logs.push({ data });
    return this;
  }
  labelledLog(label, ...data) {
    this.logs.push({ label, data });
    return this;
  }
  groupStart(title) {
    return new _GroupedLog(this.logger, this.level, title, this.root ?? this, this);
  }
  groupEnd() {
    this.parent?.logs.push(this);
    return this.parent ?? this;
  }
  dispatch() {
    return this.logger.dispatch(this.level, this.root ?? this);
  }
};
var GroupedLog = _GroupedLog;
_a2 = GROUPED_LOG;
function isGroupedLog(data) {
  return isObject(data) && data[GROUPED_LOG];
}

// src/foundation/logger/controller.ts
var Logger = class {
  constructor() {
    this._target = null;
  }
  error(...data) {
    return this.dispatch("error", ...data);
  }
  warn(...data) {
    return this.dispatch("warn", ...data);
  }
  info(...data) {
    return this.dispatch("info", ...data);
  }
  debug(...data) {
    return this.dispatch("debug", ...data);
  }
  errorGroup(title) {
    return new GroupedLog(this, "error", title);
  }
  warnGroup(title) {
    return new GroupedLog(this, "warn", title);
  }
  infoGroup(title) {
    return new GroupedLog(this, "info", title);
  }
  debugGroup(title) {
    return new GroupedLog(this, "debug", title);
  }
  setTarget(newTarget) {
    this._target = newTarget;
  }
  dispatch(level, ...data) {
    return this._target?.dispatchEvent(
      new DOMEvent("vds-log", {
        bubbles: true,
        composed: true,
        detail: { level, data }
      })
    ) || false;
  }
};

// src/foundation/logger/colors.ts
var LOCAL_STORAGE_KEY = "@vidstack/log-colors";
var savedColors = init();
function getLogColor(key2) {
  return savedColors.get(key2);
}
function saveLogColor(key2, { color = generateColor(), overwrite = false } = {}) {
  if (!savedColors.has(key2) || overwrite) {
    savedColors.set(key2, color);
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));
  }
}
function generateColor() {
  return `hsl(${Math.random() * 360}, 55%, 70%)`;
}
function init() {
  let colors;
  try {
    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));
  } catch {
  }
  return new Map(Object.entries(colors ?? {}));
}

// src/foundation/logger/log-level.ts
var LogLevelValue = Object.freeze({
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
  debug: 4
});
var LogLevelColor = Object.freeze({
  silent: "white",
  error: "hsl(6, 58%, 50%)",
  warn: "hsl(51, 58%, 50%)",
  info: "hsl(219, 58%, 50%)",
  debug: "hsl(280, 58%, 50%)"
});

// src/foundation/logger/ms.ts
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
function ms2(val) {
  const msAbs = Math.abs(val);
  if (msAbs >= d) {
    return Math.round(val / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(val / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(val / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(val / s) + "s";
  }
  return round(val, 2) + "ms";
}

// src/foundation/logger/log-printer.ts
var LogPrinter = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._level = "warn" ;
  }
  /**
   * The current log level.
   */
  get logLevel() {
    return this._level ;
  }
  set logLevel(level) {
    this._level = level;
  }
  onConnect() {
    this.listen("vds-log", (event) => {
      event.stopPropagation();
      const eventTargetName = (event.path?.[0] ?? event.target).tagName.toLowerCase();
      const { level = "warn", data } = event.detail ?? {};
      if (LogLevelValue[this._level] < LogLevelValue[level]) {
        return;
      }
      saveLogColor(eventTargetName);
      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : "";
      console.groupCollapsed(
        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? "..." : ""}`,
        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,
        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,
        "color: gray; font-size: 11px; padding-left: 4px;"
      );
      if (data?.length === 1 && isGroupedLog(data[0])) {
        printGroup(level, data[0]);
      } else if (data) {
        print(level, ...data);
      }
      this._printTimeDiff();
      printStackTrace();
      console.groupEnd();
    });
    return () => {
      this._lastLogged = void 0;
    };
  }
  _printTimeDiff() {
    labelledPrint("Time since last log", this._calcLastLogTimeDiff());
  }
  _calcLastLogTimeDiff() {
    const time = performance.now();
    const diff = time - (this._lastLogged ?? (this._lastLogged = performance.now()));
    this._lastLogged = time;
    return ms2(diff);
  }
};
function print(level, ...data) {
  console[level](...data);
}
function labelledPrint(label, ...data) {
  console.log(`%c${label}:`, "color: gray", ...data);
}
function printStackTrace() {
  console.groupCollapsed("%cStack Trace", "color: gray");
  console.trace();
  console.groupEnd();
}
function printGroup(level, groupedLog) {
  console.groupCollapsed(groupedLog.title);
  for (const log of groupedLog.logs) {
    if (isGroupedLog(log)) {
      printGroup(level, log);
    } else if ("label" in log && !isUndefined(log.label)) {
      labelledPrint(log.label, ...log.data);
    } else {
      print(level, ...log.data);
    }
  }
  console.groupEnd();
}

// src/foundation/observers/focus-visible.ts
var $keyboard = signal(false);
{
  listenEvent(document, "pointerdown", () => {
    $keyboard.set(false);
  });
  listenEvent(document, "keydown", (e) => {
    if (e.metaKey || e.altKey || e.ctrlKey)
      return;
    $keyboard.set(true);
  });
}
var FocusVisibleController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._focused = signal(false);
  }
  onConnect(el) {
    effect2(() => {
      if (!$keyboard()) {
        this._focused.set(false);
        updateFocusAttr(el, false);
        this.listen("pointerenter", this._onPointerEnter.bind(this));
        this.listen("pointerleave", this._onPointerLeave.bind(this));
        return;
      }
      const active = document.activeElement === el;
      this._focused.set(active);
      updateFocusAttr(el, active);
      this.listen("focus", this._onFocus.bind(this));
      this.listen("blur", this._onBlur.bind(this));
    });
  }
  focused() {
    return this._focused();
  }
  _onFocus() {
    this._focused.set(true);
    updateFocusAttr(this.el, true);
  }
  _onBlur() {
    this._focused.set(false);
    updateFocusAttr(this.el, false);
  }
  _onPointerEnter() {
    updateHoverAttr(this.el, true);
  }
  _onPointerLeave() {
    updateHoverAttr(this.el, false);
  }
};
function updateFocusAttr(el, isFocused) {
  setAttribute(el, "data-focus", isFocused);
  setAttribute(el, "data-hocus", isFocused);
}
function updateHoverAttr(el, isHovering) {
  setAttribute(el, "data-hocus", isHovering);
  setAttribute(el, "data-hover", isHovering);
}

// src/foundation/orientation/controller.ts
var CAN_USE_SCREEN_ORIENTATION_API = canOrientScreen();
var ScreenOrientationController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._type = signal(getScreenOrientation());
    this._locked = signal(false);
  }
  /**
   * The current screen orientation type.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get type() {
    return this._type();
  }
  /**
   * Whether the screen orientation is currently locked.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get locked() {
    return this._locked();
  }
  /**
   * Whether the viewport is in a portrait orientation.
   *
   * @signal
   */
  get portrait() {
    return this._type().startsWith("portrait");
  }
  /**
   * Whether the viewport is in a landscape orientation.
   *
   * @signal
   */
  get landscape() {
    return this._type().startsWith("landscape");
  }
  /**
   * Whether the native Screen Orientation API is available.
   */
  get supported() {
    return CAN_USE_SCREEN_ORIENTATION_API;
  }
  onConnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API) {
      listenEvent(screen.orientation, "change", this._onOrientationChange.bind(this));
    } else {
      const query = window.matchMedia("(orientation: landscape)");
      query.onchange = this._onOrientationChange.bind(this);
      return () => query.onchange = null;
    }
  }
  async onDisconnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API && this._locked())
      await this.unlock();
  }
  _onOrientationChange(event) {
    this._type.set(getScreenOrientation());
    this.dispatch("orientation-change", {
      detail: {
        orientation: peek(this._type),
        lock: this._currentLock
      },
      trigger: event
    });
  }
  /**
   * Locks the orientation of the screen to the desired orientation type using the
   * Screen Orientation API.
   *
   * @param lockType - The screen lock orientation type.
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async lock(lockType) {
    if (peek(this._locked) || this._currentLock === lockType)
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    this._locked.set(true);
    this._currentLock = lockType;
  }
  /**
   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
   * API. This method will throw an error if the API is unavailable.
   *
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async unlock() {
    if (!peek(this._locked))
      return;
    assertScreenOrientationAPI();
    this._currentLock = void 0;
    await screen.orientation.unlock();
    this._locked.set(false);
  }
};
function assertScreenOrientationAPI() {
  if (CAN_USE_SCREEN_ORIENTATION_API)
    return;
  throw Error(
    "[vidstack] screen orientation API is not available" 
  );
}
function getScreenOrientation() {
  if (CAN_USE_SCREEN_ORIENTATION_API)
    return window.screen.orientation.type;
  return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
}

// src/foundation/queue/request-queue.ts
var RequestQueue = class {
  constructor() {
    this._serving = false;
    this._pending = deferredPromise();
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * The number of callbacks that are currently in queue.
   */
  get _size() {
    return this._queue.size;
  }
  /**
   * Whether items in the queue are being served immediately, otherwise they're queued to
   * be processed later.
   */
  get _isServing() {
    return this._serving;
  }
  /**
   * Waits for the queue to be flushed (ie: start serving).
   */
  async _waitForFlush() {
    if (this._serving)
      return;
    await this._pending.promise;
  }
  /**
   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
   * then the callback will be invoked immediately.
   *
   * @param key - Uniquely identifies this callback so duplicates are ignored.
   * @param callback - The function to call when this item in the queue is being served.
   */
  _enqueue(key2, callback) {
    if (this._serving) {
      callback();
      return;
    }
    this._queue.delete(key2);
    this._queue.set(key2, callback);
  }
  /**
   * Invokes the callback with the given `key` in the queue (if it exists).
   */
  _serve(key2) {
    this._queue.get(key2)?.();
    this._queue.delete(key2);
  }
  /**
   * Flush all queued items and start serving future requests immediately until `stop()` is called.
   */
  _start() {
    this._flush();
    this._serving = true;
    if (this._queue.size > 0)
      this._flush();
  }
  /**
   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
   */
  _stop() {
    this._serving = false;
  }
  /**
   * Stop serving requests, empty the request queue, and release any promises waiting for the
   * queue to flush.
   */
  _reset() {
    this._stop();
    this._queue.clear();
    this._release();
  }
  _flush() {
    for (const key2 of this._queue.keys())
      this._serve(key2);
    this._release();
  }
  _release() {
    this._pending.resolve();
    this._pending = deferredPromise();
  }
};

// src/player/core/api/media-attrs.ts
var MEDIA_ATTRIBUTES = [
  "autoplay",
  "autoplayError",
  "canFullscreen",
  "canPictureInPicture",
  "canLoad",
  "canPlay",
  "canSeek",
  "ended",
  "error",
  "fullscreen",
  "loop",
  "live",
  "liveEdge",
  "mediaType",
  "muted",
  "paused",
  "pictureInPicture",
  "playing",
  "playsinline",
  "seeking",
  "started",
  "streamType",
  "userIdle",
  "viewType",
  "waiting"
];

// src/player/core/providers/type-check.ts
function isHTMLAudioElement(element) {
  return element instanceof HTMLAudioElement;
}
function isHTMLVideoElement(element) {
  return element instanceof HTMLVideoElement;
}
function isHTMLMediaElement(element) {
  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
}

// src/player/core/keyboard/controller.ts
var MEDIA_KEY_SHORTCUTS = {
  togglePaused: "k Space",
  toggleMuted: "m",
  toggleFullscreen: "f",
  togglePictureInPicture: "i",
  toggleCaptions: "c",
  seekBackward: "ArrowLeft",
  seekForward: "ArrowRight",
  volumeUp: "ArrowUp",
  volumeDown: "ArrowDown"
};
var MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Control"]);
var BUTTON_SELECTORS = 'button, [role="button"]';
var IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"]';
var MediaKeyboardController = class extends ComponentController {
  constructor(instance, _media) {
    super(instance);
    this._media = _media;
    this._timeSlider = null;
  }
  onConnect() {
    effect2(this._onTargetChange.bind(this));
  }
  _onTargetChange() {
    const { keyDisabled, keyTarget } = this.$props;
    if (keyDisabled())
      return;
    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
    if (target === this.el) {
      this.listen("focusin", () => $active.set(true));
      this.listen("focusout", (event) => {
        if (!this.el.contains(event.target))
          $active.set(false);
      });
    } else {
      if (!peek($active))
        $active.set(document.querySelector("media-player") === this.el);
      listenEvent(document, "focusin", (event) => {
        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
        if (activePlayer !== void 0)
          $active.set(this.el === activePlayer);
      });
    }
    effect2(() => {
      if (!$active())
        return;
      listenEvent(target, "keyup", this._onKeyUp.bind(this));
      listenEvent(target, "keydown", this._onKeyDown.bind(this));
      listenEvent(target, "keydown", this._onPreventVideoKeys.bind(this), { capture: true });
    });
  }
  _onKeyUp(event) {
    const focused = document.activeElement, sliderFocused = focused?.hasAttribute("data-media-slider");
    if (!event.key || !this.$store.canSeek() || sliderFocused || focused?.matches(IGNORE_SELECTORS)) {
      return;
    }
    const method2 = this._getMatchingMethod(event);
    if (method2?.startsWith("seek")) {
      event.preventDefault();
      event.stopPropagation();
      if (this._timeSlider) {
        this._forwardTimeKeyboardEvent(event);
        this._timeSlider = null;
      } else {
        this._media.remote.seek(this._seekTotal, event);
        this._seekTotal = void 0;
      }
    }
    if (method2?.startsWith("volume")) {
      const volumeSlider = this.el.querySelector("media-volume-slider");
      volumeSlider?.dispatchEvent(new DOMEvent("keyup", { trigger: event }));
    }
  }
  _onKeyDown(event) {
    if (!event.key || MODIFIER_KEYS.has(event.key))
      return;
    const focused = document.activeElement;
    if (focused?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focused?.matches(BUTTON_SELECTORS)) {
      return;
    }
    const sliderFocused = focused?.hasAttribute("data-media-slider"), method2 = this._getMatchingMethod(event);
    if (!method2 && !event.metaKey && /[0-9]/.test(event.key) && !sliderFocused) {
      event.preventDefault();
      event.stopPropagation();
      this._media.remote.seek(this.$store.duration() / 10 * Number(event.key), event);
      return;
    }
    if (!method2 || /volume|seek/.test(method2) && sliderFocused)
      return;
    event.preventDefault();
    event.stopPropagation();
    switch (method2) {
      case "seekForward":
      case "seekBackward":
        this._seeking(event, method2);
        break;
      case "volumeUp":
      case "volumeDown":
        const volumeSlider = this.el.querySelector("media-volume-slider");
        if (volumeSlider) {
          volumeSlider.dispatchEvent(new DOMEvent("keydown", { trigger: event }));
        } else {
          const value = event.shiftKey ? 0.1 : 0.05;
          this._media.remote.changeVolume(
            this.$store.volume() + (method2 === "volumeUp" ? +value : -value),
            event
          );
        }
        break;
      case "toggleFullscreen":
        this._media.remote.toggleFullscreen("prefer-media", event);
        break;
      default:
        this._media.remote[method2]?.(event);
    }
  }
  _onPreventVideoKeys(event) {
    if (isHTMLMediaElement(event.target) && this._getMatchingMethod(event)) {
      event.preventDefault();
    }
  }
  _getMatchingMethod(event) {
    const keyShortcuts = {
      ...this.$props.keyShortcuts(),
      ...this._media.ariaKeys
    };
    return Object.keys(keyShortcuts).find(
      (method2) => keyShortcuts[method2].split(" ").some(
        (keys) => replaceSymbolKeys(keys).replace(/Control/g, "Ctrl").split("+").every(
          (key2) => MODIFIER_KEYS.has(key2) ? event[key2.toLowerCase() + "Key"] : event.key === key2.replace("Space", " ")
        )
      )
    );
  }
  _calcSeekAmount(event, type) {
    const seekBy = event.shiftKey ? 10 : 5;
    return this._seekTotal = Math.max(
      0,
      Math.min(
        (this._seekTotal ?? this.$store.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
        this.$store.duration()
      )
    );
  }
  _forwardTimeKeyboardEvent(event) {
    this._timeSlider?.dispatchEvent(new DOMEvent(event.type, { trigger: event }));
  }
  _seeking(event, type) {
    if (!this.$store.canSeek())
      return;
    if (!this._timeSlider)
      this._timeSlider = this.el.querySelector("media-time-slider");
    if (this._timeSlider) {
      this._forwardTimeKeyboardEvent(event);
    } else {
      this._media.remote.seeking(this._calcSeekAmount(event, type), event);
    }
  }
};
var SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
function replaceSymbolKeys(key2) {
  return key2.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
}

// src/player/core/api/player-props.ts
var mediaPlayerProps = {
  autoplay: false,
  aspectRatio: defineProp({
    value: null,
    type: {
      from(value) {
        if (!value)
          return null;
        if (!value.includes("/"))
          return +value;
        const [width, height] = value.split("/").map(Number);
        return +(width / height).toFixed(4);
      }
    }
  }),
  controls: false,
  currentTime: 0,
  crossorigin: null,
  fullscreenOrientation: "landscape",
  load: "visible",
  logLevel: "silent",
  loop: false,
  muted: false,
  paused: true,
  playsinline: false,
  playbackRate: 1,
  poster: "",
  preload: "metadata",
  preferNativeHLS: defineProp({
    value: false,
    attribute: "prefer-native-hls"
  }),
  src: "",
  userIdleDelay: 2e3,
  viewType: "unknown",
  streamType: "unknown",
  volume: 1,
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  keyDisabled: false,
  keyTarget: "player",
  keyShortcuts: MEDIA_KEY_SHORTCUTS,
  title: "",
  thumbnails: null,
  textTracks: defineProp({
    value: [],
    attribute: false
  }),
  smallBreakpointX: 600,
  largeBreakpointX: 980,
  smallBreakpointY: 380,
  largeBreakpointY: 600
};

// src/player/core/time-ranges.ts
var TimeRange = class {
  get length() {
    return this._ranges.length;
  }
  constructor(start, end) {
    if (isArray(start)) {
      this._ranges = start;
    } else if (!isUndefined(start) && !isUndefined(end)) {
      this._ranges = [[start, end]];
    } else {
      this._ranges = [];
    }
  }
  start(index) {
    throwIfEmpty(this._ranges.length);
    throwIfOutOfRange("start", index, this._ranges.length - 1);
    return this._ranges[index][0] ?? Infinity;
  }
  end(index) {
    throwIfEmpty(this._ranges.length);
    throwIfOutOfRange("end", index, this._ranges.length - 1);
    return this._ranges[index][1] ?? Infinity;
  }
};
function getTimeRangesStart(range) {
  if (!range.length)
    return null;
  let min = range.start(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(range) {
  if (!range.length)
    return null;
  let max = range.end(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
function throwIfEmpty(length) {
  if (!length)
    throw new Error("`TimeRanges` object is empty." );
}
function throwIfOutOfRange(fnName, index, end) {
  if (!isNumber(index) || index < 0 || index > end) {
    throw new Error(
      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`
    );
  }
}

// src/player/core/api/store.ts
var MediaStoreFactory = new StoreFactory({
  audioTracks: [],
  audioTrack: null,
  autoplay: false,
  autoplayError: void 0,
  buffered: new TimeRange(),
  duration: 0,
  canLoad: false,
  canFullscreen: false,
  canPictureInPicture: false,
  canPlay: false,
  controls: false,
  crossorigin: null,
  poster: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  loop: false,
  logLevel: "warn" ,
  mediaType: "unknown",
  muted: false,
  paused: true,
  played: new TimeRange(),
  playing: false,
  playsinline: false,
  pictureInPicture: false,
  preload: "metadata",
  playbackRate: 1,
  qualities: [],
  quality: null,
  autoQuality: false,
  canSetQuality: true,
  seekable: new TimeRange(),
  seeking: false,
  source: { src: "", type: "" },
  sources: [],
  started: false,
  title: "",
  textTracks: [],
  textTrack: null,
  thumbnails: null,
  thumbnailCues: [],
  volume: 1,
  waiting: false,
  get viewType() {
    return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
  },
  get streamType() {
    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
  },
  get currentSrc() {
    return this.source;
  },
  get bufferedStart() {
    return getTimeRangesStart(this.buffered) ?? 0;
  },
  get bufferedEnd() {
    return getTimeRangesEnd(this.buffered) ?? 0;
  },
  get seekableStart() {
    return getTimeRangesStart(this.seekable) ?? 0;
  },
  get seekableEnd() {
    return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
  },
  get seekableWindow() {
    return Math.max(0, this.seekableEnd - this.seekableStart);
  },
  // ~~ responsive design ~~
  touchPointer: false,
  orientation: "landscape",
  mediaWidth: 0,
  mediaHeight: 0,
  breakpointX: "sm",
  breakpointY: "sm",
  // ~~ user props ~~
  userIdle: false,
  userBehindLiveEdge: false,
  // ~~ live props ~~
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  get canSeek() {
    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
  },
  get live() {
    return this.streamType.includes("live") || !Number.isFinite(this.duration);
  },
  get liveEdgeStart() {
    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
  },
  get liveEdge() {
    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
  },
  get liveEdgeWindow() {
    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
  },
  // ~~ internal props ~~
  autoplaying: false,
  providedViewType: "unknown",
  providedStreamType: "unknown",
  inferredStreamType: "unknown",
  liveSyncPosition: null
});
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "breakpointX",
  "breakpointY",
  "canFullscreen",
  "canLoad",
  "canPictureInPicture",
  "controls",
  "fullscreen",
  "logLevel",
  "loop",
  "mediaHeight",
  "mediaWidth",
  "muted",
  "orientation",
  "pictureInPicture",
  "playsinline",
  "poster",
  "preload",
  "providedStreamType",
  "providedViewType",
  "source",
  "sources",
  "textTrack",
  "textTracks",
  "thumbnailCues",
  "thumbnails",
  "title",
  "touchPointer",
  "volume"
]);
function softResetMediaStore($media) {
  MediaStoreFactory.reset($media, (prop2) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop2));
  tick();
}

// src/foundation/list/list.ts
var _a3;
var List = class extends EventsTarget {
  constructor() {
    super(...arguments);
    this._items = [];
    /* @internal */
    this[_a3] = false;
  }
  get length() {
    return this._items.length;
  }
  get readonly() {
    return this[LIST_READONLY];
  }
  /**
   * Transform list to an array.
   */
  toArray() {
    return [...this._items];
  }
  [(_a3 = LIST_READONLY, Symbol.iterator)]() {
    return this._items.values();
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    const index = this._items.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this._items[index];
        }
      });
    }
    if (this._items.includes(item))
      return;
    this._items.push(item);
    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
  }
  /* @internal */
  [LIST_REMOVE](item, trigger) {
    const index = this._items.indexOf(item);
    if (index >= 0) {
      this[LIST_ON_REMOVE]?.(item, trigger);
      this._items.splice(index, 1);
      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
    }
  }
  /* @internal */
  [LIST_RESET](trigger) {
    for (const item of [...this._items])
      this[LIST_REMOVE](item, trigger);
    this._items = [];
    this[LIST_SET_READONLY](false, trigger);
    this[LIST_ON_RESET]?.();
  }
  /* @internal */
  [LIST_SET_READONLY](readonly, trigger) {
    if (this[LIST_READONLY] === readonly)
      return;
    this[LIST_READONLY] = readonly;
    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
  }
};

// src/foundation/list/select-list.ts
var SELECTED = Symbol("SELECTED" );
var SelectList = class extends List {
  get selected() {
    return this._items.find((item) => item.selected) ?? null;
  }
  get selectedIndex() {
    return this._items.findIndex((item) => item.selected);
  }
  /* @internal */
  [LIST_ON_REMOVE](item, trigger) {
    this[LIST_SELECT](item, false, trigger);
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    item[SELECTED] = false;
    Object.defineProperty(item, "selected", {
      get() {
        return this[SELECTED];
      },
      set: (selected) => {
        if (this.readonly)
          return;
        this[LIST_ON_USER_SELECT]?.();
        this[LIST_SELECT](item, selected);
      }
    });
    super[LIST_ADD](item, trigger);
  }
  /* @internal */
  [LIST_SELECT](item, selected, trigger) {
    if (selected === item[SELECTED])
      return;
    const prev = this.selected;
    item[SELECTED] = selected;
    const changed = !selected ? prev === item : prev !== item;
    if (changed) {
      if (prev)
        prev[SELECTED] = false;
      this.dispatchEvent(
        new DOMEvent("change", {
          detail: { prev, current: this.selected },
          trigger
        })
      );
    }
  }
};

// src/player/core/quality/video-quality.ts
var VideoQualityList = class extends SelectList {
  constructor() {
    super(...arguments);
    this._auto = false;
    /**
     * Configures quality switching:
     *
     * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
     * request if any, flush the whole buffer, and fetch fragment matching with current position
     * and requested quality level.
     *
     * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
     * already buffered next fragment.
     *
     * - `load`: Set quality level for next loaded fragment.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/quality#switch}
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
     */
    this.switch = "current";
  }
  /**
   * Whether automatic quality selection is enabled.
   */
  get auto() {
    return this._auto || this.readonly;
  }
  /* @internal */
  [(LIST_ON_USER_SELECT)]() {
    this[SET_AUTO_QUALITY](false);
  }
  /* @internal */
  [LIST_ON_RESET](trigger) {
    this[SET_AUTO_QUALITY](false, trigger);
  }
  /**
   * Request automatic quality selection (if supported). This will be a no-op if the list is
   * `readonly` as that already implies auto-selection.
   */
  autoSelect(trigger) {
    if (this.readonly || this._auto || !this[ENABLE_AUTO_QUALITY])
      return;
    this[ENABLE_AUTO_QUALITY]();
    this[SET_AUTO_QUALITY](true, trigger);
  }
  /* @internal */
  [SET_AUTO_QUALITY](auto, trigger) {
    if (this._auto === auto)
      return;
    this._auto = auto;
    this.dispatchEvent(
      new DOMEvent("auto-change", {
        detail: auto,
        trigger
      })
    );
  }
};

// src/player/core/state/media-events-logger.ts
var MEDIA_EVENTS = [
  "abort",
  "can-play",
  "can-play-through",
  "duration-change",
  "emptied",
  "ended",
  "error",
  "fullscreen-change",
  "loaded-data",
  "loaded-metadata",
  "load-start",
  "media-type-change",
  "pause",
  "play",
  "playing",
  "progress",
  "seeked",
  "seeking",
  "source-change",
  "sources-change",
  "stalled",
  "started",
  "suspend",
  "stream-type-change",
  "replay",
  // 'time-update',
  "view-type-change",
  "volume-change",
  "waiting"
] ;
var MediaEventsLogger = class extends ComponentController {
  constructor(instance, _media) {
    super(instance);
    this._media = _media;
  }
  onConnect() {
    const handler = this._onMediaEvent.bind(this);
    for (const eventType of MEDIA_EVENTS)
      this.listen(eventType, handler);
  }
  _onMediaEvent(event) {
    this._media.logger?.infoGroup(`\u{1F4E1} dispatching \`${event.type}\``).labelledLog("Media Store", { ...this.$store }).labelledLog("Event", event).dispatch();
  }
};

// src/player/core/state/media-load-controller.ts
var MediaLoadController = class extends ComponentController {
  constructor(instance, _callback) {
    super(instance);
    this._callback = _callback;
  }
  async onAttach(el) {
    const load = this.$props.load();
    if (load === "eager") {
      requestAnimationFrame(this._callback);
    } else if (load === "idle") {
      const { waitIdlePeriod } = await import('./chunks/std-SO3XIO43.js');
      waitIdlePeriod(this._callback);
    } else if (load === "visible") {
      const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          observer.disconnect();
          this._callback();
        }
      });
      observer.observe(el);
      return observer.disconnect.bind(observer);
    }
  }
};

// src/player/core/state/media-player-delegate.ts
var MediaPlayerDelegate = class {
  constructor(_handle, _media) {
    this._handle = _handle;
    this._media = _media;
  }
  _dispatch(type, ...init2) {
    this._handle(new DOMEvent(type, init2?.[0]));
  }
  async _ready(info, trigger) {
    const { $store, logger } = this._media;
    if (peek($store.canPlay))
      return;
    this._dispatch("can-play", { detail: info, trigger });
    tick();
    {
      logger?.infoGroup("-~-~-~-~-~-~-~-~- \u2705 MEDIA READY -~-~-~-~-~-~-~-~-").labelledLog("Media Store", { ...$store }).labelledLog("Trigger Event", trigger).dispatch();
    }
    if ($store.canPlay() && $store.autoplay() && !$store.started()) {
      await this._attemptAutoplay();
    }
  }
  async _attemptAutoplay() {
    const { player, $store } = this._media;
    $store.autoplaying.set(true);
    try {
      await player.play();
      this._dispatch("autoplay", { detail: { muted: $store.muted() } });
    } catch (error) {
      this._dispatch("autoplay-fail", {
        detail: {
          muted: $store.muted(),
          error
        }
      });
    } finally {
      $store.autoplaying.set(false);
    }
  }
};

// src/foundation/queue/queue.ts
var Queue = class {
  constructor() {
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * Queue the given `item` under the given `key` to be processed at a later time by calling
   * `serve(key)`.
   */
  _enqueue(key2, item) {
    if (!this._queue.has(key2))
      this._queue.set(key2, /* @__PURE__ */ new Set());
    this._queue.get(key2).add(item);
  }
  /**
   * Process all items in queue for the given `key`.
   */
  _serve(key2, callback) {
    const items = this._queue.get(key2);
    if (items)
      for (const item of items)
        callback(item);
    this._queue.delete(key2);
  }
  /**
   * Removes all queued items under the given `key`.
   */
  _delete(key2) {
    this._queue.delete(key2);
  }
  /**
   * The number of items currently queued under the given `key`.
   */
  _size(key2) {
    return this._queue.get(key2)?.size ?? 0;
  }
  /**
   * Clear all items in the queue.
   */
  _reset() {
    this._queue.clear();
  }
};

// src/player/core/user.ts
var MediaUserController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._idleTimer = -2;
    this._delay = 2e3;
    this._pausedTracking = false;
    this._focusedItem = null;
  }
  /**
   * Whether the media user is currently idle.
   */
  get idling() {
    return this.$store.userIdle();
  }
  /**
   * The amount of delay in milliseconds while media playback is progressing without user
   * activity to indicate an idle state.
   *
   * @defaultValue 2000
   */
  get idleDelay() {
    return this._delay;
  }
  set idleDelay(newDelay) {
    this._delay = newDelay;
  }
  /**
   * Change the user idle state.
   */
  idle(idle, delay = this._delay, trigger) {
    this._clearIdleTimer();
    if (!this._pausedTracking)
      this._requestIdleChange(idle, delay, trigger);
  }
  /**
   * Whether all idle tracking should be paused until resumed again.
   */
  pauseIdleTracking(paused, trigger) {
    this._pausedTracking = paused;
    if (paused) {
      this._clearIdleTimer();
      this._requestIdleChange(false, 0, trigger);
    }
  }
  onConnect() {
    effect2(this._watchPaused.bind(this));
    listenEvent(this.el, "play", this._onMediaPlay.bind(this));
    listenEvent(this.el, "pause", this._onMediaPause.bind(this));
  }
  _watchPaused() {
    if (this.$store.paused())
      return;
    const onStopIdle = this._onStopIdle.bind(this);
    for (const eventType of ["pointerup", "keydown"]) {
      listenEvent(this.el, eventType, onStopIdle);
    }
    effect2(() => {
      if (!this.$store.touchPointer())
        listenEvent(this.el, "pointermove", onStopIdle);
    });
  }
  _onMediaPlay(event) {
    this.idle(true, this._delay, event);
  }
  _onMediaPause(event) {
    this.idle(false, 0, event);
  }
  _clearIdleTimer() {
    window.clearTimeout(this._idleTimer);
    this._idleTimer = -1;
  }
  _onStopIdle(event) {
    if (event.MEDIA_GESTURE)
      return;
    if (isKeyboardEvent(event)) {
      if (event.key === "Escape") {
        this.el?.focus();
        this._focusedItem = null;
      } else if (this._focusedItem) {
        event.preventDefault();
        requestAnimationFrame(() => {
          this._focusedItem?.focus();
          this._focusedItem = null;
        });
      }
    }
    this.idle(false, 0, event);
    this.idle(true, this._delay, event);
  }
  _requestIdleChange(idle, delay, trigger) {
    if (delay === 0) {
      this._onIdleChange(idle, trigger);
      return;
    }
    this._idleTimer = window.setTimeout(() => {
      this._onIdleChange(idle && !this._pausedTracking, trigger);
    }, delay);
  }
  _onIdleChange(idle, trigger) {
    if (this.$store.userIdle() === idle)
      return;
    this.$store.userIdle.set(idle);
    if (idle && document.activeElement && this.el?.contains(document.activeElement)) {
      this._focusedItem = document.activeElement;
      requestAnimationFrame(() => this.el?.focus());
    }
    this.dispatch("user-idle-change", {
      detail: idle,
      trigger
    });
  }
};

// src/player/core/state/media-request-manager.ts
var MediaRequestContext = class {
  constructor() {
    this._seeking = false;
    this._looping = false;
    this._replaying = false;
    this._queue = new Queue();
  }
};
var MediaRequestManager = class extends ComponentController {
  constructor(instance, _stateMgr, _request, _media) {
    super(instance);
    this._stateMgr = _stateMgr;
    this._request = _request;
    this._media = _media;
    this._wasPIPActive = false;
    this._store = _media.$store;
    this._provider = _media.$provider;
    this._user = new MediaUserController(instance);
    this._fullscreen = new FullscreenController(instance);
    this._orientation = new ScreenOrientationController(instance);
  }
  onConnect() {
    effect2(this._onIdleDelayChange.bind(this));
    effect2(this._onFullscreenSupportChange.bind(this));
    effect2(this._onPiPSupportChange.bind(this));
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), handle = this._handleRequest.bind(this);
    for (const name of names) {
      if (name.startsWith("media-")) {
        this.listen(name, handle);
      }
    }
    this.listen("fullscreen-change", this._onFullscreenChange.bind(this));
  }
  _handleRequest(event) {
    event.stopPropagation();
    {
      this._media.logger?.infoGroup(`\u{1F4EC} received \`${event.type}\``).labelledLog("Request", event).dispatch();
    }
    if (peek(this._provider))
      this[event.type]?.(event);
  }
  async _play() {
    const { canPlay, paused, ended, autoplaying, seekableStart } = this._store;
    if (!peek(paused))
      return;
    try {
      const provider = peek(this._provider);
      throwIfNotReadyForPlayback(provider, peek(canPlay));
      if (peek(ended)) {
        provider.currentTime = seekableStart() + 0.1;
      }
      return provider.play();
    } catch (error) {
      const errorEvent = this.createEvent("play-fail", { detail: coerceToError(error) });
      errorEvent.autoplay = autoplaying();
      this._stateMgr._handle(errorEvent);
      throw error;
    }
  }
  async _pause() {
    const { canPlay, paused } = this._store;
    if (peek(paused))
      return;
    const provider = peek(this._provider);
    throwIfNotReadyForPlayback(provider, peek(canPlay));
    return provider.pause();
  }
  _seekToLiveEdge() {
    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this._store;
    userBehindLiveEdge.set(false);
    if (peek(() => !live() || liveEdge() || !canSeek()))
      return;
    const provider = peek(this._provider);
    throwIfNotReadyForPlayback(provider, peek(canPlay));
    provider.currentTime = liveSyncPosition() ?? seekableEnd() - 2;
  }
  async _enterFullscreen(target = "prefer-media") {
    const provider = peek(this._provider);
    const adapter = target === "prefer-media" && this._fullscreen.supported || target === "media" ? this._fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (adapter.active)
      return;
    if (peek(this._store.pictureInPicture)) {
      this._wasPIPActive = true;
      await this._exitPictureInPicture();
    }
    return adapter.enter();
  }
  async _exitFullscreen(target = "prefer-media") {
    const provider = peek(this._provider);
    const adapter = target === "prefer-media" && this._fullscreen.supported || target === "media" ? this._fullscreen : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (!adapter.active)
      return;
    if (this._orientation.locked)
      await this._orientation.unlock();
    try {
      const result = await adapter.exit();
      if (this._wasPIPActive && peek(this._store.canPictureInPicture)) {
        await this._enterPictureInPicture();
      }
      return result;
    } finally {
      this._wasPIPActive = false;
    }
  }
  async _enterPictureInPicture() {
    this._throwIfPIPNotSupported();
    if (this._store.pictureInPicture())
      return;
    return await this._provider().pictureInPicture.enter();
  }
  async _exitPictureInPicture() {
    this._throwIfPIPNotSupported();
    if (!this._store.pictureInPicture())
      return;
    return await this._provider().pictureInPicture.exit();
  }
  _throwIfPIPNotSupported() {
    if (this._store.canPictureInPicture())
      return;
    throw Error(
      `[vidstack] picture-in-picture is not currently available` 
    );
  }
  _onIdleDelayChange() {
    this._user.idleDelay = this.$props.userIdleDelay();
  }
  _onFullscreenSupportChange() {
    const { canLoad, canFullscreen: canFullscreen2 } = this._store, supported = this._fullscreen.supported || this._provider()?.fullscreen?.supported || false;
    if (canLoad() && peek(canFullscreen2) === supported)
      return;
    canFullscreen2.set(supported);
  }
  _onPiPSupportChange() {
    const { canLoad, canPictureInPicture } = this._store, supported = this._provider()?.pictureInPicture?.supported || false;
    if (canLoad() && peek(canPictureInPicture) === supported)
      return;
    canPictureInPicture.set(supported);
  }
  ["media-audio-track-change-request"](event) {
    if (this._media.audioTracks.readonly) {
      {
        this._media.logger?.warnGroup(`[vidstack] attempted to change audio track but it is currently read-only`).labelledLog("Event", event).dispatch();
      }
      return;
    }
    const index = event.detail, track = this._media.audioTracks[index];
    if (track) {
      this._request._queue._enqueue("audioTrack", event);
      track.selected = true;
    } else {
      this._media.logger?.warnGroup("[vidstack] failed audio track change request (invalid index)").labelledLog("Audio Tracks", this._media.audioTracks.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
    }
  }
  async ["media-enter-fullscreen-request"](event) {
    try {
      this._request._queue._enqueue("fullscreen", event);
      await this._enterFullscreen(event.detail);
    } catch (error) {
      this._onFullscreenError(error);
    }
  }
  async ["media-exit-fullscreen-request"](event) {
    try {
      this._request._queue._enqueue("fullscreen", event);
      await this._exitFullscreen(event.detail);
    } catch (error) {
      this._onFullscreenError(error);
    }
  }
  async _onFullscreenChange(event) {
    if (!event.detail)
      return;
    try {
      const lockType = peek(this.$props.fullscreenOrientation);
      if (this._orientation.supported && !isUndefined(lockType)) {
        await this._orientation.lock(lockType);
      }
    } catch (e) {
    }
  }
  _onFullscreenError(error) {
    this._stateMgr._handle(
      this.createEvent("fullscreen-error", {
        detail: coerceToError(error)
      })
    );
  }
  async ["media-enter-pip-request"](event) {
    try {
      this._request._queue._enqueue("pip", event);
      await this._enterPictureInPicture();
    } catch (error) {
      this._onPictureInPictureError(error);
    }
  }
  async ["media-exit-pip-request"](event) {
    try {
      this._request._queue._enqueue("pip", event);
      await this._exitPictureInPicture();
    } catch (error) {
      this._onPictureInPictureError(error);
    }
  }
  _onPictureInPictureError(error) {
    this._stateMgr._handle(
      this.createEvent("picture-in-picture-error", {
        detail: coerceToError(error)
      })
    );
  }
  ["media-live-edge-request"](event) {
    const { live, liveEdge, canSeek } = this._store;
    if (!live() || liveEdge() || !canSeek())
      return;
    this._request._queue._enqueue("seeked", event);
    try {
      this._seekToLiveEdge();
    } catch (e) {
      this._media.logger?.error("seek to live edge fail", e);
    }
  }
  ["media-loop-request"]() {
    window.requestAnimationFrame(async () => {
      try {
        this._request._looping = true;
        this._request._replaying = true;
        await this._play();
      } catch (e) {
        this._request._looping = false;
        this._request._replaying = false;
      }
    });
  }
  async ["media-pause-request"](event) {
    if (this._store.paused())
      return;
    try {
      this._request._queue._enqueue("pause", event);
      await this._provider().pause();
    } catch (e) {
      this._request._queue._delete("pause");
      this._media.logger?.error("pause-fail", e);
    }
  }
  async ["media-play-request"](event) {
    if (!this._store.paused())
      return;
    try {
      this._request._queue._enqueue("play", event);
      await this._provider().play();
    } catch (e) {
      const errorEvent = this.createEvent("play-fail", { detail: coerceToError(e) });
      this._stateMgr._handle(errorEvent);
    }
  }
  ["media-rate-change-request"](event) {
    if (this._store.playbackRate() === event.detail)
      return;
    this._request._queue._enqueue("rate", event);
    this._provider().playbackRate = event.detail;
  }
  ["media-quality-change-request"](event) {
    if (this._media.qualities.readonly) {
      {
        this._media.logger?.warnGroup(`[vidstack] attempted to change video quality but it is currently read-only`).labelledLog("Event", event).dispatch();
      }
      return;
    }
    this._request._queue._enqueue("quality", event);
    const index = event.detail;
    if (index < 0) {
      this._media.qualities.autoSelect(event);
    } else {
      const quality = this._media.qualities[index];
      if (quality) {
        quality.selected = true;
      } else {
        this._media.logger?.warnGroup("[vidstack] failed quality change request (invalid index)").labelledLog("Qualities", this._media.qualities.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
      }
    }
  }
  ["media-resume-user-idle-request"](event) {
    this._request._queue._enqueue("userIdle", event);
    this._user.pauseIdleTracking(false, event);
  }
  ["media-pause-user-idle-request"](event) {
    this._request._queue._enqueue("userIdle", event);
    this._user.pauseIdleTracking(true, event);
  }
  ["media-seek-request"](event) {
    const { seekableStart, seekableEnd, ended, canSeek, live, userBehindLiveEdge } = this._store;
    if (ended())
      this._request._replaying = true;
    this._request._seeking = false;
    this._request._queue._delete("seeking");
    const boundTime = Math.min(Math.max(seekableStart() + 0.1, event.detail), seekableEnd() - 0.1);
    if (!Number.isFinite(boundTime) || !canSeek())
      return;
    this._request._queue._enqueue("seeked", event);
    this._provider().currentTime = boundTime;
    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundTime) >= 2) {
      userBehindLiveEdge.set(true);
    }
  }
  ["media-seeking-request"](event) {
    this._request._queue._enqueue("seeking", event);
    this._store.seeking.set(true);
    this._request._seeking = true;
  }
  ["media-start-loading"](event) {
    if (this._store.canLoad())
      return;
    this._request._queue._enqueue("load", event);
    this._stateMgr._handle(this.createEvent("can-load"));
  }
  ["media-text-track-change-request"](event) {
    const { index, mode } = event.detail, track = this._media.textTracks[index];
    if (track) {
      this._request._queue._enqueue("textTrack", event);
      track.setMode(mode, event);
    } else {
      this._media.logger?.warnGroup("[vidstack] failed text track change request (invalid index)").labelledLog("Text Tracks", this._media.textTracks.toArray()).labelledLog("Index", index).labelledLog("Event", event).dispatch();
    }
  }
  ["media-mute-request"](event) {
    if (this._store.muted())
      return;
    this._request._queue._enqueue("volume", event);
    this._provider().muted = true;
  }
  ["media-unmute-request"](event) {
    const { muted, volume } = this._store;
    if (!muted())
      return;
    this._request._queue._enqueue("volume", event);
    this._media.$provider().muted = false;
    if (volume() === 0) {
      this._request._queue._enqueue("volume", event);
      this._provider().volume = 0.25;
    }
  }
  ["media-volume-change-request"](event) {
    const { muted, volume } = this._store;
    const newVolume = event.detail;
    if (volume() === newVolume)
      return;
    this._request._queue._enqueue("volume", event);
    this._provider().volume = newVolume;
    if (newVolume > 0 && muted()) {
      this._request._queue._enqueue("volume", event);
      this._provider().muted = false;
    }
  }
};
function throwIfNotReadyForPlayback(provider, canPlay) {
  if (provider && canPlay)
    return;
  throw Error(
    `[vidstack] media is not ready - wait for \`can-play\` event.` 
  );
}
function throwIfFullscreenNotSupported(target, fullscreen) {
  if (fullscreen?.supported)
    return;
  throw Error(
    `[vidstack] fullscreen is not currently available on target \`${target}\`` 
  );
}

// ../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// ../../node_modules/.pnpm/just-throttle@4.2.0/node_modules/just-throttle/index.mjs
var functionThrottle = throttle;
function throttle(fn, interval, options) {
  var timeoutId = null;
  var throttledFn = null;
  var leading = options && options.leading;
  var trailing = options && options.trailing;
  if (leading == null) {
    leading = true;
  }
  if (trailing == null) {
    trailing = !leading;
  }
  if (leading == true) {
    trailing = false;
  }
  var cancel = function() {
    if (timeoutId) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  var flush = function() {
    var call = throttledFn;
    cancel();
    if (call) {
      call();
    }
  };
  var throttleWrapper = function() {
    var callNow = leading && !timeoutId;
    var context = this;
    var args = arguments;
    throttledFn = function() {
      return fn.apply(context, args);
    };
    if (!timeoutId) {
      timeoutId = setTimeout(function() {
        timeoutId = null;
        if (trailing) {
          return throttledFn();
        }
      }, interval);
    }
    if (callNow) {
      callNow = false;
      return throttledFn();
    }
  };
  throttleWrapper.cancel = cancel;
  throttleWrapper.flush = flush;
  return throttleWrapper;
}

// src/player/core/state/tracked-media-events.ts
var TRACKED_EVENT = /* @__PURE__ */ new Set([
  "autoplay",
  "autoplay-fail",
  "can-load",
  "sources-change",
  "source-change",
  "load-start",
  "abort",
  "error",
  "loaded-metadata",
  "loaded-data",
  "can-play",
  "play",
  "play-fail",
  "pause",
  "playing",
  "seeking",
  "seeked",
  "waiting"
]);

// src/player/core/state/media-state-manager.ts
var MediaStateManager = class extends ComponentController {
  constructor(instance, _request, _media) {
    super(instance);
    this._request = _request;
    this._media = _media;
    this._trackedEvents = /* @__PURE__ */ new Map();
    this._skipInitialSrcChange = true;
    this._firingWaiting = false;
    this["seeking"] = functionThrottle(
      (event) => {
        const { seeking, currentTime, paused } = this._store;
        seeking.set(true);
        currentTime.set(event.detail);
        this._satisfyRequest("seeking", event);
        if (paused()) {
          this._waitingTrigger = event;
          this._fireWaiting();
        }
      },
      150,
      { leading: true }
    );
    this._fireWaiting = functionDebounce(() => {
      if (!this._waitingTrigger)
        return;
      this._firingWaiting = true;
      const { waiting, playing } = this._store;
      waiting.set(true);
      playing.set(false);
      const event = this.createEvent("waiting", { trigger: this._waitingTrigger });
      this._trackedEvents.set("waiting", event);
      this.el.dispatchEvent(event);
      this._waitingTrigger = void 0;
      this._firingWaiting = false;
    }, 300);
    this._store = _media.$store;
  }
  onAttach(el) {
    el.setAttribute("aria-busy", "true");
  }
  onConnect(el) {
    this._addTextTrackListeners();
    this._addQualityListeners();
    this._addAudioTrackListeners();
    this.listen("fullscreen-change", this["fullscreen-change"].bind(this));
    this.listen("fullscreen-error", this["fullscreen-error"].bind(this));
  }
  _handle(event) {
    const type = event.type;
    this[event.type]?.(event);
    {
      if (TRACKED_EVENT.has(type))
        this._trackedEvents.set(type, event);
      this.el?.dispatchEvent(event);
    }
  }
  _resetTracking() {
    this._stopWaiting();
    this._request._replaying = false;
    this._request._looping = false;
    this._firingWaiting = false;
    this._waitingTrigger = void 0;
    this._trackedEvents.clear();
  }
  _satisfyRequest(request, event) {
    this._request._queue._serve(request, (requestEvent) => {
      event.request = requestEvent;
      appendTriggerEvent(event, requestEvent);
    });
  }
  _addTextTrackListeners() {
    this._onTextTracksChange();
    this._onTextTrackModeChange();
    const textTracks = this._media.textTracks;
    listenEvent(textTracks, "add", this._onTextTracksChange.bind(this));
    listenEvent(textTracks, "remove", this._onTextTracksChange.bind(this));
    listenEvent(textTracks, "mode-change", this._onTextTrackModeChange.bind(this));
  }
  _addQualityListeners() {
    const qualities = this._media.qualities;
    listenEvent(qualities, "add", this._onQualitiesChange.bind(this));
    listenEvent(qualities, "remove", this._onQualitiesChange.bind(this));
    listenEvent(qualities, "change", this._onQualityChange.bind(this));
    listenEvent(qualities, "auto-change", this._onAutoQualityChange.bind(this));
    listenEvent(qualities, "readonly-change", this._onCanSetQualityChange.bind(this));
  }
  _addAudioTrackListeners() {
    const audioTracks = this._media.audioTracks;
    listenEvent(audioTracks, "add", this._onAudioTracksChange.bind(this));
    listenEvent(audioTracks, "remove", this._onAudioTracksChange.bind(this));
    listenEvent(audioTracks, "change", this._onAudioTrackChange.bind(this));
  }
  _onTextTracksChange(event) {
    const { textTracks } = this._store;
    textTracks.set(this._media.textTracks.toArray());
    this.dispatch("text-tracks-change", {
      detail: textTracks(),
      trigger: event
    });
  }
  _onTextTrackModeChange(event) {
    if (event)
      this._satisfyRequest("textTrack", event);
    const current = this._media.textTracks.selected, { textTrack } = this._store;
    if (textTrack() !== current) {
      textTrack.set(current);
      this.dispatch("text-track-change", {
        detail: current,
        trigger: event
      });
    }
  }
  _onAudioTracksChange(event) {
    const { audioTracks } = this._store;
    audioTracks.set(this._media.audioTracks.toArray());
    this.dispatch("audio-tracks-change", {
      detail: audioTracks(),
      trigger: event
    });
  }
  _onAudioTrackChange(event) {
    const { audioTrack } = this._store;
    audioTrack.set(this._media.audioTracks.selected);
    this._satisfyRequest("audioTrack", event);
    this.dispatch("audio-track-change", {
      detail: audioTrack(),
      trigger: event
    });
  }
  _onQualitiesChange(event) {
    const { qualities } = this._store;
    qualities.set(this._media.qualities.toArray());
    this.dispatch("qualities-change", {
      detail: qualities(),
      trigger: event
    });
  }
  _onQualityChange(event) {
    const { quality } = this._store;
    quality.set(this._media.qualities.selected);
    this._satisfyRequest("quality", event);
    this.dispatch("quality-change", {
      detail: quality(),
      trigger: event
    });
  }
  _onAutoQualityChange() {
    this._store.autoQuality.set(this._media.qualities.auto);
  }
  _onCanSetQualityChange() {
    this._store.canSetQuality.set(!this._media.qualities.readonly);
  }
  ["provider-change"](event) {
    this._media.$provider.set(event.detail);
  }
  ["autoplay"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play"));
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
    this._store.autoplayError.set(void 0);
  }
  ["autoplay-fail"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play-fail"));
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
    this._store.autoplayError.set(event.detail);
    this._resetTracking();
  }
  ["can-load"](event) {
    this._store.canLoad.set(true);
    this._trackedEvents.set("can-load", event);
    this._satisfyRequest("load", event);
    this._media.textTracks[TEXT_TRACK_CAN_LOAD]();
  }
  ["media-type-change"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    const viewType = this._store.viewType();
    this._store.mediaType.set(event.detail);
    if (viewType !== this._store.viewType()) {
      setTimeout(
        () => this.dispatch("view-type-change", {
          detail: this._store.viewType(),
          trigger: event
        }),
        0
      );
    }
  }
  ["stream-type-change"](event) {
    const { streamType, inferredStreamType } = this._store;
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    inferredStreamType.set(event.detail);
    event.detail = streamType();
  }
  ["rate-change"](event) {
    this._store.playbackRate.set(event.detail);
    this._satisfyRequest("rate", event);
  }
  ["sources-change"](event) {
    this._store.sources.set(event.detail);
  }
  ["source-change"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("sources-change"));
    this._store.source.set(event.detail);
    this.el?.setAttribute("aria-busy", "true");
    {
      this._media.logger?.infoGroup("\u{1F4FC} Media source change").labelledLog("Source", event.detail).dispatch();
    }
    if (this._skipInitialSrcChange) {
      this._skipInitialSrcChange = false;
      return;
    }
    this._media.audioTracks[LIST_RESET](event);
    this._media.qualities[LIST_RESET](event);
    this._resetTracking();
    softResetMediaStore(this._media.$store);
    this._trackedEvents.set(event.type, event);
  }
  ["abort"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    appendTriggerEvent(event, this._trackedEvents.get("can-load"));
  }
  ["load-start"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
  }
  ["error"](event) {
    this._store.error.set(event.detail);
    appendTriggerEvent(event, this._trackedEvents.get("abort"));
  }
  ["loaded-metadata"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("load-start"));
  }
  ["loaded-data"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("load-start"));
  }
  ["can-play"](event) {
    if (event.trigger?.type !== "loadedmetadata") {
      appendTriggerEvent(event, this._trackedEvents.get("loaded-metadata"));
    }
    this._onCanPlayDetail(event.detail);
    this.el?.setAttribute("aria-busy", "false");
  }
  ["can-play-through"](event) {
    this._onCanPlayDetail(event.detail);
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
  }
  _onCanPlayDetail(detail) {
    const { seekable, seekableEnd, buffered, duration, canPlay } = this._store;
    seekable.set(detail.seekable);
    buffered.set(detail.buffered);
    duration.set(seekableEnd);
    canPlay.set(true);
  }
  ["duration-change"](event) {
    const { live, duration } = this._store, time = event.detail;
    if (!live())
      duration.set(!Number.isNaN(time) ? time : 0);
  }
  ["progress"](event) {
    const { buffered, seekable, live, duration, seekableEnd } = this._store, detail = event.detail;
    buffered.set(detail.buffered);
    seekable.set(detail.seekable);
    if (live()) {
      duration.set(seekableEnd);
      this.dispatch("duration-change", {
        detail: seekableEnd(),
        trigger: event
      });
    }
  }
  ["play"](event) {
    const { paused, autoplayError, ended, autoplaying } = this._store;
    event.autoplay = autoplaying();
    if (this._request._looping || !paused()) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this._trackedEvents.get("waiting"));
    this._satisfyRequest("play", event);
    paused.set(false);
    autoplayError.set(void 0);
    if (ended() || this._request._replaying) {
      this._request._replaying = false;
      ended.set(false);
      this._handle(this.createEvent("replay", { trigger: event }));
    }
  }
  ["play-fail"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play"));
    this._satisfyRequest("play", event);
    const { paused, playing } = this._store;
    paused.set(true);
    playing.set(false);
    this._resetTracking();
  }
  ["playing"](event) {
    const playEvent = this._trackedEvents.get("play");
    if (playEvent) {
      appendTriggerEvent(event, this._trackedEvents.get("waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, this._trackedEvents.get("seeked"));
    }
    setTimeout(() => this._resetTracking(), 0);
    const { paused, playing, seeking, ended } = this._store;
    paused.set(false);
    playing.set(true);
    seeking.set(false);
    ended.set(false);
    if (this._request._looping) {
      event.stopImmediatePropagation();
      this._request._looping = false;
      return;
    }
    this["started"](event);
  }
  ["started"](event) {
    const { started, live, liveSyncPosition, seekableEnd } = this._store;
    if (!started()) {
      if (live()) {
        const end = liveSyncPosition() ?? seekableEnd() - 2;
        if (Number.isFinite(end))
          this._media.$provider().currentTime = end;
      }
      started.set(true);
      this._handle(this.createEvent("started", { trigger: event }));
    }
  }
  ["pause"](event) {
    if (this._request._looping) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this._trackedEvents.get("seeked"));
    this._satisfyRequest("pause", event);
    const { paused, playing, seeking } = this._store;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    this._resetTracking();
  }
  ["time-update"](event) {
    const { currentTime, played, waiting } = this._store, detail = event.detail;
    currentTime.set(detail.currentTime);
    played.set(detail.played);
    waiting.set(false);
    for (const track of this._media.textTracks) {
      if (track.mode === "disabled")
        continue;
      track[TEXT_TRACK_UPDATE_ACTIVE_CUES](detail.currentTime, event);
    }
  }
  ["volume-change"](event) {
    const { volume, muted } = this._store, detail = event.detail;
    volume.set(detail.volume);
    muted.set(detail.muted || detail.volume === 0);
    this._satisfyRequest("volume", event);
  }
  ["seeked"](event) {
    const { seeking, currentTime, paused, duration, ended } = this._store;
    if (this._request._seeking) {
      seeking.set(true);
      event.stopImmediatePropagation();
    } else if (seeking()) {
      const waitingEvent = this._trackedEvents.get("waiting");
      appendTriggerEvent(event, waitingEvent);
      if (waitingEvent?.trigger?.type !== "seeking") {
        appendTriggerEvent(event, this._trackedEvents.get("seeking"));
      }
      if (paused())
        this._stopWaiting();
      seeking.set(false);
      if (event.detail !== duration())
        ended.set(false);
      currentTime.set(event.detail);
      this._satisfyRequest("seeked", event);
      const origin = event.originEvent;
      if (origin && origin.isTrusted && !/seek/.test(origin.type)) {
        this["started"](event);
      }
    }
  }
  ["waiting"](event) {
    if (this._firingWaiting || this._request._seeking)
      return;
    event.stopImmediatePropagation();
    this._waitingTrigger = event;
    this._fireWaiting();
  }
  ["ended"](event) {
    if (this._request._looping) {
      event.stopImmediatePropagation();
      return;
    }
    const { paused, playing, seeking, ended } = this._store;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    ended.set(true);
    this._resetTracking();
  }
  _stopWaiting() {
    this._fireWaiting.cancel();
    this._store.waiting.set(false);
  }
  ["fullscreen-change"](event) {
    this._store.fullscreen.set(event.detail);
    this._satisfyRequest("fullscreen", event);
  }
  ["fullscreen-error"](event) {
    this._satisfyRequest("fullscreen", event);
  }
  ["picture-in-picture-change"](event) {
    this._store.pictureInPicture.set(event.detail);
    this._satisfyRequest("pip", event);
  }
  ["picture-in-picture-error"](event) {
    this._satisfyRequest("pip", event);
  }
};

// src/player/core/state/media-store-sync.ts
var MediaStoreSync = class extends ComponentController {
  onAttach(el) {
    effect2(this._onLogLevelChange.bind(this));
    effect2(this._onAutoplayChange.bind(this));
    effect2(this._onPosterChange.bind(this));
    effect2(this._onLoopChange.bind(this));
    effect2(this._onControlsChange.bind(this));
    effect2(this._onCrossOriginChange.bind(this));
    effect2(this._onPlaysinlineChange.bind(this));
    effect2(this._onLiveToleranceChange.bind(this));
    effect2(this._onLiveChange.bind(this));
    effect2(this._onLiveEdgeChange.bind(this));
    effect2(this._onThumbnailsChange.bind(this));
  }
  _onLogLevelChange() {
    this.$store.logLevel.set(this.$props.logLevel());
  }
  _onAutoplayChange() {
    const autoplay = this.$props.autoplay();
    this.$store.autoplay.set(autoplay);
    this.dispatch("autoplay-change", { detail: autoplay });
  }
  _onLoopChange() {
    const loop = this.$props.loop();
    this.$store.loop.set(loop);
    this.dispatch("loop-change", { detail: loop });
  }
  _onControlsChange() {
    const controls = this.$props.controls();
    this.$store.controls.set(controls);
    this.dispatch("controls-change", { detail: controls });
  }
  _onPosterChange() {
    const poster = this.$props.poster();
    this.$store.poster.set(poster);
    this.dispatch("poster-change", { detail: poster });
  }
  _onCrossOriginChange() {
    this.$store.crossorigin.set(this.$props.crossorigin());
  }
  _onPlaysinlineChange() {
    const playsinline = this.$props.playsinline();
    this.$store.playsinline.set(playsinline);
    this.dispatch("playsinline-change", { detail: playsinline });
  }
  _onLiveChange() {
    this.dispatch("live-change", { detail: this.$store.live() });
  }
  _onLiveToleranceChange() {
    this.$store.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
    this.$store.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
  }
  _onLiveEdgeChange() {
    this.dispatch("live-edge-change", { detail: this.$store.liveEdge() });
  }
  _onThumbnailsChange() {
    this.$store.thumbnails.set(this.$props.thumbnails());
  }
};

// src/player/core/state/remote-control.ts
var MediaRemoteControl = class {
  constructor(_logger) {
    this._logger = _logger;
    this._target = null;
    this._player = null;
    this._prevTrackIndex = -1;
  }
  /**
   * Set the target from which to dispatch media requests events from. The events should bubble
   * up from this target to the `<media-player>` element.
   *
   * @example
   * ```ts
   * const button = document.querySelector('button');
   * remote.setTarget(button);
   * ```
   */
  setTarget(target) {
    this._target = target;
    this._logger?.setTarget(target);
  }
  /**
   * Returns the current `<media-player>` element. This method will attempt to find the player by
   * searching up from either the given `target` or default target set via `remote.setTarget`.
   *
   * @example
   * ```ts
   * const player = remote.getPlayer();
   * ```
   */
  getPlayer(target) {
    if (this._player)
      return this._player;
    (target ?? this._target)?.dispatchEvent(
      new DOMEvent("find-media-player", {
        detail: (player) => void (this._player = player),
        bubbles: true,
        composed: true
      })
    );
    return this._player;
  }
  /**
   * Set the current `<media-player>` element so the remote can support toggle methods such as
   * `togglePaused` as they rely on the current media state.
   */
  setPlayer(player) {
    this._player = player;
  }
  /**
   * Dispatch a request to start the media loading process. This will only work if the media
   * player has been initialized with a custom loading strategy `<media-player load="custom">`.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#loading-strategies}
   */
  startLoading(trigger) {
    this._dispatchRequest("media-start-loading", trigger);
  }
  /**
   * Dispatch a request to begin/resume media playback.
   */
  play(trigger) {
    this._dispatchRequest("media-play-request", trigger);
  }
  /**
   * Dispatch a request to pause media playback.
   */
  pause(trigger) {
    this._dispatchRequest("media-pause-request", trigger);
  }
  /**
   * Dispatch a request to set the media volume to mute (0).
   */
  mute(trigger) {
    this._dispatchRequest("media-mute-request", trigger);
  }
  /**
   * Dispatch a request to unmute the media volume and set it back to it's previous state.
   */
  unmute(trigger) {
    this._dispatchRequest("media-unmute-request", trigger);
  }
  /**
   * Dispatch a request to enter fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  enterFullscreen(target, trigger) {
    this._dispatchRequest("media-enter-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to exit fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  exitFullscreen(target, trigger) {
    this._dispatchRequest("media-exit-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to enter picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  enterPictureInPicture(trigger) {
    this._dispatchRequest("media-enter-pip-request", trigger);
  }
  /**
   * Dispatch a request to exit picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  exitPictureInPicture(trigger) {
    this._dispatchRequest("media-exit-pip-request", trigger);
  }
  /**
   * Notify the media player that a seeking process is happening and to seek to the given `time`.
   */
  seeking(time, trigger) {
    this._dispatchRequest("media-seeking-request", trigger, time);
  }
  /**
   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
   * This is generally called after a series of `remote.seeking()` calls.
   */
  seek(time, trigger) {
    this._dispatchRequest("media-seek-request", trigger, time);
  }
  seekToLiveEdge(trigger) {
    this._dispatchRequest("media-live-edge-request", trigger);
  }
  /**
   * Dispatch a request to update the media volume to the given `volume` level which is a value
   * between 0 and 1.
   *
   * @example
   * ```ts
   * remote.changeVolume(0); // 0%
   * remote.changeVolume(0.05); // 5%
   * remote.changeVolume(0.5); // 50%
   * remote.changeVolume(0.75); // 70%
   * remote.changeVolume(1); // 100%
   * ```
   */
  changeVolume(volume, trigger) {
    this._dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
  }
  /**
   * Dispatch a request to change the current audio track.
   *
   * @example
   * ```ts
   * remote.changeAudioTrack(1); // track at index 1
   * ```
   */
  changeAudioTrack(index, trigger) {
    this._dispatchRequest("media-audio-track-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
   * selection.
   *
   * @example
   * ```ts
   * remote.changeQuality(-1); // auto
   * remote.changeQuality(1); // quality at index 1
   * ```
   */
  changeQuality(index, trigger) {
    this._dispatchRequest("media-quality-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the mode of the text track at the given index.
   *
   * @example
   * ```ts
   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
   * ```
   */
  changeTextTrackMode(index, mode, trigger) {
    this._dispatchRequest("media-text-track-change-request", trigger, {
      index,
      mode
    });
  }
  /**
   * Dispatch a request to change the media playback rate.
   *
   * @example
   * ```ts
   * remote.changePlaybackRate(0.5); // Half the normal speed
   * remote.changePlaybackRate(1); // Normal speed
   * remote.changePlaybackRate(1.5); // 50% faster than normal
   * remote.changePlaybackRate(2); // Double the normal speed
   * ```
   */
  changePlaybackRate(rate, trigger) {
    this._dispatchRequest("media-rate-change-request", trigger, rate);
  }
  /**
   * Dispatch a request to resume user idle tracking. Refer to {@link MediaRemoteControl.pauseUserIdle}
   * for more information.
   */
  resumeUserIdle(trigger) {
    this._dispatchRequest("media-resume-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to pause user idle tracking. Pausing tracking will result in the `user-idle`
   * attribute and state being `false` until `remote.resumeUserIdle()` is called. This method
   * is generally used when building custom controls and you'd like to prevent the UI from
   * dissapearing.
   *
   * @example
   * ```ts
   * // Prevent user idling while menu is being interacted with.
   * function onSettingsOpen() {
   *   remote.pauseUserIdle();
   * }
   *
   * function onSettingsClose() {
   *   remote.resumeUserIdle();
   * }
   * ```
   */
  pauseUserIdle(trigger) {
    this._dispatchRequest("media-pause-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to toggle the media playback state.
   */
  togglePaused(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.togglePaused.name);
      return;
    }
    if (player.state.paused)
      this.play(trigger);
    else
      this.pause(trigger);
  }
  /**
   * Dispatch a request to toggle the user idle state.
   */
  toggleUserIdle(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleUserIdle.name);
      return;
    }
    player.user.idle(!player.user.idling, 0, trigger);
  }
  /**
   * Dispatch a request to toggle the media muted state.
   */
  toggleMuted(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleMuted.name);
      return;
    }
    if (player.state.muted)
      this.unmute(trigger);
    else
      this.mute(trigger);
  }
  /**
   * Dispatch a request to toggle the media fullscreen state.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  toggleFullscreen(target, trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleFullscreen.name);
      return;
    }
    if (player.state.fullscreen)
      this.exitFullscreen(target, trigger);
    else
      this.enterFullscreen(target, trigger);
  }
  /**
   * Dispatch a request to toggle the media picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  togglePictureInPicture(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.togglePictureInPicture.name);
      return;
    }
    if (player.state.pictureInPicture)
      this.exitPictureInPicture(trigger);
    else
      this.enterPictureInPicture(trigger);
  }
  /**
   * Dispatch a request to toggle the current captions mode.
   */
  toggleCaptions(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      this._noPlayerWarning(this.toggleCaptions.name);
      return;
    }
    const tracks = player.state.textTracks, track = player.state.textTrack;
    if (track) {
      const index = tracks.indexOf(track);
      this.changeTextTrackMode(index, "disabled", trigger);
      this._prevTrackIndex = index;
    } else {
      let index = this._prevTrackIndex;
      if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
        index = -1;
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2) && track2.default);
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2));
      }
      if (index >= 0)
        this.changeTextTrackMode(index, "showing", trigger);
      this._prevTrackIndex = -1;
    }
  }
  _dispatchRequest(type, trigger, detail) {
    const request = new DOMEvent(type, {
      bubbles: true,
      composed: true,
      detail,
      trigger
    });
    const shouldUsePlayer = trigger?.target && (trigger.target === document || trigger.target === window || trigger.target === document.body || this._player && !this._player.contains(trigger.target));
    const target = shouldUsePlayer ? this._target ?? this.getPlayer() : trigger?.target ?? this._target;
    {
      this._logger?.infoGroup(`\u{1F4E8} dispatching \`${type}\``).labelledLog("Target", target).labelledLog("Player", this._player).labelledLog("Request Event", request).labelledLog("Trigger Event", trigger).dispatch();
    }
    target?.dispatchEvent(request);
  }
  _noPlayerWarning(method2) {
    {
      console.warn(
        `[vidstack] attempted to call \`MediaRemoteControl.${method2}\`() that requires player but failed because remote could not find a parent player element from target`
      );
    }
  }
};

// src/player/core/thumbnails/loader.ts
var ThumbnailsLoader = class extends ComponentController {
  onConnect() {
    this._media = useMedia();
    effect2(this._onLoadCues.bind(this));
  }
  _onLoadCues() {
    const { canLoad, thumbnailCues } = this._media.$store;
    if (!canLoad())
      return;
    const controller = new AbortController(), { crossorigin, thumbnails } = this._media.$store;
    const src = thumbnails();
    if (!src)
      return;
    import('./chunks/dev-DOQY4JGU.js').then(({ parseResponse }) => {
      parseResponse(
        fetch(src, {
          signal: controller.signal,
          credentials: getRequestCredentials(crossorigin())
        })
      ).then(({ cues }) => thumbnailCues.set(cues)).catch(noop);
    });
    return () => {
      controller.abort();
      thumbnailCues.set([]);
    };
  }
};

// src/player/core/tracks/audio-tracks.ts
var AudioTrackList = class extends SelectList {
  getById(id2) {
    if (id2 === "")
      return null;
    return this._items.find((track) => track.id === id2) ?? null;
  }
};

// src/player/core/tracks/text/render/native-text-renderer.ts
var NativeTextRenderer = class {
  constructor() {
    this.priority = 0;
    this._display = true;
    this._video = null;
    this._track = null;
    this._tracks = /* @__PURE__ */ new Set();
  }
  canRender() {
    return true;
  }
  attach(video) {
    this._video = video;
    if (!video.crossOrigin)
      video.crossOrigin = "anonymous";
    video.textTracks.onchange = this._onChange.bind(this);
  }
  addTrack(track) {
    this._tracks.add(track);
    this._attachTrack(track);
  }
  removeTrack(track) {
    track[TEXT_TRACK_NATIVE]?.remove?.();
    track[TEXT_TRACK_NATIVE] = null;
    this._tracks.delete(track);
  }
  changeTrack(track) {
    const prev = this._track?.[TEXT_TRACK_NATIVE], current = track?.[TEXT_TRACK_NATIVE];
    if (prev && this._track !== track)
      prev.track.mode = "disabled";
    if (current)
      current.track.mode = "showing";
    this._track = track;
  }
  setDisplay(display) {
    this._display = display;
  }
  detach() {
    if (this._video)
      this._video.textTracks.onchange = null;
    for (const track of this._tracks)
      this.removeTrack(track);
    this._tracks.clear();
    this._video = null;
    this._track = null;
  }
  _attachTrack(track) {
    var _a4;
    if (!this._video)
      return;
    const el = track[_a4 = TEXT_TRACK_NATIVE] ?? (track[_a4] = this._createTrackElement(track));
    if (el instanceof HTMLElement)
      this._video.append(el);
  }
  _createTrackElement(track) {
    const el = document.createElement("track");
    el.src = "https://cdn.jsdelivr.net/npm/vidstack/empty.vtt";
    el.id = track.id;
    el.label = track.label;
    el.kind = track.kind;
    el.default = track.default;
    track.language && (el.srclang = track.language);
    return el;
  }
  _copyCues(track, native) {
    if (native.cues?.length)
      return;
    for (const cue of track.cues)
      native.addCue(cue);
  }
  _onChange(event) {
    for (const track of this._tracks) {
      const nativeTrack = track[TEXT_TRACK_NATIVE]?.track;
      if (!nativeTrack)
        continue;
      if (!this._display) {
        nativeTrack.mode = "disabled";
        continue;
      }
      if (nativeTrack.mode === "showing") {
        this._copyCues(track, nativeTrack);
        track.setMode("showing", event);
      } else if (track.mode === "showing") {
        track.setMode("disabled", event);
      }
    }
  }
};

// src/player/core/tracks/text/render/text-renderer.ts
var TextRenderers = class {
  constructor(_media) {
    this._media = _media;
    this._video = null;
    this._renderers = [];
    this._nativeDisplay = false;
    this._nativeRenderer = null;
    this._customRenderer = null;
    const textTracks = _media.textTracks;
    this._textTracks = textTracks;
    effect2(this._watchControls.bind(this));
    onDispose(this._detach.bind(this));
    listenEvent(textTracks, "add", this._onAddTrack.bind(this));
    listenEvent(textTracks, "remove", this._onRemoveTrack.bind(this));
    listenEvent(textTracks, "mode-change", this._update.bind(this));
  }
  _watchControls() {
    const { $store, $iosControls } = this._media;
    this._nativeDisplay = $store.controls() || $iosControls();
    this._update();
  }
  add(renderer) {
    this._renderers.push(renderer);
    this._update();
  }
  remove(renderer) {
    renderer.detach();
    this._renderers.splice(this._renderers.indexOf(renderer), 1);
    this._update();
  }
  /* @internal */
  [ATTACH_VIDEO](video) {
    requestAnimationFrame(() => {
      this._video = video;
      if (video) {
        this._nativeRenderer = new NativeTextRenderer();
        this._nativeRenderer.attach(video);
        for (const track of this._textTracks)
          this._addNativeTrack(track);
      }
      this._update();
    });
  }
  _addNativeTrack(track) {
    if (!isTrackCaptionKind(track))
      return;
    this._nativeRenderer?.addTrack(track);
  }
  _removeNativeTrack(track) {
    if (!isTrackCaptionKind(track))
      return;
    this._nativeRenderer?.removeTrack(track);
  }
  _onAddTrack(event) {
    this._addNativeTrack(event.detail);
  }
  _onRemoveTrack(event) {
    this._removeNativeTrack(event.detail);
  }
  _update() {
    if (!this._video) {
      this._detach();
      return;
    }
    const currentTrack = this._textTracks.selected;
    if (this._nativeDisplay || currentTrack?.[TEXT_TRACK_NATIVE_HLS]) {
      this._customRenderer?.changeTrack(null);
      this._nativeRenderer.setDisplay(true);
      this._nativeRenderer.changeTrack(currentTrack);
      return;
    }
    this._nativeRenderer.setDisplay(false);
    this._nativeRenderer.changeTrack(null);
    if (!currentTrack) {
      this._customRenderer?.changeTrack(null);
      return;
    }
    const customRenderer = this._renderers.sort((a, b) => a.priority - b.priority).find((loader) => loader.canRender(currentTrack));
    if (this._customRenderer !== customRenderer) {
      this._customRenderer?.detach();
      customRenderer?.attach(this._video);
      this._customRenderer = customRenderer ?? null;
    }
    customRenderer?.changeTrack(currentTrack);
  }
  _detach() {
    this._nativeRenderer?.detach();
    this._nativeRenderer = null;
    this._customRenderer?.detach();
    this._customRenderer = null;
  }
};

// src/player/core/tracks/text/text-tracks.ts
var TextTrackList = class extends List {
  constructor() {
    super(...arguments);
    this._canLoad = false;
    this._defaults = {};
    this._onTrackModeChangeBind = this._onTrackModeChange.bind(this);
  }
  get selected() {
    const track = this._items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
    return track ?? null;
  }
  add(init2, trigger) {
    const isTrack = init2 instanceof TextTrack, track = isTrack ? init2 : new TextTrack(init2);
    if (this._defaults[init2.kind] && init2.default)
      delete init2.default;
    track.addEventListener("mode-change", this._onTrackModeChangeBind);
    this[LIST_ADD](track, trigger);
    track[TEXT_TRACK_CROSSORIGIN] = this[TEXT_TRACK_CROSSORIGIN];
    if (this._canLoad)
      track[TEXT_TRACK_CAN_LOAD]();
    if (init2.default) {
      this._defaults[init2.kind] = track;
      track.mode = "showing";
    }
    return this;
  }
  remove(track, trigger) {
    if (!this._items.includes(track))
      return;
    if (track === this._defaults[track.kind])
      delete this._defaults[track.kind];
    track.mode = "disabled";
    track[TEXT_TRACK_ON_MODE_CHANGE] = null;
    track.removeEventListener("mode-change", this._onTrackModeChangeBind);
    this[LIST_REMOVE](track, trigger);
    return this;
  }
  clear(trigger) {
    for (const track of this._items)
      this.remove(track, trigger);
    return this;
  }
  getById(id2) {
    return this._items.find((track) => track.id === id2) ?? null;
  }
  getByKind(kind) {
    const kinds = Array.isArray(kind) ? kind : [kind];
    return this._items.filter((track) => kinds.includes(track.kind));
  }
  /* @internal */
  [(TEXT_TRACK_CAN_LOAD)]() {
    if (this._canLoad)
      return;
    for (const track of this._items)
      track[TEXT_TRACK_CAN_LOAD]();
    this._canLoad = true;
  }
  _onTrackModeChange(event) {
    const track = event.detail;
    if (track.mode === "showing") {
      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
      for (const t of this._items) {
        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
          t.mode = "disabled";
        }
      }
    }
    this.dispatchEvent(
      new DOMEvent("mode-change", {
        detail: event.detail,
        trigger: event
      })
    );
  }
};

// src/player/core/player.tsx
var Player = class extends Component {
  constructor(instance) {
    super(instance);
    this._canPlayQueue = new RequestQueue();
    this._initStore();
    new MediaStoreSync(instance);
    const context = {
      player: null,
      scope: getScope(),
      qualities: new VideoQualityList(),
      audioTracks: new AudioTrackList(),
      $provider: signal(null),
      $props: this.$props,
      $store: this.$store
    };
    {
      const logPrinter = new LogPrinter(instance);
      effect2(() => {
        logPrinter.logLevel = this.$props.logLevel();
      });
    }
    context.logger = new Logger();
    context.remote = new MediaRemoteControl(context.logger );
    context.$iosControls = computed(this._isIOSControls.bind(this));
    context.textTracks = new TextTrackList();
    context.textTracks[TEXT_TRACK_CROSSORIGIN] = this.$props.crossorigin;
    context.textRenderers = new TextRenderers(context);
    context.ariaKeys = {};
    this._media = context;
    provideContext(mediaContext, context);
    this.orientation = new ScreenOrientationController(instance);
    new FocusVisibleController(instance);
    new MediaKeyboardController(instance, context);
    new ThumbnailsLoader(instance);
    new MediaEventsLogger(instance, context);
    const request = new MediaRequestContext();
    this._stateMgr = new MediaStateManager(instance, request, context);
    this._requestMgr = new MediaRequestManager(instance, this._stateMgr, request, context);
    context.delegate = new MediaPlayerDelegate(
      this._stateMgr._handle.bind(this._stateMgr),
      context
    );
    new MediaLoadController(instance, this.startLoading.bind(this));
  }
  get _provider() {
    return this._media.$provider();
  }
  onAttach(el) {
    el.setAttribute("tabindex", "0");
    setAttributeIfEmpty(el, "role", "region");
    effect2(this._watchTitle.bind(this));
    effect2(this._watchOrientation.bind(this));
    effect2(this._watchCanPlay.bind(this));
    effect2(this._watchMuted.bind(this));
    effect2(this._watchPaused.bind(this));
    effect2(this._watchVolume.bind(this));
    effect2(this._watchCurrentTime.bind(this));
    effect2(this._watchPlaysinline.bind(this));
    effect2(this._watchPlaybackRate.bind(this));
    this._setMediaAttributes();
    this._setMediaVars();
    this._media.player = el;
    this._media.remote.setTarget(el);
    this._media.remote.setPlayer(el);
    listenEvent(el, "find-media-player", this._onFindPlayer.bind(this));
  }
  onConnect(el) {
    if (IS_IPHONE)
      setAttribute(el, "data-iphone", "");
    const pointerQuery = window.matchMedia("(pointer: coarse)");
    this._onTouchChange(pointerQuery);
    pointerQuery.onchange = this._onTouchChange.bind(this);
    const resize = new ResizeObserver(this._onResize.bind(this));
    resize.observe(el);
    effect2(this._onResize.bind(this));
    this.dispatch("media-player-connect", {
      detail: this.el,
      bubbles: true,
      composed: true
    });
    {
      this._media.logger.setTarget(el);
      return () => this._media.logger.setTarget(null);
    }
  }
  _initStore() {
    const providedProps = {
      viewType: "providedViewType",
      streamType: "providedStreamType"
    };
    for (const prop2 of Object.keys(this.$props)) {
      this.$store[providedProps[prop2] ?? prop2]?.set(this.$props[prop2]());
    }
    effect2(this._onProvidedTypesChange.bind(this));
    this.$store.muted.set(this.$props.muted() || this.$props.volume() === 0);
  }
  _watchTitle() {
    const { title } = this.$props, { live, viewType } = this.$store, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media";
    const newTitle = title();
    if (newTitle) {
      this.el?.setAttribute("data-title", newTitle);
      this.el?.removeAttribute("title");
    }
    const currentTitle = this.el?.getAttribute("data-title") || "";
    this.$store.title.set(currentTitle);
    setAttribute(
      this.el,
      "aria-label",
      currentTitle ? `${typeText} - ${currentTitle}` : typeText + " Player"
    );
  }
  _watchOrientation() {
    const orientation = this.orientation.landscape ? "landscape" : "portrait";
    this.$store.orientation.set(orientation);
    setAttribute(this.el, "data-orientation", orientation);
    this._onResize();
  }
  _watchCanPlay() {
    if (this.$store.canPlay() && this._provider)
      this._canPlayQueue._start();
    else
      this._canPlayQueue._stop();
  }
  _onProvidedTypesChange() {
    this.$store.providedViewType.set(this.$props.viewType());
    this.$store.providedStreamType.set(this.$props.streamType());
  }
  _setMediaAttributes() {
    const $attrs = {
      "aspect-ratio": this.$props.aspectRatio,
      "data-captions": () => {
        const track = this.$store.textTrack();
        return !!track && isTrackCaptionKind(track);
      },
      "data-ios-controls": this._media.$iosControls
    };
    const mediaAttrName = {
      canPictureInPicture: "can-pip",
      pictureInPicture: "pip"
    };
    for (const prop2 of MEDIA_ATTRIBUTES) {
      const attrName = "data-" + (mediaAttrName[prop2] ?? camelToKebabCase(prop2));
      $attrs[attrName] = this.$store[prop2];
    }
    delete $attrs.title;
    this.setAttributes($attrs);
  }
  _setMediaVars() {
    this.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = this.$props.aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      }
    });
  }
  _onFindPlayer(event) {
    event.detail(this.el);
  }
  _onResize() {
    if (!this.el)
      return;
    const width = this.el.clientWidth, height = this.el.clientHeight, { smallBreakpointX, smallBreakpointY, largeBreakpointX, largeBreakpointY } = this.$props, bpx = width < smallBreakpointX() ? "sm" : width < largeBreakpointX() ? "md" : "lg", bpy = height < smallBreakpointY() ? "sm" : height < largeBreakpointY() ? "md" : "lg";
    this.$store.breakpointX.set(bpx);
    this.$store.breakpointY.set(bpy);
    setAttribute(this.el, "data-bp-x", bpx);
    setAttribute(this.el, "data-bp-y", bpy);
  }
  _onTouchChange(queryList) {
    const isTouch = queryList.matches;
    setAttribute(this.el, "data-touch", isTouch);
    this.$store.touchPointer.set(isTouch);
    this._onResize();
  }
  _isIOSControls() {
    return !canFullscreen() && this.$store.mediaType() === "video" && (this.$store.controls() && !this.$props.playsinline() || this.$store.fullscreen());
  }
  get provider() {
    return this._provider;
  }
  get user() {
    return this._requestMgr._user;
  }
  get qualities() {
    return this._media.qualities;
  }
  get audioTracks() {
    return this._media.audioTracks;
  }
  get textTracks() {
    return this._media.textTracks;
  }
  get textRenderers() {
    return this._media.textRenderers;
  }
  get paused() {
    return this._provider?.paused ?? true;
  }
  set paused(paused) {
    if (paused) {
      this._canPlayQueue._enqueue("paused", () => this._requestMgr._pause());
    } else
      this._canPlayQueue._enqueue("paused", () => this._requestMgr._play());
  }
  _watchPaused() {
    this.paused = this.$props.paused();
  }
  get muted() {
    return this._provider?.muted ?? false;
  }
  set muted(muted) {
    this._canPlayQueue._enqueue("muted", () => this._provider.muted = muted);
  }
  _watchMuted() {
    this.muted = this.$props.muted();
  }
  get currentTime() {
    return this._provider?.currentTime ?? 0;
  }
  set currentTime(time) {
    this._canPlayQueue._enqueue("currentTime", () => {
      const adapter = this._provider;
      if (time !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max(this.$store.seekableStart() + 0.1, time),
            this.$store.seekableEnd() - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  _watchCurrentTime() {
    this.currentTime = this.$props.currentTime();
  }
  get volume() {
    return this._provider?.volume ?? 1;
  }
  set volume(volume) {
    this._canPlayQueue._enqueue("volume", () => this._provider.volume = volume);
  }
  _watchVolume() {
    this.volume = clampNumber(0, this.$props.volume(), 1);
  }
  get playsinline() {
    return this._provider?.playsinline ?? false;
  }
  set playsinline(inline) {
    this._canPlayQueue._enqueue("playsinline", () => this._provider.playsinline = inline);
  }
  _watchPlaysinline() {
    this.playsinline = this.$props.playsinline();
  }
  get playbackRate() {
    return this._provider?.playbackRate ?? 1;
  }
  set playbackRate(rate) {
    this._canPlayQueue._enqueue("rate", () => this._provider.playbackRate = rate);
  }
  _watchPlaybackRate() {
    this.playbackRate = this.$props.playbackRate();
  }
  async play() {
    return this._requestMgr._play();
  }
  async pause() {
    return this._requestMgr._pause();
  }
  async enterFullscreen(target) {
    return this._requestMgr._enterFullscreen(target);
  }
  async exitFullscreen(target) {
    return this._requestMgr._exitFullscreen(target);
  }
  enterPictureInPicture() {
    return this._requestMgr._enterPictureInPicture();
  }
  exitPictureInPicture() {
    return this._requestMgr._exitPictureInPicture();
  }
  seekToLiveEdge() {
    this._requestMgr._seekToLiveEdge();
  }
  startLoading() {
    this._media.delegate._dispatch("can-load");
  }
  destroy() {
    this.dispatch("destroy");
  }
};
Player.el = defineElement({
  tagName: "media-player",
  props: mediaPlayerProps,
  store: MediaStoreFactory
});
__decorateClass([
  prop
], Player.prototype, "provider", 1);
__decorateClass([
  prop
], Player.prototype, "user", 1);
__decorateClass([
  prop
], Player.prototype, "orientation", 2);
__decorateClass([
  prop
], Player.prototype, "qualities", 1);
__decorateClass([
  prop
], Player.prototype, "audioTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textRenderers", 1);
__decorateClass([
  prop
], Player.prototype, "paused", 1);
__decorateClass([
  prop
], Player.prototype, "muted", 1);
__decorateClass([
  prop
], Player.prototype, "currentTime", 1);
__decorateClass([
  prop
], Player.prototype, "volume", 1);
__decorateClass([
  prop
], Player.prototype, "playsinline", 1);
__decorateClass([
  prop
], Player.prototype, "playbackRate", 1);
__decorateClass([
  method
], Player.prototype, "play", 1);
__decorateClass([
  method
], Player.prototype, "pause", 1);
__decorateClass([
  method
], Player.prototype, "enterFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "exitFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "enterPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "exitPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "seekToLiveEdge", 1);
__decorateClass([
  method
], Player.prototype, "startLoading", 1);

// src/icons/icon.tsx
var $$_templ4 = /* @__PURE__ */ $$_create_template(`<svg viewBox="0 0 32 32" fill="none" aria-hidden="true" focusable="false" data-media-icon="true"></svg>`);
function Icon2({ slot, part, paths: paths2, rotate }) {
  return (() => {
    const $$_root = $$_clone($$_templ4);
    $$_attr($$_root, "data-rotate", rotate);
    $$_attr($$_root, "slot", slot);
    $$_attr($$_root, "part", part);
    $$_root.innerHTML = paths2;
    return $$_root;
  })();
}

// src/player/skins/community/context.ts
function i18n(translations, key2) {
  return translations()?.[key2] ?? key2;
}
var communitySkinContext = createContext();
function useCommunitySkin() {
  return useContext(communitySkinContext);
}
function useCommunitySkinI18n() {
  return useCommunitySkin().$props.translations;
}

// src/player/skins/community/shared.tsx
var $$_templ5 = /* @__PURE__ */ $$_create_template(`<media-play-button default-appearance="" mk-d><media-tooltip mk-d><span slot="play"></span><span slot="pause"></span></media-tooltip></media-play-button>`);
var $$_templ_23 = /* @__PURE__ */ $$_create_template(`<media-mute-button default-appearance="" mk-d><media-tooltip mk-d><span slot="mute"></span><span slot="unmute"></span></media-tooltip></media-mute-button>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<media-caption-button default-appearance="" mk-d><media-tooltip mk-d><span slot="on"></span><span slot="off"></span></media-tooltip></media-caption-button>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<media-pip-button default-appearance="" mk-d><media-tooltip mk-d><span slot="enter"></span><span slot="exit"></span></media-tooltip></media-pip-button>`);
var $$_templ_5 = /* @__PURE__ */ $$_create_template(`<media-fullscreen-button default-appearance="" mk-d><media-tooltip position="top right" mk-d><span slot="enter"></span><span slot="exit"></span></media-tooltip></media-fullscreen-button>`);
var $$_templ_6 = /* @__PURE__ */ $$_create_template(`<media-seek-button mk-d><media-tooltip mk-d><span></span></media-tooltip></media-seek-button>`);
var $$_templ_7 = /* @__PURE__ */ $$_create_template(`<media-volume-slider mk-d><media-slider-value type="pointer" format="percent" slot="preview" mk-d></media-slider-value></media-volume-slider>`);
var $$_templ_8 = /* @__PURE__ */ $$_create_template(`<span part="main-title"></span>`);
var $$_templ_9 = $$_templ_8;
var $$_templ_10 = /* @__PURE__ */ $$_create_template(`<media-menu part="chapters-menu" mk-d><media-menu-button mk-d><media-tooltip mk-d></media-tooltip></media-menu-button><media-chapters-menu-items mk-d></media-chapters-menu-items></media-menu>`);
var $$_templ_11 = /* @__PURE__ */ $$_create_template(`<media-menu part="settings-menu" mk-d><media-menu-button mk-d><media-tooltip mk-d></media-tooltip></media-menu-button><media-menu-items mk-d><media-menu mk-d><media-audio-menu-button mk-d></media-audio-menu-button><media-audio-menu-items mk-d></media-audio-menu-items></media-menu><media-menu mk-d><media-playback-rate-menu-button mk-d></media-playback-rate-menu-button><media-playback-rate-menu-items mk-d></media-playback-rate-menu-items></media-menu><media-menu mk-d><media-quality-menu-button mk-d></media-quality-menu-button><media-quality-menu-items mk-d></media-quality-menu-items></media-menu><media-menu mk-d><media-captions-menu-button mk-d></media-captions-menu-button><media-captions-menu-items mk-d></media-captions-menu-items></media-menu></media-menu-items></media-menu>`);
var $$_templ_12 = /* @__PURE__ */ $$_create_template(`<div part="gestures"><media-gesture event="pointerup" action="toggle:paused" mk-d></media-gesture><media-gesture event="pointerup" action="toggle:user-idle" mk-d></media-gesture><media-gesture event="dblpointerup" action="toggle:fullscreen" mk-d></media-gesture><media-gesture event="dblpointerup" action="seek:-10" mk-d></media-gesture><media-gesture event="dblpointerup" action="seek:10" mk-d></media-gesture></div>`);
var $$_templ_13 = /* @__PURE__ */ $$_create_template(`<media-time-slider mk-d><div slot="preview"><media-slider-thumbnail mk-d></media-slider-thumbnail><div part="chapter-title"></div><media-slider-value type="pointer" format="time" mk-d></media-slider-value></div></media-time-slider>`);
var $$_templ_14 = /* @__PURE__ */ $$_create_template(`<div part="time-group"><media-time type="current" mk-d></media-time><div part="time-divider">/</div><media-time type="duration" mk-d></media-time></div>`);
function PlayButton({
  part,
  tooltip = "top left"
}) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ5), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling;
    $$_attr($$_root, "part", part);
    $$_scoped(() => {
      $$_attr($$_el, "position", tooltip);
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, "Play"));
        $$_insert_lite($$_el_3, () => i18n(lang, "Pause"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function MuteButton({ tooltip = "top center" }) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_23), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling;
    $$_scoped(() => {
      $$_attr($$_el, "position", tooltip);
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, "Mute"));
        $$_insert_lite($$_el_3, () => i18n(lang, "Unmute"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function CaptionButton({ tooltip = "top center" }) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_3), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling;
    $$_scoped(() => {
      $$_attr($$_el, "position", tooltip);
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, "Closed-Captions On"));
        $$_insert_lite($$_el_3, () => i18n(lang, "Closed-Captions Off"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function PiPButton() {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_4), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling;
    $$_scoped(() => {
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, "Enter PiP"));
        $$_insert_lite($$_el_3, () => i18n(lang, "Exit PiP"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function FullscreenButton() {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_5), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling;
    $$_scoped(() => {
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, "Enter Fullscreen"));
        $$_insert_lite($$_el_3, () => i18n(lang, "Exit Fullscreen"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function SeekButton({
  seconds,
  tooltip = "top center"
}) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_6), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild;
    $$_attr($$_root, "seconds", seconds);
    $$_scoped(() => {
      $$_insert_lite(
        $$_root,
        $$_create_component(Icon2, { paths: seconds >= 0 ? seek_forward_10_default : seek_backward_10_default }),
        $$_el
      );
      $$_attr($$_el, "position", tooltip);
      $$_scoped(() => {
        $$_insert_lite($$_el_2, () => i18n(lang, seconds >= 0 ? "Seek Forward" : "Seek Backward"));
      }, $$_setup_custom_element($$_el));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function VolumeSlider() {
  return (() => {
    const $$_root = $$_clone($$_templ_7), $$_el = $$_root.firstChild;
    $$_scoped(() => {
      $$_setup_custom_element($$_el);
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function ChapterTitleOrMainTitle() {
  const {
    $media: { title, textTracks, started }
  } = useCommunitySkin();
  const chapterTitle = signal(""), mainTitle = computed(() => started() ? chapterTitle() || title() : title());
  effect2(() => {
    const track = textTracks().find(
      (track2) => track2.kind === "chapters" && track2.mode === "showing"
    );
    track && listenEvent(track, "cue-change", () => {
      chapterTitle.set(track.activeCues[0]?.text || "");
    });
    return () => chapterTitle.set("");
  });
  return (() => {
    const $$_root = $$_clone($$_templ_9);
    $$_insert_lite($$_root, mainTitle);
    return $$_root;
  })();
}
function ChaptersMenu({
  position = "bottom",
  tooltip = "bottom center"
}) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_10), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el.nextSibling;
    $$_attr($$_root, "position", position);
    $$_scoped(() => {
      $$_scoped(() => {
        $$_insert_lite($$_el, $$_create_component(Icon2, { paths: chapters_default }), $$_el_2);
        $$_attr($$_el_2, "position", tooltip);
        $$_scoped(() => {
          $$_insert_lite($$_el_2, () => i18n(lang, "Chapters"));
        }, $$_setup_custom_element($$_el_2));
      }, $$_setup_custom_element($$_el));
      $$_setup_custom_element($$_el_3);
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function SettingsMenu({
  position = "bottom",
  tooltip = "bottom right"
}) {
  const lang = useCommunitySkinI18n();
  return (() => {
    const $$_root = $$_clone($$_templ_11), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el.nextSibling, $$_el_4 = $$_el_3.firstChild, $$_el_5 = $$_el_4.firstChild, $$_el_6 = $$_el_5.nextSibling, $$_el_7 = $$_el_4.nextSibling, $$_el_8 = $$_el_7.firstChild, $$_el_9 = $$_el_8.nextSibling, $$_el_10 = $$_el_7.nextSibling, $$_el_11 = $$_el_10.firstChild, $$_el_12 = $$_el_11.nextSibling, $$_el_13 = $$_el_10.nextSibling, $$_el_14 = $$_el_13.firstChild, $$_el_15 = $$_el_14.nextSibling;
    $$_attr($$_root, "position", position);
    $$_scoped(() => {
      $$_scoped(() => {
        $$_insert_lite($$_el, $$_create_component(Icon2, { paths: settings_default, rotate: true }), $$_el_2);
        $$_attr($$_el_2, "position", tooltip);
        $$_scoped(() => {
          $$_insert_lite($$_el_2, () => i18n(lang, "Settings"));
        }, $$_setup_custom_element($$_el_2));
      }, $$_setup_custom_element($$_el));
      $$_scoped(() => {
        $$_scoped(() => {
          $$_setup_custom_element($$_el_5, { label: () => i18n(lang, "Audio") });
          $$_setup_custom_element($$_el_6, { emptyLabel: () => i18n(lang, "Default") });
        }, $$_setup_custom_element($$_el_4));
        $$_scoped(() => {
          $$_setup_custom_element($$_el_8, { label: () => i18n(lang, "Speed") });
          $$_setup_custom_element($$_el_9, { normalLabel: () => i18n(lang, "Normal") });
        }, $$_setup_custom_element($$_el_7));
        $$_scoped(() => {
          $$_setup_custom_element($$_el_11, { label: () => i18n(lang, "Quality") });
          $$_setup_custom_element($$_el_12, { autoLabel: () => i18n(lang, "Auto") });
        }, $$_setup_custom_element($$_el_10));
        $$_scoped(() => {
          $$_setup_custom_element($$_el_14, { label: () => i18n(lang, "Captions") });
          $$_setup_custom_element($$_el_15, { offLabel: () => i18n(lang, "Off") });
        }, $$_setup_custom_element($$_el_13));
      }, $$_setup_custom_element($$_el_3));
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function VideoGestures() {
  return (() => {
    const $$_root = $$_clone($$_templ_12), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.nextSibling, $$_el_4 = $$_el_3.nextSibling, $$_el_5 = $$_el_4.nextSibling;
    $$_setup_custom_element($$_el);
    $$_setup_custom_element($$_el_2);
    $$_setup_custom_element($$_el_3);
    $$_setup_custom_element($$_el_4);
    $$_setup_custom_element($$_el_5);
    return $$_root;
  })();
}
function TimeSlider() {
  return (() => {
    const $$_root = $$_clone($$_templ_13), $$_el = $$_root.firstChild, $$_el_2 = $$_el.firstChild, $$_el_3 = $$_el_2.nextSibling, $$_el_4 = $$_el_3.nextSibling;
    $$_scoped(() => {
      $$_setup_custom_element($$_el_2);
      $$_setup_custom_element($$_el_4);
    }, $$_setup_custom_element($$_root));
    return $$_root;
  })();
}
function TimeGroup() {
  return (() => {
    const $$_root = $$_clone($$_templ_14), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.nextSibling;
    $$_setup_custom_element($$_el);
    $$_setup_custom_element($$_el_3);
    return $$_root;
  })();
}

// src/player/skins/community/audio.tsx
var $$_templ6 = /* @__PURE__ */ $$_create_template(`<div part="media-ui aod live:dvr mobile"><media-captions mk-d></media-captions><div part="controls"><div part="controls-group"></div><div part="controls-group"></div><div part="controls-group"><media-time type="current" mk-d></media-time><div part="controls-spacer"></div><media-time type="duration" mk-d></media-time></div><div part="controls-group"><div part="controls-spacer"></div><div part="controls-spacer"></div></div></div></div>`);
var $$_templ_24 = /* @__PURE__ */ $$_create_template(`<div part="media-ui aod live:dvr desktop"><media-captions mk-d></media-captions><div part="controls"><div part="controls-group"></div><div part="controls-group"></div></div></div>`);
function renderAudio(isMobile) {
  return isMobile ? MobileUI() : DesktopUI();
}
function MobileUI() {
  return (() => {
    const $$_root = $$_clone($$_templ6), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.firstChild, $$_el_4 = $$_el_3.nextSibling, $$_el_5 = $$_el_4.nextSibling, $$_el_6 = $$_el_5.firstChild, $$_el_7 = $$_el_6.nextSibling, $$_el_8 = $$_el_7.nextSibling, $$_el_9 = $$_el_5.nextSibling, $$_el_10 = $$_el_9.firstChild, $$_el_11 = $$_el_10.nextSibling;
    $$_setup_custom_element($$_el);
    $$_insert_lite($$_el_3, $$_create_component(MuteButton, { tooltip: "top left" }), null);
    $$_insert_lite($$_el_3, $$_create_component(ChapterTitleOrMainTitle), null);
    $$_insert_lite($$_el_3, $$_create_component(CaptionButton), null);
    $$_insert_lite($$_el_3, $$_create_component(ChaptersMenu, { tooltip: "top center", position: "top" }), null);
    $$_insert_lite($$_el_3, $$_create_component(SettingsMenu, { tooltip: "top right", position: "top" }), null);
    $$_insert_lite($$_el_4, $$_create_component(TimeSlider));
    $$_setup_custom_element($$_el_6);
    $$_setup_custom_element($$_el_8);
    $$_insert_lite($$_el_9, $$_create_component(SeekButton, { seconds: -10, tooltip: "top left" }), $$_el_11);
    $$_insert_lite($$_el_9, $$_create_component(PlayButton, { tooltip: "top center" }), $$_el_11);
    $$_insert_lite($$_el_9, $$_create_component(SeekButton, { seconds: 10 }), $$_el_11);
    return $$_root;
  })();
}
function DesktopUI() {
  return (() => {
    const $$_root = $$_clone($$_templ_24), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.firstChild, $$_el_4 = $$_el_3.nextSibling;
    $$_setup_custom_element($$_el);
    $$_insert_lite($$_el_3, $$_create_component(TimeSlider));
    $$_insert_lite($$_el_4, $$_create_component(SeekButton, { seconds: -10, tooltip: "top left" }), null);
    $$_insert_lite($$_el_4, $$_create_component(PlayButton, { tooltip: "top center" }), null);
    $$_insert_lite($$_el_4, $$_create_component(SeekButton, { seconds: 10 }), null);
    $$_insert_lite($$_el_4, $$_create_component(TimeGroup), null);
    $$_insert_lite($$_el_4, $$_create_component(ChapterTitleOrMainTitle), null);
    $$_insert_lite($$_el_4, $$_create_component(MuteButton, { tooltip: "top center" }), null);
    $$_insert_lite($$_el_4, $$_create_component(VolumeSlider), null);
    $$_insert_lite($$_el_4, $$_create_component(CaptionButton), null);
    $$_insert_lite($$_el_4, $$_create_component(ChaptersMenu, { tooltip: "top center", position: "top" }), null);
    $$_insert_lite($$_el_4, $$_create_component(SettingsMenu, { tooltip: "top right", position: "top" }), null);
    return $$_root;
  })();
}

// src/player/skins/community/video.tsx
var $$_templ7 = /* @__PURE__ */ $$_create_template(`<div part="media-ui vod live:dvr mobile"><media-captions mk-d></media-captions><media-buffering-indicator mk-d></media-buffering-indicator><div part="scrim"></div><div part="controls"><div part="controls-group"><div part="controls-spacer"></div></div><div part="controls-group"></div><div part="controls-group"><div part="controls-spacer"></div></div><div part="controls-group"></div></div><div part="start-duration"><media-time type="duration" mk-d></media-time></div></div>`);
var $$_templ_25 = /* @__PURE__ */ $$_create_template(`<div part="media-ui vod live:dvr desktop "><media-captions mk-d></media-captions><media-buffering-indicator mk-d></media-buffering-indicator><div part="scrim"></div><div part="controls"><div part="controls-group"><div part="controls-spacer"></div></div><div part="controls-group"></div><div part="controls-group"></div><div part="controls-group"></div></div></div>`);
function renderVideo(isMobile) {
  return isMobile ? MobileUI2() : DesktopUI2();
}
function MobileUI2() {
  return (() => {
    const $$_root = $$_clone($$_templ7), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.nextSibling, $$_el_4 = $$_el_3.nextSibling, $$_el_5 = $$_el_4.firstChild; $$_el_5.firstChild; const $$_el_7 = $$_el_5.nextSibling, $$_el_8 = $$_el_7.nextSibling, $$_el_9 = $$_el_8.firstChild, $$_el_10 = $$_el_8.nextSibling, $$_el_11 = $$_el_4.nextSibling, $$_el_12 = $$_el_11.firstChild;
    $$_insert_lite($$_root, $$_create_component(VideoGestures), $$_el);
    $$_setup_custom_element($$_el);
    $$_setup_custom_element($$_el_2);
    $$_insert_lite($$_el_5, $$_create_component(CaptionButton, { tooltip: "bottom center" }), null);
    $$_insert_lite($$_el_5, $$_create_component(ChaptersMenu), null);
    $$_insert_lite($$_el_5, $$_create_component(SettingsMenu, { tooltip: "bottom center" }), null);
    $$_insert_lite($$_el_5, $$_create_component(MuteButton, { tooltip: "bottom right" }), null);
    $$_insert_lite($$_el_7, $$_create_component(PlayButton, { tooltip: "top center" }));
    $$_insert_lite($$_el_8, $$_create_component(TimeGroup), $$_el_9);
    $$_insert_lite($$_el_8, $$_create_component(ChapterTitleOrMainTitle), $$_el_9);
    $$_insert_lite($$_el_8, $$_create_component(FullscreenButton), null);
    $$_insert_lite($$_el_10, $$_create_component(TimeSlider));
    $$_setup_custom_element($$_el_12);
    return $$_root;
  })();
}
function DesktopUI2() {
  return (() => {
    const $$_root = $$_clone($$_templ_25), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.nextSibling, $$_el_4 = $$_el_3.nextSibling, $$_el_5 = $$_el_4.firstChild; $$_el_5.firstChild; const $$_el_7 = $$_el_5.nextSibling, $$_el_8 = $$_el_7.nextSibling, $$_el_9 = $$_el_8.nextSibling;
    $$_insert_lite($$_root, $$_create_component(VideoGestures), $$_el);
    $$_setup_custom_element($$_el);
    $$_setup_custom_element($$_el_2);
    $$_insert_lite($$_el_5, $$_create_component(ChaptersMenu), null);
    $$_insert_lite($$_el_5, $$_create_component(SettingsMenu), null);
    $$_insert_lite($$_el_8, $$_create_component(TimeSlider));
    $$_insert_lite($$_el_9, $$_create_component(PlayButton), null);
    $$_insert_lite($$_el_9, $$_create_component(MuteButton), null);
    $$_insert_lite($$_el_9, $$_create_component(VolumeSlider), null);
    $$_insert_lite($$_el_9, $$_create_component(TimeGroup), null);
    $$_insert_lite($$_el_9, $$_create_component(ChapterTitleOrMainTitle), null);
    $$_insert_lite($$_el_9, $$_create_component(CaptionButton), null);
    $$_insert_lite($$_el_9, $$_create_component(PiPButton), null);
    $$_insert_lite($$_el_9, $$_create_component(FullscreenButton), null);
    return $$_root;
  })();
}

// src/player/skins/community/skin.tsx
var CommunitySkin = class extends Component {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
    provideContext(communitySkinContext, {
      $props: this.$props,
      $media: this._media.$store
    });
  }
  /** We need this to compute and save the layout type to prevent unnecessary re-renders. */
  _getLayoutType() {
    const { viewType, streamType } = this._media.$store;
    return viewType() === "audio" ? streamType().includes("live") ? "audio:live" : "audio" : streamType().endsWith("live") ? "video:live" : "video";
  }
  onAttach() {
    this.setAttributes({
      "data-audio": this._isAudio.bind(this),
      "data-video": this._isVideo.bind(this),
      "data-mobile": this._isMobile.bind(this)
    });
  }
  _isAudio() {
    const { viewType } = this._media.$store;
    return viewType() === "audio";
  }
  _isVideo() {
    const { viewType } = this._media.$store;
    return viewType() !== "audio";
  }
  _isMobile() {
    const { breakpointX } = this._media.$store;
    return breakpointX() === "sm";
  }
  render() {
    const $layoutType = computed(this._getLayoutType.bind(this)), $isMobile = computed(this._isMobile.bind(this));
    return () => {
      const render2 = $layoutType().startsWith("video") ? renderVideo : renderAudio;
      return render2($isMobile());
    };
  }
};
CommunitySkin.el = defineElement({
  tagName: "media-community-skin",
  nohydrate: true,
  props: {
    translations: null
  }
});
CommunitySkin.register = getUIComponents;

// src/player/ui/buffering-indicator.tsx
var $$_templ8 = /* @__PURE__ */ $$_create_template(`<svg part="icon" fill="none" viewBox="0 0 120 120" aria-hidden="true"><circle part="track" cx="60" cy="60" r="54" stroke="currentColor"></circle><circle part="track-fill" cx="60" cy="60" r="54" stroke="currentColor" pathLength="100"></circle></svg>`);
var BufferingIndicator = class extends Component {
  onAttach() {
    this._media = useMedia();
    this.setAttributes({
      "data-buffering": computed(this._isBuffering.bind(this))
    });
  }
  _isBuffering() {
    const { canPlay, waiting } = this._media.$store;
    return !canPlay() || waiting();
  }
  render() {
    return $$_clone($$_templ8);
  }
};
BufferingIndicator.el = defineElement({
  tagName: "media-buffering-indicator"
});

// src/utils/aria.ts
function ariaBool2(value) {
  return value ? "true" : "false";
}
function $ariaBool(signal2) {
  return () => ariaBool2(signal2());
}

// src/player/core/keyboard/aria-shortcuts.ts
var ARIAKeyShortcuts = class extends ComponentController {
  constructor(instance, _shortcut) {
    super(instance);
    this._shortcut = _shortcut;
  }
  onAttach(el) {
    const { $props, ariaKeys } = useMedia(), keys = el.getAttribute("aria-keyshortcuts");
    if (keys) {
      ariaKeys[this._shortcut] = keys;
      {
        onDispose(() => {
          delete ariaKeys[this._shortcut];
        });
      }
      return;
    }
    const shortcuts = $props.keyShortcuts()[this._shortcut];
    if (shortcuts)
      el.setAttribute("aria-keyshortcuts", shortcuts);
  }
};

// src/player/ui/tooltip/context.ts
var tooltipContext = createContext();

// src/player/ui/tooltip/tooltip-controller.ts
var id = 0;
var TooltipController = class extends ComponentController {
  constructor(instance) {
    super(instance);
    provideContext(tooltipContext, {
      _attachTooltip: this._attachTooltip.bind(this)
    });
  }
  _attachTooltip(tooltipEl) {
    const tooltipId = `media-tooltip-${++id}`;
    setAttribute(this.el, "aria-describedby", tooltipId);
    setAttribute(tooltipEl, "id", tooltipId);
    setAttribute(tooltipEl, "role", "tooltip");
    this.el.removeAttribute("aria-label");
  }
};

// src/player/ui/buttons/toggle-button.tsx
var toggleButtonProps = {
  disabled: false,
  defaultPressed: false,
  defaultAppearance: false
};
var ToggleButton = class extends Component {
  constructor(instance) {
    super(instance);
    this._pressed = signal(false);
    new FocusVisibleController(instance);
    new TooltipController(instance);
    if (this._keyShortcut)
      new ARIAKeyShortcuts(instance, this._keyShortcut);
  }
  get pressed() {
    return peek(this._pressed);
  }
  onAttach(el) {
    if (isWriteSignal(this._pressed)) {
      this._pressed.set(this.$props.defaultPressed());
    }
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "role", "button");
    const { disabled, defaultAppearance } = this.$props;
    this.setAttributes({
      disabled,
      "default-appearance": defaultAppearance,
      "data-pressed": this._pressed,
      "aria-pressed": this._isARIAPressed.bind(this),
      "data-media-button": true
    });
  }
  onConnect(el) {
    onPress(el, this._onMaybePress.bind(this));
  }
  _isARIAPressed() {
    return ariaBool(this._pressed());
  }
  _onPress(event) {
    if (isWriteSignal(this._pressed)) {
      this._pressed.set((p) => !p);
    }
  }
  _onMaybePress(event) {
    const disabled = this.$props.disabled();
    if (disabled) {
      if (disabled)
        event.stopImmediatePropagation();
      return;
    }
    event.preventDefault();
    this._onPress(event);
  }
};
ToggleButton.el = defineElement({
  tagName: "media-toggle-button",
  props: toggleButtonProps
});
__decorateClass([
  prop
], ToggleButton.prototype, "pressed", 1);

// src/player/ui/buttons/caption-button.tsx
var CaptionButton2 = class extends ToggleButton {
  constructor() {
    super(...arguments);
    this._keyShortcut = "toggleCaptions";
  }
  onAttach(el) {
    this._media = useMedia();
    this._pressed = this._isPressed.bind(this);
    super.onAttach(el);
    setARIALabel(el, this._getLabel.bind(this));
    this.setAttributes({
      "aria-hidden": $ariaBool(this._isHidden.bind(this))
    });
  }
  _onPress(event) {
    this._media.remote.toggleCaptions(event);
  }
  _isPressed() {
    const { textTrack } = this._media.$store, track = textTrack();
    return !!track && isTrackCaptionKind(track);
  }
  _isHidden() {
    const { textTracks } = this._media.$store;
    return textTracks().filter(isTrackCaptionKind).length == 0;
  }
  _getLabel() {
    const { textTrack } = this._media.$store;
    return textTrack() ? "Closed-Captions Off" : "Closed-Captions On";
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: closed_captions_on_default, slot: "on" }),
      $$_create_component(Icon2, { paths: closed_captions_default, slot: "off" })
    ];
  }
};
CaptionButton2.el = defineElement({
  tagName: "media-caption-button",
  props: toggleButtonProps
});

// src/player/ui/buttons/fullscreen-button.tsx
var FullscreenButton2 = class extends ToggleButton {
  constructor() {
    super(...arguments);
    this._keyShortcut = "toggleFullscreen";
  }
  onAttach(el) {
    this._media = useMedia();
    this._pressed = this._isPressed.bind(this);
    super.onAttach(el);
    setARIALabel(el, this._getLabel.bind(this));
    const { fullscreen } = this._media.$store;
    this.setAttributes({
      "aria-hidden": $ariaBool(this._isHidden.bind(this)),
      "data-fullscreen": fullscreen
    });
  }
  _onPress(event) {
    const remote = this._media.remote, target = this.$props.target();
    this._pressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);
  }
  _isPressed() {
    const { fullscreen } = this._media.$store;
    return fullscreen();
  }
  _isHidden() {
    const { canFullscreen: canFullscreen2 } = this._media.$store;
    return !canFullscreen2();
  }
  _getLabel() {
    const { fullscreen } = this._media.$store;
    return fullscreen() ? "Exit Fullscreen" : "Enter Fullscreen";
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: fullscreen_default, slot: "enter" }),
      $$_create_component(Icon2, { paths: fullscreen_exit_default, slot: "exit" })
    ];
  }
};
FullscreenButton2.el = defineElement({
  tagName: "media-fullscreen-button",
  props: {
    ...toggleButtonProps,
    target: "prefer-media"
  }
});

// src/player/ui/buttons/mute-button.tsx
var MuteButton2 = class extends ToggleButton {
  constructor() {
    super(...arguments);
    this._keyShortcut = "toggleMuted";
  }
  onAttach(el) {
    this._media = useMedia();
    this._pressed = this._isPressed.bind(this);
    setARIALabel(el, this._getLabel.bind(this));
    this.setAttributes({
      "data-muted": this._pressed,
      "data-volume": this._getVolumeText.bind(this)
    });
    super.onAttach(el);
  }
  _onPress(event) {
    const remote = this._media.remote;
    this._pressed() ? remote.unmute(event) : remote.mute(event);
  }
  _isPressed() {
    const { muted, volume } = this._media.$store;
    return muted() || volume() === 0;
  }
  _getLabel() {
    return this._pressed() ? "Unmute" : "Mute";
  }
  _getVolumeText() {
    const { muted, volume } = this._media.$store, $volume = volume();
    if (muted() || $volume === 0)
      return "muted";
    else if ($volume >= 0.5)
      return "high";
    else if ($volume < 0.5)
      return "low";
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: volume_high_default, slot: "volume-high" }),
      $$_create_component(Icon2, { paths: volume_low_default, slot: "volume-low" }),
      $$_create_component(Icon2, { paths: mute_default, slot: "volume-muted" })
    ];
  }
};
MuteButton2.el = defineElement({
  tagName: "media-mute-button",
  props: toggleButtonProps
});

// src/player/ui/buttons/pip-button.tsx
var PIPButton = class extends ToggleButton {
  constructor() {
    super(...arguments);
    this._keyShortcut = "togglePictureInPicture";
  }
  onAttach(el) {
    this._media = useMedia();
    this._pressed = this._isPressed.bind(this);
    super.onAttach(el);
    setARIALabel(el, this._getLabel.bind(this));
    const { pictureInPicture } = this._media.$store;
    this.setAttributes({
      "aria-hidden": $ariaBool(this._isHidden.bind(this)),
      "data-pip": pictureInPicture
    });
  }
  _onPress(event) {
    const remote = this._media.remote;
    this._pressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);
  }
  _isPressed() {
    const { pictureInPicture } = this._media.$store;
    return pictureInPicture();
  }
  _isHidden() {
    const { canPictureInPicture } = this._media.$store;
    return !canPictureInPicture();
  }
  _getLabel() {
    const { pictureInPicture } = this._media.$store;
    return pictureInPicture() ? "Exit Picture In Picture" : "Enter Picture In Picture";
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: picture_in_picture_default, slot: "enter" }),
      $$_create_component(Icon2, { paths: picture_in_picture_exit_default, slot: "exit" })
    ];
  }
};
PIPButton.el = defineElement({
  tagName: "media-pip-button",
  props: toggleButtonProps
});

// src/player/ui/buttons/play-button.tsx
var PlayButton2 = class extends ToggleButton {
  constructor() {
    super(...arguments);
    this._keyShortcut = "togglePaused";
  }
  onAttach(el) {
    this._media = useMedia();
    this._pressed = this._isPressed.bind(this);
    super.onAttach(el);
    setARIALabel(el, this._getLabel.bind(this));
    const { paused, ended } = this._media.$store;
    this.setAttributes({
      "data-paused": paused,
      "data-ended": ended
    });
  }
  _onPress(event) {
    const remote = this._media.remote;
    this._pressed() ? remote.pause(event) : remote.play(event);
  }
  _isPressed() {
    const { paused } = this._media.$store;
    return !paused();
  }
  _getLabel() {
    const { paused } = this._media.$store;
    return paused() ? "Play" : "Pause";
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: play_default, slot: "play" }),
      $$_create_component(Icon2, { paths: replay_default, slot: "replay" }),
      $$_create_component(Icon2, { paths: pause_default, slot: "pause" })
    ];
  }
};
PlayButton2.el = defineElement({
  tagName: "media-play-button",
  props: toggleButtonProps
});

// src/player/ui/buttons/seek-button.tsx
var SeekButton2 = class extends Component {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
    new FocusVisibleController(instance);
    new TooltipController(instance);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "role", "button");
    setARIALabel(el, this._getLabel.bind(this));
    const { seconds, defaultAppearance } = this.$props;
    this.setAttributes({
      seconds,
      "default-appearance": defaultAppearance,
      "aria-hidden": $ariaBool(this._isHidden.bind(this)),
      "data-media-button": true
    });
  }
  onConnect(el) {
    onPress(el, this._onPress.bind(this));
  }
  _isHidden() {
    const { canSeek } = this._media.$store;
    return !canSeek();
  }
  _getLabel() {
    const { seconds } = this.$props;
    return `Seek ${seconds() > 0 ? "forward" : "backward"} ${seconds()} seconds`;
  }
  _onPress(event) {
    const { seconds, disabled } = this.$props;
    if (disabled())
      return;
    const { currentTime } = this._media.$store, seekTo = currentTime() + seconds();
    this._media.remote.seek(seekTo, event);
  }
  render() {
    return [
      $$_create_component(Icon2, { paths: seek_backward_default, slot: "backward" }),
      $$_create_component(Icon2, { paths: seek_forward_default, slot: "forward" })
    ];
  }
};
SeekButton2.el = defineElement({
  tagName: "media-seek-button",
  props: {
    disabled: false,
    defaultAppearance: false,
    seconds: 30
  }
});

// src/player/ui/captions/captions-renderer.ts
var CaptionsTextRenderer = class {
  constructor(_renderer) {
    this._renderer = _renderer;
    this.priority = 10;
    this._track = null;
    this._disposal = createDisposalBin();
  }
  attach() {
  }
  canRender() {
    return true;
  }
  detach() {
    this._disposal.empty();
    this._renderer.reset();
    this._track = null;
  }
  changeTrack(track) {
    if (!track || this._track === track)
      return;
    this._disposal.empty();
    if (track.readyState < 2) {
      this._renderer.reset();
      this._disposal.add(
        listenEvent(track, "load", () => this._changeTrack(track), { once: true })
      );
    } else {
      this._changeTrack(track);
    }
    this._disposal.add(
      listenEvent(track, "add-cue", (event) => {
        this._renderer.addCue(event.detail);
      }),
      listenEvent(track, "remove-cue", (event) => {
        this._renderer.removeCue(event.detail);
      })
    );
    this._track = track;
  }
  _changeTrack(track) {
    this._renderer.changeTrack({
      cues: [...track.cues],
      regions: [...track.regions]
    });
  }
};

// src/player/ui/captions/captions.tsx
var Captions = class extends Component {
  onAttach() {
    this._media = useMedia();
    this.setAttributes({
      "aria-hidden": $ariaBool(this._isHidden.bind(this))
    });
  }
  onConnect(el) {
    this._renderer = new CaptionsRenderer(el);
    this._textRenderer = new CaptionsTextRenderer(this._renderer);
    effect2(this._watchViewType.bind(this));
  }
  onDisconnect() {
    if (this._textRenderer) {
      this._textRenderer.detach();
      this._media.textRenderers.remove(this._textRenderer);
    }
    this._renderer?.destroy();
  }
  _isHidden() {
    const { textTrack } = this._media.$store, track = textTrack();
    return !track || !isTrackCaptionKind(track);
  }
  _watchViewType() {
    const { viewType } = this._media.$store;
    if (viewType() === "audio") {
      return this._setupAudioView();
    } else {
      return this._setupVideoView();
    }
  }
  _setupAudioView() {
    effect2(this._onTrackChange.bind(this));
    return () => {
      this.el.textContent = "";
    };
  }
  _onTrackChange() {
    if (this._isHidden())
      return;
    const { textTrack } = this._media.$store;
    listenEvent(textTrack(), "cue-change", this._onCueChange.bind(this));
    effect2(this._onUpdateTimedNodes.bind(this));
  }
  _onCueChange() {
    this.el.textContent = "";
    const { currentTime, textTrack } = this._media.$store, time = peek(currentTime), activeCues = peek(textTrack).activeCues;
    for (const cue of activeCues) {
      const cueEl = document.createElement("div");
      cueEl.setAttribute("part", "cue");
      cueEl.innerHTML = renderVTTCueString(cue, time);
      this.el.append(cueEl);
    }
  }
  _onUpdateTimedNodes() {
    const { currentTime } = this._media.$store;
    updateTimedVTTCueNodes(this.el, currentTime());
  }
  _setupVideoView() {
    effect2(this._watchTextDirection.bind(this));
    effect2(this._watchMediaTime.bind(this));
    this._media.textRenderers.add(this._textRenderer);
    return () => {
      this.el.textContent = "";
      this._textRenderer.detach();
      this._media.textRenderers.remove(this._textRenderer);
    };
  }
  _watchTextDirection() {
    this._renderer.dir = this.$props.textDir();
  }
  _watchMediaTime() {
    if (this._isHidden())
      return;
    const { currentTime } = this._media.$store;
    this._renderer.currentTime = currentTime();
  }
};
Captions.el = defineElement({
  tagName: "media-captions",
  props: { textDir: "ltr" }
});

// src/player/ui/gesture.tsx
var Gesture = class extends Component {
  constructor() {
    super(...arguments);
    this._outlet = null;
    this._presses = 0;
    this._pressTimerId = -1;
  }
  onAttach() {
    const { event, action } = this.$props;
    this.setAttributes({
      event,
      action
    });
  }
  onConnect() {
    this._media = useMedia();
    scopedRaf(() => {
      this._outlet = this._media.player.querySelector("media-outlet");
      effect2(this._attachListener.bind(this));
    });
  }
  _attachListener() {
    let eventType = this.$props.event();
    if (!this._outlet || !eventType)
      return;
    if (/^dbl/.test(eventType)) {
      eventType = eventType.split(/^dbl/)[1];
    }
    listenEvent(this._outlet, eventType, this._acceptEvent.bind(this));
  }
  _acceptEvent(event) {
    if (!this._inBounds(event) || isPointerEvent(event) && (event.button !== 0 || this._media.activeMenu)) {
      return;
    }
    event.MEDIA_GESTURE = true;
    event.preventDefault();
    const isDblEvent = peek(this.$props.event)?.startsWith("dbl");
    if (!isDblEvent) {
      if (this._presses === 0) {
        setTimeout(() => {
          if (this._presses === 1)
            this._handleEvent(event);
        }, 250);
      }
    } else if (this._presses === 1) {
      queueMicrotask(() => this._handleEvent(event));
      clearTimeout(this._pressTimerId);
      this._presses = 0;
      return;
    }
    if (this._presses === 0) {
      this._pressTimerId = window.setTimeout(() => {
        this._presses = 0;
      }, 275);
    }
    this._presses++;
  }
  _handleEvent(event) {
    this.el.setAttribute("data-triggered", "");
    requestAnimationFrame(() => {
      if (this._isTopLayer()) {
        this._performAction(peek(this.$props.action), event);
      }
      requestAnimationFrame(() => {
        this.el.removeAttribute("data-triggered");
      });
    });
  }
  /** Validate event occurred in gesture bounds. */
  _inBounds(event) {
    if (!this.el)
      return false;
    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
      const touch = isTouchEvent(event) ? event.touches[0] : void 0;
      const clientX = touch?.clientX ?? event.clientX;
      const clientY = touch?.clientY ?? event.clientY;
      const rect = this.el.getBoundingClientRect();
      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
      return event.type.includes("leave") ? !inBounds : inBounds;
    }
    return true;
  }
  /** Validate gesture has the highest z-index in this triggered group. */
  _isTopLayer() {
    const gestures = this._media.player.querySelectorAll(
      "media-gesture[data-triggered]"
    );
    return Array.from(gestures).sort(
      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
    )[0]?.component === this;
  }
  _performAction(action, trigger) {
    if (!action)
      return;
    const [method2, value] = action.replace(/:([a-z])/, "-$1").split(":");
    if (action.includes(":fullscreen")) {
      this._media.remote.toggleFullscreen("prefer-media", trigger);
    } else if (action.includes("seek:")) {
      this._media.remote.seek(peek(this._media.$store.currentTime) + (+value || 0), trigger);
    } else {
      this._media.remote[kebabToCamelCase(method2)](trigger);
    }
  }
};
Gesture.el = defineElement({
  tagName: "media-gesture",
  props: {
    event: void 0,
    action: void 0
  }
});

// src/player/ui/live-indicator.tsx
var $$_templ9 = /* @__PURE__ */ $$_create_template(`<div part="container"><div part="text">LIVE</div></div>`);
var LiveIndicator = class extends Component {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
    new FocusVisibleController(instance);
  }
  onAttach(el) {
    const { live, liveEdge } = this._media.$store;
    setARIALabel(el, this._getLabel.bind(this));
    this.setAttributes({
      tabindex: this._getTabIndex.bind(this),
      role: this._getRole.bind(this),
      "data-live": live,
      "data-live-edge": liveEdge,
      "data-media-button": true
    });
  }
  onConnect(el) {
    onPress(el, this._onPress.bind(this));
  }
  _getLabel() {
    const { live } = this._media.$store;
    return live() ? "Go live" : null;
  }
  _getTabIndex() {
    const { live } = this._media.$store;
    return live() ? 0 : null;
  }
  _getRole() {
    const { live } = this._media.$store;
    return live() ? "button" : null;
  }
  _onPress(event) {
    const { liveEdge } = this._media.$store;
    if (liveEdge())
      return;
    this._media.remote.seekToLiveEdge(event);
  }
  render() {
    return $$_clone($$_templ9);
  }
};
LiveIndicator.el = defineElement({
  tagName: "media-live-indicator"
});

// src/player/ui/menu/menu-context.ts
var menuContext = createContext();

// src/player/ui/menu/menu-button.tsx
var MenuButton = class extends Component {
  constructor(instance) {
    super(instance);
    this._menu = useContext(menuContext);
    new FocusVisibleController(instance);
    new TooltipController(instance);
  }
  onAttach(el) {
    this._menu._attachMenuButton(el);
    effect2(this._watchDisabled.bind(this));
  }
  onConnect(el) {
    const hint = Array.from(el.querySelectorAll('[slot="hint"]')).pop();
    if (hint) {
      effect2(() => {
        const text = this._menu._hint();
        if (text)
          hint.textContent = text;
      });
    }
  }
  _watchDisabled() {
    this._menu._disableMenuButton(this.$props.disabled());
  }
};
MenuButton.el = defineElement({
  tagName: "media-menu-button",
  props: { disabled: false }
});

// src/player/ui/menu/render.tsx
var $$_templ10 = /* @__PURE__ */ $$_create_template(`<span slot="label"></span>`);
var $$_templ_26 = /* @__PURE__ */ $$_create_template(`<div slot="hint"></div>`);
function renderMenuButtonContent({ label, iconPaths }) {
  return [
    $$_create_component(Icon2, { slot: "close-icon", paths: arrow_left_default }),
    $$_create_component(Icon2, { slot: "icon", paths: iconPaths }),
    (() => {
      const $$_root = $$_clone($$_templ10);
      $$_insert_lite($$_root, label);
      return $$_root;
    })(),
    $$_clone($$_templ_26),
    $$_create_component(Icon2, { slot: "open-icon", paths: chevron_right_default })
  ];
}

// src/player/ui/menu/audio/menu-button.tsx
var AudioMenuButton = class extends MenuButton {
  render() {
    const { label } = this.$props;
    return renderMenuButtonContent({
      label,
      iconPaths: music_default
    });
  }
};
AudioMenuButton.el = defineElement({
  tagName: "media-audio-menu-button",
  props: { disabled: false, label: "Audio" }
});

// src/foundation/observers/class-manager.ts
var ClassManager = class {
  constructor(el) {
    this._map = /* @__PURE__ */ new Map();
    this._classes = signal([]);
    this._requestUpdate = animationFrameThrottle(this._update.bind(this));
    this._root = el.firstChild;
    this._observer = new MutationObserver(this._onMutation.bind(this));
    this._observer.observe(this._root, { subtree: true, childList: true });
    effect2(this._watch.bind(this));
    onDispose(this._destroy.bind(this));
  }
  _onMutation(records) {
    const selector = Array.from(this._map.keys()).join(",");
    for (const record of records) {
      for (const node of record.addedNodes) {
        if (isDOMElement(node) && node.matches(selector))
          this._requestUpdate();
      }
    }
  }
  _observe(selector, $class) {
    this._map.set(selector, $class);
    this._classes.set((c) => [...c, $class]);
    return this;
  }
  _update() {
    for (const [selector, classes] of this._map) {
      const _class = peek(classes);
      for (const el of this._root.querySelectorAll(selector)) {
        setAttribute(el, "class", _class);
      }
    }
  }
  _watch() {
    for (const c of this._classes())
      c();
    this._requestUpdate();
  }
  _destroy() {
    this._classes.set([]);
    this._map.clear();
    this._observer.disconnect();
  }
};

// src/player/ui/menu/menu-items.tsx
var MenuItems = class extends Component {
  constructor(instance) {
    super(instance);
    this._menu = useContext(menuContext);
    new FocusVisibleController(instance);
  }
  onAttach(el) {
    this._menu._attachMenuItems(el);
  }
};
MenuItems.el = defineElement({
  tagName: "media-menu-items"
});

// src/player/ui/menu/radio/context.ts
var radioGroupContext = createContext();

// src/player/ui/menu/radio/radio.tsx
var $$_templ11 = /* @__PURE__ */ $$_create_template(`<div part="check"></div>`);
var Radio = class extends Component {
  constructor(instance) {
    super(instance);
    this._checked = signal(false);
    this._controller = {
      _value: this.$props.value,
      _check: this._check.bind(this),
      _onCheck: null
    };
    new FocusVisibleController(instance);
  }
  get checked() {
    return this._checked();
  }
  onAttach() {
    effect2(this._watchValue.bind(this));
    this._addToGroup();
    const isMenuItem = hasProvidedContext(menuContext);
    this.setAttributes({
      value: this.$props.value,
      role: isMenuItem ? "menuitemradio" : "radio",
      tabindex: isMenuItem ? -1 : 0,
      "aria-checked": $ariaBool(this._checked)
    });
  }
  onConnect(el) {
    this._addToGroup();
    onPress(el, this._onPress.bind(this));
  }
  onDisconnect() {
    const group = useContext(radioGroupContext);
    group.remove(this._controller);
  }
  _addToGroup() {
    const group = useContext(radioGroupContext);
    group.add(this._controller);
  }
  _watchValue() {
    const { value } = this.$props, newValue = value();
    if (peek(this._checked)) {
      this._controller._onCheck?.(newValue);
    }
  }
  _onPress(event) {
    if (peek(this._checked))
      return;
    this._checked.set(true);
    this.dispatch("change", { trigger: event });
    this._controller._onCheck?.(peek(this.$props.value), event);
  }
  _check(value, trigger) {
    if (peek(this._checked) === value)
      return;
    this._checked.set(value);
    this.dispatch("change", { trigger });
  }
  render() {
    return $$_clone($$_templ11);
  }
};
Radio.el = defineElement({
  tagName: "media-radio",
  props: { value: "" }
});
__decorateClass([
  prop
], Radio.prototype, "checked", 1);

// src/player/ui/menu/radio/radio-group.tsx
var RadioGroup = class extends Component {
  constructor(instance) {
    super(instance);
    this._group = /* @__PURE__ */ new Set();
    this._value = signal("");
    this._onChangeBind = this._onChange.bind(this);
    provideContext(radioGroupContext, {
      add: this._addRadio.bind(this),
      remove: this._removeRadio.bind(this)
    });
  }
  get values() {
    return Array.from(this._group).map((radio) => radio._value());
  }
  get value() {
    return this._value();
  }
  set value(value) {
    this._onChange(value);
  }
  onAttach(el) {
    const isMenuItem = hasProvidedContext(menuContext);
    if (!isMenuItem)
      setAttributeIfEmpty(el, "role", "radiogroup");
    this._watchValueProp();
    this.setAttributes({ value: this._value });
  }
  onConnect() {
    effect2(this._watchValueProp.bind(this));
  }
  onDestroy() {
    this._group.clear();
  }
  _addRadio(radio) {
    if (this._group.has(radio))
      return;
    this._group.add(radio);
    radio._onCheck = this._onChangeBind;
    radio._check(radio._value() === this._value());
  }
  _removeRadio(radio) {
    radio._onCheck = null;
    this._group.delete(radio);
  }
  _watchValueProp() {
    this._onChange(this.$props.value());
  }
  _onChange(newValue, trigger) {
    const currentValue = peek(this._value);
    if (!newValue || newValue === currentValue)
      return;
    const currentRadio = this._findRadio(currentValue), newRadio = this._findRadio(newValue);
    currentRadio?._check(false, trigger);
    newRadio?._check(true, trigger);
    this._value.set(newValue);
    this.dispatch("change", { trigger });
  }
  _findRadio(newValue) {
    for (const radio of this._group) {
      if (newValue === peek(radio._value))
        return radio;
    }
    return null;
  }
};
RadioGroup.el = defineElement({
  tagName: "media-radio-group",
  props: { value: "" }
});
__decorateClass([
  prop
], RadioGroup.prototype, "values", 1);
__decorateClass([
  prop
], RadioGroup.prototype, "value", 1);

// src/player/ui/menu/radio/render.tsx
var $$_templ12 = /* @__PURE__ */ $$_create_template(`<media-radio-group mk-d></media-radio-group>`);
var $$_templ_27 = /* @__PURE__ */ $$_create_template(`<media-radio mk-d></media-radio>`);
function renderRadioGroup(props) {
  const { value, onChange, radioGroupClass } = props;
  return (() => {
    const $$_root = $$_clone($$_templ12);
    $$_effect(() => $$_attr($$_root, "class", radioGroupClass()));
    $$_listen($$_root, "change", onChange);
    $$_scoped(() => {
      $$_insert_lite($$_root, () => renderOptions(props));
    }, $$_setup_custom_element($$_root, { value }));
    return $$_root;
  })();
}
function renderOptions(props) {
  const { options } = props;
  return options().map((option) => {
    return (() => {
      const $$_root = $$_clone($$_templ_27);
      $$_attr($$_root, "part", props.part);
      $$_scoped(() => {
        $$_insert_lite($$_root, option.content);
      }, $$_setup_custom_element($$_root, { value: option.value }));
      return $$_root;
    })();
  });
}

// src/player/ui/menu/audio/menu-items.tsx
var $$_templ13 = /* @__PURE__ */ $$_create_template(`<span part="label"></span>`);
var AudioMenuItems = class extends MenuItems {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
  }
  onConnect(el) {
    effect2(this._watchControllerDisabled.bind(this));
    effect2(this._watchHintText.bind(this));
    const { radioClass, radioCheckClass } = this.$props;
    new ClassManager(el)._observe("media-radio", radioClass)._observe('[part="check"]', radioCheckClass);
  }
  _watchHintText() {
    const { emptyLabel } = this.$props, { audioTrack } = this._media.$store, track = audioTrack();
    this._menu._hint.set(track?.label ?? emptyLabel());
  }
  _watchControllerDisabled() {
    this._menu._disable(this._isDisabled());
  }
  _isDisabled() {
    const { audioTracks } = this._media.$store;
    return audioTracks().length === 0;
  }
  _onChange(event) {
    if (this._isDisabled())
      return;
    const radioGroup = event.target;
    const value = radioGroup.value, index = this._media.audioTracks.toArray().findIndex((track) => track.label.toLowerCase() === value);
    if (index >= 0)
      this._media.remote.changeAudioTrack(index, event);
  }
  _getValue() {
    const { audioTrack } = this._media.$store;
    const track = audioTrack();
    return track ? track.label.toLowerCase() : "";
  }
  _getOptions() {
    const { audioTracks } = this._media.$store;
    return audioTracks().map((track) => ({
      value: track.label.toLowerCase(),
      content: () => (() => {
        const $$_root = $$_clone($$_templ13);
        $$_insert_lite($$_root, track.label);
        return $$_root;
      })()
    }));
  }
  render() {
    const { radioGroupClass } = this.$props;
    return renderRadioGroup({
      value: this._getValue.bind(this),
      options: this._getOptions.bind(this),
      radioGroupClass,
      onChange: this._onChange.bind(this)
    });
  }
};
AudioMenuItems.el = defineElement({
  tagName: "media-audio-menu-items",
  props: {
    emptyLabel: "Default",
    radioClass: null,
    radioGroupClass: null,
    radioCheckClass: null
  }
});
AudioMenuItems.register = [RadioGroup, Radio];

// src/player/ui/menu/captions/menu-button.tsx
var CaptionsMenuButton = class extends MenuButton {
  render() {
    const { label } = this.$props;
    return renderMenuButtonContent({
      label,
      iconPaths: closed_captions_default
    });
  }
};
CaptionsMenuButton.el = defineElement({
  tagName: "media-captions-menu-button",
  props: { disabled: false, label: "Captions" }
});

// src/player/ui/menu/captions/menu-items.tsx
var $$_templ14 = /* @__PURE__ */ $$_create_template(`<span part="label"></span>`);
var $$_templ_28 = $$_templ14;
var CaptionsMenuItems = class extends MenuItems {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
  }
  onConnect(el) {
    effect2(this._watchControllerDisabled.bind(this));
    effect2(this._watchHintText.bind(this));
    const { radioClass, radioCheckClass } = this.$props;
    new ClassManager(el)._observe("media-radio", radioClass)._observe('[part="check"]', radioCheckClass);
  }
  _watchHintText() {
    const { offLabel } = this.$props, { textTrack } = this._media.$store, track = textTrack();
    this._menu._hint.set(
      track && isTrackCaptionKind(track) && track.mode === "showing" ? track.label : offLabel()
    );
  }
  _watchControllerDisabled() {
    this._menu._disable(this._isDisabled());
  }
  _isDisabled() {
    const { textTracks } = this._media.$store;
    return textTracks().filter(isTrackCaptionKind).length === 0;
  }
  _onChange(event) {
    if (this._isDisabled())
      return;
    const radioGroup = event.target;
    const value = radioGroup.value;
    if (value === "off") {
      const track = this._media.textTracks.selected;
      if (track) {
        const index2 = this._media.textTracks.toArray().indexOf(track);
        this._media.remote.changeTextTrackMode(index2, "disabled", event);
      }
      return;
    }
    const index = this._media.textTracks.toArray().findIndex((track) => track.label.toLowerCase() === value);
    if (index >= 0)
      this._media.remote.changeTextTrackMode(index, "showing", event);
  }
  _getValue() {
    const { textTrack, textTracks } = this._media.$store, track = textTrack();
    return track && isTrackCaptionKind(track) && track.mode === "showing" ? track.label.toLowerCase() : "off";
  }
  _getOptions() {
    const { offLabel } = this.$props, { textTracks } = this._media.$store;
    return [
      { value: "off", content: () => (() => {
        const $$_root = $$_clone($$_templ14);
        $$_insert_lite($$_root, offLabel);
        return $$_root;
      })() },
      ...textTracks().filter(isTrackCaptionKind).map((track) => ({
        value: track.label.toLowerCase(),
        content: () => (() => {
          const $$_root = $$_clone($$_templ_28);
          $$_insert_lite($$_root, track.label);
          return $$_root;
        })()
      }))
    ];
  }
  render() {
    const { radioGroupClass } = this.$props;
    return renderRadioGroup({
      value: this._getValue.bind(this),
      options: this._getOptions.bind(this),
      radioGroupClass,
      onChange: this._onChange.bind(this)
    });
  }
};
CaptionsMenuItems.el = defineElement({
  tagName: "media-captions-menu-items",
  props: {
    offLabel: "Off",
    radioClass: null,
    radioGroupClass: null,
    radioCheckClass: null
  }
});
CaptionsMenuItems.register = [RadioGroup, Radio];

// src/utils/time.ts
function padNumberWithZeroes(num, expectedLength) {
  const str = String(num);
  const actualLength = str.length;
  const shouldPad = actualLength < expectedLength;
  if (shouldPad) {
    const padLength = expectedLength - actualLength;
    const padding = `0`.repeat(padLength);
    return `${padding}${num}`;
  }
  return str;
}
function parseTime(duration) {
  const hours = Math.trunc(duration / 3600);
  const minutes = Math.trunc(duration % 3600 / 60);
  const seconds = Math.trunc(duration % 60);
  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));
  return {
    hours,
    minutes,
    seconds,
    fraction
  };
}
function formatTime(duration, shouldPadHours = false, shouldPadMinutes = false, shouldAlwaysShowHours = false) {
  const { hours, minutes, seconds } = parseTime(duration);
  const paddedHours = shouldPadHours ? padNumberWithZeroes(hours, 2) : hours;
  const paddedMinutes = shouldPadMinutes ? padNumberWithZeroes(minutes, 2) : minutes;
  const paddedSeconds = padNumberWithZeroes(seconds, 2);
  if (hours > 0 || shouldAlwaysShowHours) {
    return `${paddedHours}:${paddedMinutes}:${paddedSeconds}`;
  }
  return `${paddedMinutes}:${paddedSeconds}`;
}
function formatSpokenTime(duration) {
  const spokenParts = [];
  const { hours, minutes, seconds } = parseTime(duration);
  if (hours > 0) {
    spokenParts.push(`${hours} hour`);
  }
  if (minutes > 0) {
    spokenParts.push(`${minutes} min`);
  }
  if (seconds > 0 || spokenParts.length === 0) {
    spokenParts.push(`${seconds} sec`);
  }
  return spokenParts.join(" ");
}

// src/player/ui/thumbnail.tsx
var $$_templ15 = /* @__PURE__ */ $$_create_template(`<img part="img" loading="eager" decoding="async" aria-hidden="true" />`);
var Thumbnail = class extends Component {
  constructor(instance) {
    super(instance);
    this._img = null;
    this._coords = null;
    this._styleResets = [];
    this._src = signal("");
    this._loaded = signal(false);
    this._activeCue = signal(null);
    this._requestResize = animationFrameThrottle(this._resize.bind(this));
    this._media = useMedia();
  }
  onAttach() {
    this.setAttributes({
      "data-loading": this._isLoading.bind(this),
      "aria-hidden": $ariaBool(this._isHidden.bind(this))
    });
  }
  onConnect() {
    effect2(this._onLoadStart.bind(this));
    effect2(this._onFindActiveCue.bind(this));
    effect2(this._onResolveThumbnail.bind(this));
  }
  _onLoadStart() {
    this._src();
    this._media.$store.thumbnails();
    this._loaded.set(false);
  }
  _onLoaded() {
    this._loaded.set(true);
    this._requestResize();
  }
  _isLoading() {
    return !this._isHidden() && !this._loaded();
  }
  _isHidden() {
    const { duration, thumbnailCues } = this._media.$store;
    return !Number.isFinite(duration()) || thumbnailCues().length === 0;
  }
  _onFindActiveCue() {
    const { time } = this.$props, { duration, thumbnailCues } = this._media.$store, _cues = thumbnailCues(), _time = time();
    if (!_cues || !Number.isFinite(duration())) {
      this._activeCue.set(null);
      return;
    }
    this._activeCue.set(findActiveCue(_time, _cues));
  }
  _onImgRef(el) {
    this._img = el;
  }
  _onResolveThumbnail() {
    const activeCue = this._activeCue(), thumbnails = peek(this._media.$store.thumbnails);
    if (!thumbnails || !activeCue) {
      this._src.set("");
      this._resetStyles();
      return;
    }
    const [_src, _coords = ""] = (activeCue.text || "").split("#");
    this._coords = this._resolveThumbnailCoords(_coords);
    if (!this._coords) {
      this._resetStyles();
      return;
    }
    this._src.set(this._resolveThumbnailSrc(thumbnails, _src));
    this._requestResize();
  }
  _resolveThumbnailSrc(baseURL, src) {
    return !/https?:/.test(src) ? `${baseURL.split("/").slice(0, -1).join("/")}${src.replace(/^\/?/, "/")}`.replace(
      /^\/\//,
      "/"
    ) : src;
  }
  _resolveThumbnailCoords(coords) {
    const [props, values] = coords.split("="), resolvedCoords = {}, coordValues = values?.split(",");
    if (!props || !values)
      return null;
    for (let i = 0; i < props.length; i++)
      resolvedCoords[props[i]] = +coordValues[i];
    return resolvedCoords;
  }
  _resize() {
    if (!this._img || !this._coords || !this.el)
      return;
    const { w, h: h2, x, y } = this._coords, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(this.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h2), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h2), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
    this._style(this.el, "--thumbnail-width", `${w * scale}px`);
    this._style(this.el, "--thumbnail-height", `${h2 * scale}px`);
    this._style(this._img, "width", `${this._img.naturalWidth * scale}px`);
    this._style(this._img, "height", `${this._img.naturalHeight * scale}px`);
    this._style(this._img, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
  }
  _style(el, name, value) {
    el.style.setProperty(name, value);
    this._styleResets.push(() => el.style.removeProperty(name));
  }
  _resetStyles() {
    for (const reset of this._styleResets)
      reset();
    this._styleResets = [];
  }
  render() {
    const { crossorigin } = this._media.$store;
    return (() => {
      const $$_root = $$_clone($$_templ15);
      $$_effect(() => $$_attr($$_root, "src", this._src()));
      $$_effect(() => $$_attr($$_root, "crossorigin", crossorigin()));
      $$_listen($$_root, "load", this._onLoaded.bind(this));
      $$_ref($$_root, this._onImgRef.bind(this));
      return $$_root;
    })();
  }
};
Thumbnail.el = defineElement({
  tagName: "media-thumbnail",
  props: { time: 0 }
});

// src/player/ui/menu/chapters-menu-items.tsx
var $$_templ16 = /* @__PURE__ */ $$_create_template(`<media-thumbnail part="thumbnail" mk-d></media-thumbnail>`);
var $$_templ_29 = /* @__PURE__ */ $$_create_template(`<div part="content"><div part="title"></div><div part="start-time"></div><div part="duration"></div></div>`);
var ChaptersMenuItems = class extends MenuItems {
  constructor(instance) {
    super(instance);
    this._index = signal(0);
    this._track = signal(null);
    this._media = useMedia();
  }
  onAttach(el) {
    super.onAttach(el);
    this._menu._attachObserver({
      _onOpen: this._onOpen.bind(this)
    });
    this.setAttributes({
      "data-thumbnails": this._hasThumbnails.bind(this)
    });
  }
  _onOpen(trigger) {
    if (isKeyboardEvent(trigger))
      return;
    requestAnimationFrame(() => {
      const checked = this.el.querySelector('media-radio[aria-checked="true"]');
      checked.scrollIntoView({ block: "center" });
    });
  }
  onConnect(el) {
    effect2(this._watchCurrentTime.bind(this));
    effect2(this._watchControllerDisabled.bind(this));
    this._onTrackModeChange();
    listenEvent(this._media.textTracks, "mode-change", this._onTrackModeChange.bind(this));
    const {
      chapterClass,
      thumbnailClass,
      contentClass,
      titleClass,
      startTimeClass,
      durationClass
    } = this.$props;
    new ClassManager(el)._observe('[part="chapter"]', chapterClass)._observe('[part="thumbnail"]', thumbnailClass)._observe('[part="content"]', contentClass)._observe('[part="title"]', titleClass)._observe('[part="start-time"]', startTimeClass)._observe('[part="duration"]', durationClass);
  }
  _hasThumbnails() {
    const { thumbnailCues } = this._media.$store;
    return thumbnailCues().length > 0;
  }
  _watchCurrentTime() {
    if (!this._menu._expanded())
      return;
    const track = this._track(), { currentTime } = this._media.$store;
    if (!track) {
      this._index.set(-1);
      return;
    }
    const time = currentTime(), activeCueIndex = track.cues.findIndex((cue) => isCueActive(cue, time));
    this._index.set(activeCueIndex);
    if (activeCueIndex >= 0) {
      const cue = track.cues[activeCueIndex], radio = this.el.querySelector(`shadow-root media-radio[aria-checked='true']`), playedPercent = (time - cue.startTime) / (cue.endTime - cue.startTime) * 100;
      radio && setStyle(radio, "--played-percent", round(playedPercent, 3) + "%");
    }
  }
  _watchControllerDisabled() {
    this._menu._disable(this._isDisabled());
  }
  _isDisabled() {
    const track = this._track();
    return !track || !track.cues.length;
  }
  _onChange(event) {
    if (this._isDisabled() || !event.trigger)
      return;
    const index = +event.target.value, cues = this._track()?.cues;
    if (isNumber(index) && cues?.[index]) {
      this._index.set(index);
      this._media.remote.seek(cues[index].startTime, event);
    }
  }
  _onTrackModeChange() {
    onTrackChapterChange(this._media.textTracks, peek(this._track), this._track.set);
  }
  _getValue() {
    return this._index() + "";
  }
  _getOptions() {
    const track = this._track();
    if (!track)
      return [];
    return track.cues.map((cue, i) => ({
      value: i + "",
      content: () => [
        this._hasThumbnails() && (() => {
          const $$_root = $$_clone($$_templ16);
          $$_setup_custom_element($$_root, { time: cue.startTime });
          return $$_root;
        })(),
        (() => {
          const $$_root = $$_clone($$_templ_29), $$_el = $$_root.firstChild, $$_el_2 = $$_el.nextSibling, $$_el_3 = $$_el_2.nextSibling;
          $$_insert_lite($$_el, cue.text);
          $$_insert_lite($$_el_2, () => formatTime(cue.startTime, false, cue.startTime >= 3600));
          $$_insert_lite($$_el_3, () => formatSpokenTime(cue.endTime - cue.startTime));
          return $$_root;
        })()
      ]
    }));
  }
  render() {
    const { containerClass } = this.$props;
    return renderRadioGroup({
      part: "chapter",
      value: this._getValue.bind(this),
      options: this._getOptions.bind(this),
      radioGroupClass: containerClass,
      onChange: this._onChange.bind(this)
    });
  }
};
ChaptersMenuItems.el = defineElement({
  tagName: "media-chapters-menu-items",
  props: {
    containerClass: null,
    chapterClass: null,
    thumbnailClass: null,
    contentClass: null,
    titleClass: null,
    startTimeClass: null,
    durationClass: null
  }
});
ChaptersMenuItems.register = [Thumbnail, RadioGroup, Radio];

// src/player/ui/menu/menu-focus-controller.ts
var FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
  "a[href]",
  "[tabindex]",
  "input",
  "select",
  "button"
].map((selector) => `${selector}:not([aria-hidden])`).join(",");
var VALID_KEYS = /* @__PURE__ */ new Set([
  "Escape",
  "Tab",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "PageUp",
  "End",
  "PageDown",
  "Enter",
  " "
]);
var MenuFocusController = class {
  constructor(_closeMenu) {
    this._closeMenu = _closeMenu;
    this._index = 0;
    this._el = null;
    this._elements = [];
  }
  get _items() {
    return this._elements;
  }
  _attach(el) {
    listenEvent(el, "focus", this._onFocus.bind(this));
    this._el = el;
  }
  _listen() {
    if (!this._el)
      return;
    this._update();
    listenEvent(this._el, "keyup", this._onKeyUp.bind(this));
    listenEvent(this._el, "keydown", this._onKeyDown.bind(this));
    onDispose(() => {
      this._index = 0;
      this._elements = [];
    });
  }
  _focusAt(index) {
    this._index = index;
    this._elements[index]?.focus();
    this._elements[index]?.scrollIntoView({
      block: "center"
    });
  }
  _onFocus() {
    const index = this._elements.findIndex((el) => el.getAttribute("aria-checked") === "true");
    this._focusAt(index >= 0 ? index : 0);
  }
  _update() {
    this._index = 0;
    this._elements = this._getFocusableElements();
  }
  _onKeyUp(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
  }
  _onKeyDown(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
    switch (event.key) {
      case "Escape":
        this._closeMenu(event);
        break;
      case "Tab":
        this._focusAt(this._nextIndex(event.shiftKey ? -1 : 1));
        break;
      case "ArrowUp":
        this._focusAt(this._nextIndex(-1));
        break;
      case "ArrowDown":
        this._focusAt(this._nextIndex(1));
        break;
      case "Home":
      case "PageUp":
        this._focusAt(0);
        break;
      case "End":
      case "PageDown":
        this._focusAt(this._elements.length - 1);
        break;
    }
  }
  _nextIndex(delta) {
    let index = this._index;
    do {
      index = (index + delta + this._elements.length) % this._elements.length;
    } while (this._elements[index].offsetParent === null);
    return index;
  }
  _getFocusableElements() {
    if (!this._el)
      return [];
    const focusableElements = this._el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
    const is = (node) => node.hasAttribute("data-media-menu-items");
    for (const el of focusableElements) {
      if (el instanceof HTMLElement && el.offsetParent !== null && // does not have display: none
      isElementParent(this._el, el, is)) {
        elements.push(el);
      }
    }
    return elements;
  }
};

// src/player/ui/menu/menu.tsx
var idCount = 0;
var Menu = class extends Component {
  constructor(instance) {
    super(instance);
    this._expanded = signal(false);
    this._disabled = signal(false);
    this._buttonDisabled = signal(false);
    this._submenus = /* @__PURE__ */ new Set();
    this._menuButton = null;
    this._menuItems = null;
    this._menuObserver = null;
    this._disableBind = this._disable.bind(this);
    this._removeSubmenuBind = this._removeSubmenu.bind(this);
    this._onSubmenuOpenBind = this._onSubmenuOpen.bind(this);
    this._onSubmenuCloseBind = this._onSubmenuClose.bind(this);
    this._media = useMedia();
    const currentIdCount = ++idCount;
    this._menuId = `media-menu-${currentIdCount}`;
    this._menuButtonId = `media-menu-button-${currentIdCount}`;
    if (hasProvidedContext(menuContext)) {
      this._parentMenu = useContext(menuContext);
    }
    this._focus = new MenuFocusController(this.close.bind(this));
    provideContext(menuContext, {
      _expanded: this._expanded,
      _hint: signal(""),
      _disable: this._disable.bind(this),
      _attachMenuButton: this._attachMenuButton.bind(this),
      _attachMenuItems: this._attachMenuItems.bind(this),
      _attachObserver: this._attachObserver.bind(this),
      _disableMenuButton: this._disableMenuButton.bind(this),
      _addSubmenu: this._addSubmenu.bind(this)
    });
  }
  onAttach(el) {
    const { position } = this.$props;
    this.setAttributes({
      position,
      "data-open": this._expanded,
      "data-submenu": !!this._parentMenu,
      "data-disabled": this._isDisabled.bind(this),
      "data-media-menu": true
    });
  }
  onConnect(el) {
    if (!this._parentMenu) {
      effect2(this._watchBreakpoint.bind(this));
    }
    effect2(this._watchExpanded.bind(this));
    this._parentMenu?._addSubmenu(el);
    requestAnimationFrame(() => this._onResize());
  }
  onDestroy() {
    this._removePopupMenu();
    this._menuButton = null;
    this._menuItems = null;
    this._menuObserver = null;
  }
  _removePopupMenu() {
    if (!this._menuItems || this.el?.contains(this._menuItems))
      return;
    const menu = this._menuItems?.parentElement;
    this.el.append(this._menuItems);
    if (menu?.localName === "media-menu") {
      menu.destroy();
      menu.remove();
    }
  }
  _watchBreakpoint() {
    if (!this.el)
      return;
    const { breakpointX, breakpointY, viewType, orientation, fullscreen } = this._media.$store, popup = viewType() === "audio" ? breakpointX() === "sm" : breakpointY() === "sm";
    if (!this._menuItems || this._parentMenu)
      return;
    setAttribute(this.el, "data-popup", popup);
    setAttribute(this.el, "data-popup-wide", popup && orientation() === "landscape");
    if (popup && !fullscreen()) {
      if (this.el.contains?.(this._menuItems)) {
        const menu = this.el.cloneNode();
        menu.appendChild(this._menuItems);
        requestAnimationFrame(() => {
          if (!this.el)
            return;
          const mediaRing = "--media-focus-ring", mediaRingValue = getComputedStyle(this.el).getPropertyValue(mediaRing);
          if (mediaRingValue)
            setStyle(menu, mediaRing, mediaRingValue);
        });
        scoped(() => {
          document.body.append(menu);
        }, this._media.scope);
      }
    }
    this._onResize();
    return () => this._removePopupMenu();
  }
  _watchExpanded() {
    const expanded = this._isExpanded();
    this._onResize();
    this._updateMenuItemsHidden(expanded);
    if (!expanded)
      return;
    this._focus._listen();
    const closeTarget = this._getCloseTarget();
    if (closeTarget) {
      onPress(closeTarget, this._onCloseTargetPress.bind(this));
    }
    this.listen("pointerup", this._onPointerUp.bind(this));
    listenEvent(window, "pointerup", this._onWindowPointerUp.bind(this));
  }
  _attachMenuButton(el) {
    const isMenuItem = !!this._parentMenu, isExpanded = this._isExpanded.bind(this), isARIAExpanded = $ariaBool(isExpanded), isARIADisabled = $ariaBool(this._isDisabled.bind(this));
    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
    setAttribute(el, "id", this._menuButtonId);
    setAttribute(el, "aria-controls", this._menuId);
    setAttribute(el, "aria-haspopup", "true");
    effect2(() => {
      setAttribute(el, "aria-disabled", isARIADisabled());
      setAttribute(el, "aria-expanded", isARIAExpanded());
      if (!isMenuItem)
        setAttribute(el, "aria-pressed", isARIAExpanded());
      setAttribute(el, "data-pressed", isExpanded());
    });
    setAttribute(el, "data-media-button", !isMenuItem);
    setAttribute(el, "data-media-menu-button", "");
    onPress(el, this._onMenuButtonPress.bind(this));
    this._menuButton = el;
  }
  _attachMenuItems(el) {
    setAttributeIfEmpty(el, "role", "menu");
    setAttributeIfEmpty(el, "tabindex", "-1");
    setAttribute(el, "id", this._menuId);
    setAttribute(el, "aria-describedby", this._menuButtonId);
    setAttribute(el, "data-media-menu-items", "");
    this._menuItems = el;
    this._focus._attach(el);
    this._watchBreakpoint();
    this._updateMenuItemsHidden(peek(this._expanded));
  }
  _attachObserver(observer) {
    this._menuObserver = observer;
  }
  _updateMenuItemsHidden(expanded) {
    if (this._menuItems)
      setAttribute(this._menuItems, "aria-hidden", ariaBool(!expanded));
  }
  _disableMenuButton(disabled) {
    this._buttonDisabled.set(disabled);
  }
  _onMenuButtonPress(event) {
    if (this._parentMenu)
      event.stopPropagation();
    if (this._isDisabled())
      return;
    this._expanded.set((expanded) => !expanded);
    this._changeIdleTracking();
    tick();
    if (isKeyboardEvent(event)) {
      this._menuItems?.focus();
    }
    this._onChange(event);
  }
  _onChange(trigger) {
    const expanded = peek(this._expanded);
    this.dispatch(expanded ? "open" : "close", { trigger });
    if (!this._parentMenu) {
      if (expanded) {
        this._media.activeMenu?.close(trigger);
        this._media.activeMenu = this;
      } else {
        for (const el of this._submenus)
          el.close(trigger);
        this._media.activeMenu = null;
      }
    }
    if (expanded)
      this._menuObserver?._onOpen?.(trigger);
    else
      this._menuObserver?._onClose?.(trigger);
  }
  _isExpanded() {
    return !this._isDisabled() && this._expanded();
  }
  _isDisabled() {
    return this._disabled() || this._buttonDisabled();
  }
  _disable(disabled) {
    this._disabled.set(disabled);
  }
  _onPointerUp(event) {
    event.stopPropagation();
  }
  _onWindowPointerUp() {
    if (this._parentMenu)
      return setTimeout(this.close.bind(this), 300);
    this.close();
  }
  _onCloseTargetPress(event) {
    event.stopPropagation();
    this.close(event);
  }
  _getCloseTarget() {
    const target = this.el.querySelector('[slot="close-target"]');
    return isElementParent(this.el, target) ? target : null;
  }
  _changeIdleTracking(trigger) {
    if (this._parentMenu)
      return;
    if (this._expanded())
      this._media.remote.pauseUserIdle(trigger);
    else
      this._media.remote.resumeUserIdle(trigger);
  }
  _addSubmenu(el) {
    this._submenus.add(el);
    listenEvent(el, "open", this._onSubmenuOpenBind);
    listenEvent(el, "close", this._onSubmenuCloseBind);
    onDispose(this._removeSubmenuBind);
  }
  _removeSubmenu(el) {
    this._submenus.delete(el);
  }
  _onSubmenuOpen(event) {
    for (const el of this._submenus) {
      if (el !== event.target)
        el.setAttribute("aria-hidden", "true");
    }
    this._onResize();
  }
  _onSubmenuClose() {
    for (const el of this._submenus)
      el.removeAttribute("aria-hidden");
    this._onResize();
  }
  _onResize() {
    if (!this._menuItems || false)
      return;
    let style = getComputedStyle(this._menuItems), height = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let children = [...this._menuItems.children];
    if (children[0]?.localName === "shadow-root") {
      children.push(...children[0].children);
    }
    for (const child of children) {
      height += child.offsetHeight;
    }
    requestAnimationFrame(() => {
      if (!this._menuItems)
        return;
      setAttribute(this._menuItems, "data-resizing", "");
      setTimeout(() => {
        if (!this._menuItems)
          return;
        setAttribute(this._menuItems, "data-resizing", false);
      }, 250);
      setStyle(this._menuItems, "--menu-height", height + "px");
    });
  }
  open(trigger) {
    if (peek(this._expanded))
      return;
    this._expanded.set(true);
    tick();
    this._onChange(trigger);
    if (isKeyboardEvent(trigger)) {
      this._menuItems?.focus();
    }
    this._changeIdleTracking(trigger);
  }
  close(trigger) {
    if (!peek(this._expanded))
      return;
    this._expanded.set(false);
    tick();
    if (isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        this._menuButton?.focus();
      });
    }
    this._onChange(trigger);
    this._changeIdleTracking(trigger);
  }
};
Menu.el = defineElement({
  tagName: "media-menu",
  props: { position: null }
});
__decorateClass([
  method
], Menu.prototype, "open", 1);
__decorateClass([
  method
], Menu.prototype, "close", 1);

// src/player/ui/menu/playback-rate/menu-button.tsx
var PlaybackRateMenuButton = class extends MenuButton {
  render() {
    const { label } = this.$props;
    return renderMenuButtonContent({
      label,
      iconPaths: odometer_default
    });
  }
};
PlaybackRateMenuButton.el = defineElement({
  tagName: "media-playback-rate-menu-button",
  props: { disabled: false, label: "Speed" }
});

// src/player/ui/menu/playback-rate/menu-items.tsx
var $$_templ17 = /* @__PURE__ */ $$_create_template(`<span part="label"></span>`);
var PlaybackRateMenuItems = class extends MenuItems {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
  }
  onConnect(el) {
    effect2(this._watchHintText.bind(this));
    const { radioClass, radioCheckClass } = this.$props;
    new ClassManager(el)._observe("media-radio", radioClass)._observe('[part="check"]', radioCheckClass);
  }
  _watchHintText() {
    const { normalLabel } = this.$props, { playbackRate } = this._media.$store, rate = playbackRate();
    this._menu._hint.set(rate === 1 ? normalLabel() : rate + "\xD7");
  }
  _onChange(event) {
    const radioGroup = event.target;
    this._media.remote.changePlaybackRate(+radioGroup.value, event);
  }
  _getValue() {
    const { playbackRate } = this._media.$store;
    return playbackRate() + "";
  }
  _getOptions() {
    const { rates, normalLabel } = this.$props;
    return rates().map((rate) => ({
      value: rate + "",
      content: () => (() => {
        const $$_root = $$_clone($$_templ17);
        $$_insert_lite($$_root, () => rate === 1 ? normalLabel() : rate + "\xD7");
        return $$_root;
      })()
    }));
  }
  render() {
    const { radioGroupClass } = this.$props;
    return renderRadioGroup({
      value: this._getValue.bind(this),
      options: this._getOptions.bind(this),
      radioGroupClass,
      onChange: this._onChange.bind(this)
    });
  }
};
PlaybackRateMenuItems.el = defineElement({
  tagName: "media-playback-rate-menu-items",
  props: {
    normalLabel: "Normal",
    rates: [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2],
    radioGroupClass: null,
    radioClass: null,
    radioCheckClass: null
  }
});
PlaybackRateMenuItems.register = [RadioGroup, Radio];

// src/player/ui/menu/quality/menu-button.tsx
var QualityMenuButton = class extends MenuButton {
  render() {
    const { label } = this.$props;
    return renderMenuButtonContent({
      label,
      iconPaths: settings_menu_default
    });
  }
};
QualityMenuButton.el = defineElement({
  tagName: "media-quality-menu-button",
  props: { disabled: false, label: "Quality" }
});

// src/player/ui/menu/quality/menu-items.tsx
var $$_templ18 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var $$_templ_210 = /* @__PURE__ */ $$_create_template(`<span part="label"></span>`);
var $$_templ_32 = /* @__PURE__ */ $$_create_template(`<span part="info"></span>`);
var QualityMenuItems = class extends MenuItems {
  constructor(instance) {
    super(instance);
    this._sortedQualities = computed(() => {
      const { qualities } = this._media.$store;
      return [...qualities()].sort(
        (a, b) => b.height === a.height ? b.bitrate - a.bitrate : b.height - a.height
      );
    });
    this._media = useMedia();
  }
  onConnect(el) {
    effect2(this._watchControllerDisabled.bind(this));
    effect2(this._watchHintText.bind(this));
    const { radioClass, radioCheckClass } = this.$props;
    new ClassManager(el)._observe("media-radio", radioClass)._observe('[part="check"]', radioCheckClass);
  }
  _watchHintText() {
    const { autoLabel } = this.$props, { autoQuality, quality } = this._media.$store, qualityText = quality() ? quality().height + "p" : "";
    this._menu._hint.set(!autoQuality() ? qualityText : autoLabel() + ` (${qualityText})`);
  }
  _watchControllerDisabled() {
    const { qualities } = this._media.$store;
    this._menu._disable(qualities().length === 0);
  }
  _isDisabled() {
    const { canSetQuality, qualities } = this._media.$store;
    return !canSetQuality() || qualities().length === 0;
  }
  _onChange(event) {
    if (this._isDisabled())
      return;
    const radioGroup = event.target, value = radioGroup.value;
    if (value === "auto") {
      this._media.remote.changeQuality(-1, event);
      return;
    }
    const { qualities } = this._media.$store, index = peek(qualities).findIndex((quality) => this._getQualityId(quality) === value);
    if (index >= 0)
      this._media.remote.changeQuality(index, event);
  }
  _getValue() {
    const { quality, autoQuality } = this._media.$store;
    if (autoQuality())
      return "auto";
    const currentQuality = quality();
    return currentQuality ? this._getQualityId(currentQuality) : "auto";
  }
  _getQualityId(quality) {
    return quality.height + "_" + quality.bitrate;
  }
  _getOptions() {
    const { autoLabel, hideBitrate } = this.$props;
    return [
      { value: "auto", content: () => (() => {
        const $$_root = $$_clone($$_templ18);
        $$_insert_lite($$_root, autoLabel);
        return $$_root;
      })() },
      ...this._sortedQualities().map((quality) => {
        const rate = `${round(quality.bitrate / 1e6, 2)} Mbps`;
        return {
          value: this._getQualityId(quality),
          content: () => [
            (() => {
              const $$_root = $$_clone($$_templ_210);
              $$_insert_lite($$_root, quality.height + "p");
              return $$_root;
            })(),
            !hideBitrate() && (() => {
              const $$_root = $$_clone($$_templ_32);
              $$_insert_lite($$_root, rate);
              return $$_root;
            })()
          ]
        };
      })
    ];
  }
  render() {
    const { radioGroupClass } = this.$props;
    return renderRadioGroup({
      value: this._getValue.bind(this),
      options: this._getOptions.bind(this),
      radioGroupClass,
      onChange: this._onChange.bind(this)
    });
  }
};
QualityMenuItems.el = defineElement({
  tagName: "media-quality-menu-items",
  props: {
    autoLabel: "Auto",
    hideBitrate: false,
    radioGroupClass: null,
    radioClass: null,
    radioCheckClass: null
  }
});
QualityMenuItems.register = [RadioGroup, Radio];

// src/player/ui/poster.tsx
var $$_templ19 = /* @__PURE__ */ $$_create_template(`<img part="img" />`);
var Poster = class extends Component {
  constructor() {
    super(...arguments);
    this._imgLoading = signal(true);
    this._imgError = signal(false);
  }
  onAttach(el) {
    this._media = useMedia();
    this._imgSrc = computed(this._getImgSrc.bind(this));
    this._imgAlt = this._getImgAlt.bind(this);
    this.setAttributes({
      "data-loading": this._imgLoading,
      "aria-hidden": $ariaBool(this._isHidden.bind(this))
    });
  }
  onConnect(el) {
    const { canLoad, poster } = this._media.$store;
    window.requestAnimationFrame(() => {
      if (!canLoad())
        preconnect(poster());
    });
    effect2(this._onLoadStart.bind(this));
  }
  _isHidden() {
    const { poster } = this._media.$store;
    return this._imgError() || !poster();
  }
  _getImgSrc() {
    const { canLoad, poster } = this._media.$store;
    return canLoad() && poster().length ? poster() : null;
  }
  _getImgAlt() {
    return this._imgSrc() ? this.$props.alt() : null;
  }
  _onLoadStart() {
    const { canLoad, poster } = this._media.$store;
    const isLoading = canLoad() && !!poster();
    this._imgLoading.set(isLoading);
    this._imgError.set(false);
  }
  _onLoad() {
    this._imgLoading.set(false);
  }
  _onError() {
    this._imgLoading.set(false);
    this._imgError.set(true);
  }
  render() {
    const { crossorigin } = this._media.$store;
    return (() => {
      const $$_root = $$_clone($$_templ19);
      $$_effect(() => $$_attr($$_root, "src", this._imgSrc()));
      $$_effect(() => $$_attr($$_root, "alt", this._imgAlt()));
      $$_effect(() => $$_attr($$_root, "crossorigin", crossorigin()));
      $$_listen($$_root, "load", this._onLoad.bind(this));
      $$_listen($$_root, "error", this._onError.bind(this));
      return $$_root;
    })();
  }
};
Poster.el = defineElement({
  tagName: "media-poster",
  props: { alt: void 0 }
});

// src/player/ui/sliders/slider/api/store.ts
var SliderStoreFactory = new StoreFactory({
  min: 0,
  max: 100,
  value: 50,
  pointerValue: 0,
  focused: false,
  dragging: false,
  pointing: false,
  get interactive() {
    return this.dragging || this.focused || this.pointing;
  },
  get fillRate() {
    return calcRate(this.min, this.max, this.value);
  },
  get fillPercent() {
    return this.fillRate * 100;
  },
  get pointerRate() {
    return calcRate(this.min, this.max, this.pointerValue);
  },
  get pointerPercent() {
    return this.pointerRate * 100;
  }
});
function calcRate(min, max, value) {
  const range = max - min, offset = value - min;
  return range > 0 ? offset / range : 0;
}

// src/player/ui/sliders/slider-thumbnail.tsx
var $$_templ20 = /* @__PURE__ */ $$_create_template(`<media-thumbnail part="thumbnail" mk-d></media-thumbnail>`);
var SliderThumbnail = class extends Component {
  constructor(instance) {
    super(instance);
    this._media = useMedia();
    this._slider = useStore(SliderStoreFactory);
  }
  _getTime() {
    const { duration } = this._media.$store;
    return this._slider.pointerRate() * duration();
  }
  render() {
    const time = this._getTime.bind(this);
    return (() => {
      const $$_root = $$_clone($$_templ20);
      $$_effect(() => $$_attr($$_root, "time", time()));
      $$_setup_custom_element($$_root);
      return $$_root;
    })();
  }
};
SliderThumbnail.el = defineElement({
  tagName: "media-slider-thumbnail"
});
SliderThumbnail.register = [Thumbnail];

// src/player/ui/sliders/slider/format.ts
var sliderValueFormatContext = createContext(() => ({}));

// src/player/ui/sliders/slider-value.tsx
var $$_templ21 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var SliderValue = class extends Component {
  onAttach() {
    this._slider = useStore(SliderStoreFactory);
    this._format = useContext(sliderValueFormatContext);
    this._text = computed(this._getText.bind(this));
  }
  _getText() {
    const { type, format, decimalPlaces, padHours, padMinutes, showHours } = this.$props;
    const { value: sliderValue, pointerValue, min, max } = this._slider;
    const value = type() === "current" ? sliderValue() : pointerValue();
    if (format() === "percent") {
      const range = max() - min();
      const percent = value / range * 100;
      return (this._format.percent ?? round)(percent, decimalPlaces()) + "\uFE6A";
    } else if (format() === "time") {
      return (this._format.time ?? formatTime)(value, padHours(), padMinutes(), showHours());
    } else {
      return this._format.value?.(value) ?? value.toFixed(2);
    }
  }
  render() {
    return (() => {
      const $$_root = $$_clone($$_templ21);
      $$_insert_lite($$_root, this._text);
      return $$_root;
    })();
  }
};
SliderValue.el = defineElement({
  tagName: "media-slider-value",
  props: {
    type: "current",
    format: void 0,
    showHours: false,
    padHours: false,
    padMinutes: false,
    decimalPlaces: 2
  }
});

// src/player/ui/sliders/slider-video.tsx
var $$_templ22 = /* @__PURE__ */ $$_create_template(`<video muted="" playsinline="" preload="auto" part="video" style="max-width: unset"></video>`);
var SliderVideo = class extends Component {
  constructor() {
    super(...arguments);
    this._video = null;
    this._canPlay = signal(false);
    this._error = signal(false);
  }
  onAttach() {
    this._media = useMedia();
    this._slider = useStore(SliderStoreFactory);
    this._src = computed(this._getSrc.bind(this));
    this._hidden = computed(this._isHidden.bind(this));
    this.setAttributes({
      "data-loading": this._isLoading.bind(this),
      "aria-hidden": $ariaBool(this._hidden)
    });
    effect2(this._onSrcChange.bind(this));
    effect2(this._onTimeUpdate.bind(this));
  }
  onConnect() {
    if (this._video.readyState >= 2)
      this._onCanPlay();
  }
  render() {
    const { crossorigin } = this._media.$store;
    return (() => {
      const $$_root = $$_clone($$_templ22);
      $$_effect(() => $$_attr($$_root, "src", this._src()));
      $$_effect(() => $$_attr($$_root, "crossorigin", crossorigin()));
      $$_listen($$_root, "canplay", this._onCanPlay.bind(this));
      $$_listen($$_root, "error", this._onError.bind(this));
      $$_ref($$_root, this._setVideo.bind(this));
      return $$_root;
    })();
  }
  _getSrc() {
    const { canLoad } = this._media.$store;
    return canLoad() ? this.$props.src() : null;
  }
  _isLoading() {
    return !this._canPlay() && !this._hidden();
  }
  _isHidden() {
    const { duration } = this._media.$store;
    return !!this._error() || !this._canPlay() || !Number.isFinite(duration());
  }
  _onSrcChange() {
    this._src();
    this._canPlay.set(false);
    this._error.set(false);
  }
  _onCanPlay(event) {
    this._canPlay.set(true);
    this.dispatch("can-play", { trigger: event });
  }
  _onError(event) {
    this._error.set(true);
    this.dispatch("error", { trigger: event });
  }
  _onTimeUpdate() {
    const { duration } = this._media.$store;
    const { pointerRate } = this._slider;
    if (this._canPlay() && this._video && Number.isFinite(duration()) && Number.isFinite(pointerRate())) {
      this._video.currentTime = pointerRate() * duration();
    }
  }
  _setVideo(el) {
    this._video = el;
  }
};
SliderVideo.el = defineElement({
  tagName: "media-slider-video",
  props: { src: void 0 }
});

// src/player/ui/sliders/slider/api/props.ts
var sliderProps = {
  min: 0,
  max: 100,
  disabled: false,
  value: 100,
  step: 1,
  keyStep: 1,
  shiftKeyMultiplier: 5,
  trackClass: null,
  trackFillClass: null,
  trackProgressClass: null,
  thumbContainerClass: null,
  thumbClass: null
};

// src/player/ui/sliders/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/sliders/slider/events-controller.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
var SliderEventsController = class extends ComponentController {
  constructor(instance, _delegate, _media) {
    super(instance);
    this._delegate = _delegate;
    this._media = _media;
    this._outlet = null;
    this._touchX = null;
    this._touchStartValue = null;
    this._thumb = null;
    this._trackFill = null;
    this._onDocumentPointerMove = functionThrottle(
      (event) => {
        this._updatePointerValue(this._getPointerValue(event), event);
      },
      20,
      { leading: true }
    );
  }
  onConnect() {
    effect2(this._attachEventListeners.bind(this));
    effect2(this._attachPointerListeners.bind(this));
    if (this._delegate._swipeGesture) {
      scopedRaf(() => {
        const outlet = this._media.player?.querySelector("media-outlet");
        if (outlet) {
          this._outlet = outlet;
          listenEvent(outlet, "touchstart", this._onTouchStart.bind(this));
          listenEvent(outlet, "touchmove", this._onTouchMove.bind(this));
        }
      });
    }
  }
  _onTouchStart(event) {
    this._touchX = event.touches[0].clientX;
  }
  _onTouchMove(event) {
    if (isNull(this._touchX))
      return;
    event.preventDefault();
    if (this.$store.dragging())
      return;
    const diff = event.touches[0].clientX - this._touchX;
    if (Math.abs(diff) > 20) {
      this._touchX = event.touches[0].clientX;
      this._touchStartValue = this.$store.value();
      this._onStartDragging(this._touchStartValue, event);
    }
  }
  _attachEventListeners() {
    if (this._delegate._isDisabled())
      return;
    this.listen("focus", this._onFocus.bind(this));
    this.listen("pointerenter", this._onPointerEnter.bind(this));
    this.listen("pointermove", this._onPointerMove.bind(this));
    this.listen("pointerleave", this._onPointerLeave.bind(this));
    this.listen("pointerdown", this._onPointerDown.bind(this));
    this.listen("keydown", this._onKeyDown.bind(this));
    this.listen("keyup", this._onKeyUp.bind(this));
  }
  _attachPointerListeners() {
    if (this._delegate._isDisabled() || !this.$store.dragging())
      return;
    listenEvent(document, "pointerup", this._onDocumentPointerUp.bind(this));
    listenEvent(document, "pointermove", this._onDocumentPointerMove.bind(this));
    if (IS_SAFARI) {
      listenEvent(document, "touchmove", this._onDocumentTouchMove.bind(this), {
        passive: false
      });
    }
  }
  _onFocus() {
    this._updatePointerValue(this.$store.value());
  }
  _updateValue(newValue, trigger) {
    const { value, min, max, dragging } = this.$store;
    const clampedValue = Math.max(min(), Math.min(newValue, max()));
    value.set(clampedValue);
    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onValueChange(event);
    if (dragging()) {
      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
      this.el.dispatchEvent(event2);
      this._delegate._onDragValueChange(event2);
    }
  }
  _updatePointerValue(value, trigger) {
    const { pointerValue, dragging } = this.$store;
    pointerValue.set(value);
    this.dispatch("pointer-value-change", { detail: value, trigger });
    if (dragging()) {
      const dir = this._delegate._orientation === "vertical" ? "bottom" : "left", size = this._delegate._orientation === "vertical" ? "height" : "width";
      if (this._trackFill && !this.el?.hasAttribute("data-chapters")) {
        this._trackFill.style[size] = value + "%";
      }
      if (this._thumb) {
        this._thumb.style[dir] = value + "%";
      }
      this._updateValue(value, trigger);
    }
  }
  _getPointerValue(event) {
    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$store;
    if (this._delegate._orientation === "vertical") {
      const { bottom: trackBottom, height: trackHeight } = rect;
      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
    } else {
      if (this._touchX && isNumber(this._touchStartValue)) {
        const { width } = this._outlet.getBoundingClientRect(), rate = (event.clientX - this._touchX) / width, range = max() - min(), diff = range * Math.abs(rate);
        thumbPositionRate = (rate < 0 ? this._touchStartValue - diff : this._touchStartValue + diff) / range;
      } else {
        const { left: trackLeft, width: trackWidth } = rect;
        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
      }
    }
    return Math.max(
      min(),
      Math.min(
        max(),
        this._delegate._roundValue(
          getValueFromRate(min(), max(), thumbPositionRate, this._delegate._getStep())
        )
      )
    );
  }
  _onPointerEnter(event) {
    this.$store.pointing.set(true);
  }
  _onPointerMove(event) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    this._updatePointerValue(this._getPointerValue(event), event);
  }
  _onPointerLeave(event) {
    this.$store.pointing.set(false);
  }
  _onPointerDown(event) {
    if (event.button !== 0)
      return;
    const value = this._getPointerValue(event);
    this._onStartDragging(value, event);
    this._updatePointerValue(value, event);
  }
  _onStartDragging(value, trigger) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    dragging.set(true);
    this._thumb = this.el.querySelector(
      'shadow-root > div[part="thumb-container"]'
    );
    this._trackFill = this.el.querySelector(
      'shadow-root > div[part~="track-fill"]'
    );
    this._media.remote.pauseUserIdle(trigger);
    const event = this.createEvent("drag-start", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onDragStart(event);
  }
  _onStopDragging(value, trigger) {
    const { dragging } = this.$store;
    if (!dragging())
      return;
    dragging.set(false);
    if (this._trackFill) {
      setStyle(this._trackFill, "width", null);
      this._trackFill = null;
    }
    if (this._thumb) {
      setStyle(this._thumb, "left", null);
      setStyle(this._thumb, "bottom", null);
      this._thumb = null;
    }
    this._media.remote.resumeUserIdle(trigger);
    const event = this.createEvent("drag-end", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onDragEnd(event);
    this._touchX = null;
    this._touchStartValue = null;
  }
  _onKeyDown(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key: key2 } = event;
    const { min, max } = this.$store;
    let newValue;
    if (key2 === "Home" || key2 === "PageUp") {
      newValue = min();
    } else if (key2 === "End" || key2 === "PageDown") {
      newValue = max();
    } else if (!event.metaKey && /[0-9]/.test(key2)) {
      newValue = (max() - min()) / 10 * Number(key2);
    }
    if (!isUndefined(newValue)) {
      this._updatePointerValue(newValue, event);
      this._updateValue(newValue, event);
      return;
    }
    const value = this._getKeyValue(event);
    if (!value)
      return;
    const repeat = key2 === this._lastDownKey;
    if (!this.$store.dragging() && repeat)
      this._onStartDragging(value, event);
    this._updatePointerValue(value, event);
    if (!repeat)
      this._updateValue(value, event);
    this._lastDownKey = key2;
  }
  _onKeyUp(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    this._lastDownKey = "";
    const { dragging, value } = this.$store;
    if (!dragging())
      return;
    const newValue = this._getKeyValue(event) ?? value();
    this._updatePointerValue(newValue);
    this._onStopDragging(newValue, event);
  }
  _getKeyValue(event) {
    const { key: key2, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key2);
    if (!isValidKey)
      return;
    const { shiftKeyMultiplier } = this.$props;
    const { value } = this.$store, step = this._delegate._getStep(), keyStep = this._delegate._getKeyStep();
    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key2]), diff = modifiedStep * direction, steps = (value() + diff) / step;
    return Number((step * steps).toFixed(3));
  }
  // -------------------------------------------------------------------------------------------
  // Document (Pointer Events)
  // -------------------------------------------------------------------------------------------
  _onDocumentPointerUp(event) {
    if (event.button !== 0)
      return;
    const value = this._getPointerValue(event);
    this._updatePointerValue(value, event);
    this._onStopDragging(value, event);
  }
  _onDocumentTouchMove(event) {
    event.preventDefault();
  }
};

// src/player/ui/sliders/slider/slider.tsx
var $$_templ23 = /* @__PURE__ */ $$_create_template(`<div part="track"></div>`);
var $$_templ_211 = /* @__PURE__ */ $$_create_template(`<div part="track track-fill"></div>`);
var $$_templ_33 = /* @__PURE__ */ $$_create_template(`<div part="track track-progress"></div>`);
var $$_templ_42 = /* @__PURE__ */ $$_create_template(`<div part="thumb-container"><div part="thumb"></div></div>`);
var Slider = class extends Component {
  constructor(instance) {
    super(instance);
    this._readonly = false;
    this._orientation = "";
    this._updateSliderVars = animationFrameThrottle(
      (fillPercent, pointerPercent) => {
        this.el?.style.setProperty("--slider-fill-percent", fillPercent + "%");
        this.el?.style.setProperty("--slider-pointer-percent", pointerPercent + "%");
      }
    );
    // -------------------------------------------------------------------------------------------
    // Preview
    // -------------------------------------------------------------------------------------------
    this._preview = null;
    this._onPreviewResize = animationFrameThrottle(() => {
      if (!this._preview)
        return;
      const rect = this._preview.getBoundingClientRect();
      setStyle(this._preview, "--computed-width", rect.width + "px");
      setStyle(this._preview, "--computed-height", rect.height + "px");
    });
    provideContext(sliderValueFormatContext);
    this._media = useMedia();
    new SliderEventsController(instance, this, this._media);
    const focus = new FocusVisibleController(instance);
    this.$store.focused = focus.focused.bind(focus);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "role", "slider");
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(el, "autocomplete", "off");
    this._orientation = el.getAttribute("aria-orientation") || "";
    if (!this._readonly) {
      effect2(this._watchMinMax.bind(this));
      effect2(this._watchDisabled.bind(this));
    }
    effect2(this._watchValue.bind(this));
    this._setAttrs();
  }
  onConnect(el) {
    this._setupPreview();
  }
  render() {
    const { trackClass, trackFillClass, trackProgressClass, thumbContainerClass, thumbClass } = this.$props;
    return [
      (() => {
        const $$_root = $$_clone($$_templ23);
        $$_effect(() => $$_attr($$_root, "class", trackClass()));
        return $$_root;
      })(),
      (() => {
        const $$_root = $$_clone($$_templ_211);
        $$_effect(() => $$_attr($$_root, "class", trackFillClass()));
        return $$_root;
      })(),
      (() => {
        const $$_root = $$_clone($$_templ_33);
        $$_effect(() => $$_attr($$_root, "class", trackProgressClass()));
        return $$_root;
      })(),
      (() => {
        const $$_root = $$_clone($$_templ_42), $$_el = $$_root.firstChild;
        $$_effect(() => $$_attr($$_root, "class", thumbContainerClass()));
        $$_effect(() => $$_attr($$_el, "class", thumbClass()));
        return $$_root;
      })()
    ];
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  _getStep() {
    return this.$props.step();
  }
  _getKeyStep() {
    return this.$props.keyStep();
  }
  _roundValue(value) {
    return Math.round(value);
  }
  _isDisabled() {
    return this.$props.disabled();
  }
  // -------------------------------------------------------------------------------------------
  // Watch
  // -------------------------------------------------------------------------------------------
  _watchMinMax() {
    const { min, max } = this.$props;
    this.$store.min.set(min());
    this.$store.max.set(max());
  }
  _watchDisabled() {
    if (!this._isDisabled())
      return;
    const { dragging, pointing } = this.$store;
    dragging.set(false);
    pointing.set(false);
  }
  _watchValue() {
    const { dragging, value, min, max } = this.$store;
    if (peek(dragging))
      return;
    value.set(getClampedValue(min(), max(), value(), this._getStep()));
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  _getARIADisabled() {
    return ariaBool(this._isDisabled());
  }
  _getARIAValueMin() {
    return this.$props.min();
  }
  _getARIAValueMax() {
    return this.$props.max();
  }
  _getARIAValueNow() {
    const { value } = this.$store;
    return Math.round(value());
  }
  _getARIAValueText() {
    const { value, max } = this.$store;
    return round(value() / max() * 100, 2) + "%";
  }
  // -------------------------------------------------------------------------------------------
  // Attributes
  // -------------------------------------------------------------------------------------------
  _setAttrs() {
    const { disabled } = this.$props, { dragging, interactive, pointing } = this.$store;
    this.setAttributes({
      disabled,
      "data-dragging": dragging,
      "data-pointing": pointing,
      "data-interactive": interactive,
      "aria-disabled": this._getARIADisabled.bind(this),
      "aria-valuemin": this._getARIAValueMin.bind(this),
      "aria-valuemax": this._getARIAValueMax.bind(this),
      "aria-valuenow": this._getARIAValueNow.bind(this),
      "aria-valuetext": this._getARIAValueText.bind(this),
      "data-styled": this._isStyled.bind(this),
      "data-media-slider": true
    });
    effect2(this._watchCSSVars.bind(this));
  }
  _isStyled() {
    return !!this.$props.trackClass();
  }
  _watchCSSVars() {
    const { fillPercent, pointerPercent } = this.$store;
    this._updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
  }
  _setupPreview() {
    this._preview = this.el.querySelector('[slot="preview"]');
    if (!this._preview)
      return;
    effect2(this._watchPreview.bind(this));
    import('./chunks/preview-JJG3ZTKT.js').then(({ setupPreviewStyles }) => {
      setupPreviewStyles(this._preview, this._orientation);
    });
  }
  _watchPreview() {
    if (this._isDisabled() || !this._preview)
      return;
    window.requestAnimationFrame(this._onPreviewResize);
    const observer = new ResizeObserver(this._onPreviewResize);
    observer.observe(this._preview);
    return () => observer.disconnect();
  }
  // -------------------------------------------------------------------------------------------
  // Events
  // -------------------------------------------------------------------------------------------
  _onValueChange(event) {
  }
  _onDragStart(event) {
  }
  _onDragEnd(event) {
  }
  _onDragValueChange(event) {
  }
};
Slider.el = defineElement({
  tagName: "media-slider",
  props: sliderProps,
  store: SliderStoreFactory
});

// src/player/ui/sliders/time-slider/chapters.tsx
var $$_templ24 = /* @__PURE__ */ $$_create_template(`<div part="chapters"></div>`);
var $$_templ_212 = /* @__PURE__ */ $$_create_template(`<div part="chapter-container"><div part="chapter"><div part="track"></div><div part="track track-fill" style="width: 0%"></div><div part="track track-progress" style="width: 0%"></div></div></div>`);
var SliderChaptersRenderer = class {
  constructor(_media, _slider, _onChange) {
    this._media = _media;
    this._slider = _slider;
    this._onChange = _onChange;
    this._chapters = [];
    this._refs = [];
    this._activeChapterIndex = 0;
    this._bufferedChapterIndex = 0;
    this._updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
      let width;
      for (let i = this._bufferedChapterIndex; i < this._refs.length; i++) {
        width = this._calcChapterPercent(this._chapters[i], bufferedPercent);
        this._getChapterTrackProgress(this._refs[i]).style.width = width + "%";
        if (width < 100) {
          this._bufferedChapterIndex = i;
          break;
        }
      }
    });
    this._bufferedPercent = computed(this._calcMediaBufferedPercent.bind(this));
  }
  render(cues, $class) {
    return cues?.length ? $$_peek(
      () => (() => {
        const $$_root = $$_clone($$_templ24);
        $$_effect(() => $$_attr($$_root, "class", $class()));
        $$_insert_lite($$_root, () => this._renderChapters(cues));
        return $$_root;
      })()
    ) : null;
  }
  _renderChapters(cues) {
    this._chapters = this._fillChapterGaps(cues);
    const firstChapter = this._chapters[0];
    this._onChange(firstChapter.startTime === 0 ? firstChapter.text : "");
    for (let i = 0; i < this._chapters.length; i++)
      this._refs.push(this._renderChapter());
    this._updateContainerWidths();
    effect2(this._watchFillPercent.bind(this));
    effect2(this._watchPointerPercent.bind(this));
    effect2(this._watchBufferedPercent.bind(this));
    onDispose(() => {
      this._refs = [];
      this._activeChapterIndex = 0;
      this._bufferedChapterIndex = 0;
    });
    return this._refs;
  }
  _renderChapter() {
    return $$_clone($$_templ_212);
  }
  _getChapterTrackFill(container) {
    return container.firstChild.firstChild.nextSibling;
  }
  _getChapterTrackProgress(container) {
    return container.firstChild.lastChild;
  }
  _getChaptersEndTime() {
    return this._chapters[this._chapters.length - 1].endTime;
  }
  _updateContainerWidths() {
    let cue, endTime = this._getChaptersEndTime();
    for (let i = 0; i < this._chapters.length; i++) {
      cue = this._chapters[i];
      this._refs[i].style.width = round((cue.endTime - cue.startTime) / endTime * 100, 3) + "%";
    }
  }
  _watchFillPercent() {
    let { fillPercent, value, pointing } = this._slider, currentChapter = this._chapters[this._activeChapterIndex], activeIndex = this._findActiveChapterIndex(
      currentChapter.startTime <= peek(value) ? this._activeChapterIndex : 0,
      fillPercent()
    );
    if (activeIndex > this._activeChapterIndex) {
      this._updateTrackFillWidths(this._activeChapterIndex, activeIndex, "100%");
    } else if (activeIndex < this._activeChapterIndex) {
      this._updateTrackFillWidths(activeIndex + 1, this._activeChapterIndex + 1, "0%");
    }
    if (!peek(pointing) && this._activeChapterIndex !== activeIndex) {
      this._onChange(this._chapters[activeIndex].text);
    }
    let trackFill = this._getChapterTrackFill(this._refs[activeIndex]), percent = this._calcChapterPercent(this._chapters[activeIndex], fillPercent()) + "%";
    if (trackFill.style.width !== percent)
      trackFill.style.width = percent;
    this._activeChapterIndex = activeIndex;
  }
  _watchPointerPercent() {
    let { pointing, pointerPercent } = this._slider;
    if (!pointing())
      return;
    const activeIndex = this._findActiveChapterIndex(0, pointerPercent());
    this._onChange(this._chapters[activeIndex].text);
  }
  _updateTrackFillWidths(start, end, width) {
    for (let i = start; i < end; i++)
      this._getChapterTrackFill(this._refs[i]).style.width = width;
  }
  _findActiveChapterIndex(startIndex, percent) {
    let chapterPercent = 0;
    for (let i = startIndex; i < this._chapters.length; i++) {
      chapterPercent = this._calcChapterPercent(this._chapters[i], percent);
      if (chapterPercent >= 0 && chapterPercent < 100)
        return i;
    }
    return 0;
  }
  _watchBufferedPercent() {
    this._updateBufferedPercent(this._bufferedPercent());
  }
  _calcMediaBufferedPercent() {
    const { bufferedEnd, duration } = this._media;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
  }
  _calcChapterPercent(cue, percent) {
    const lastChapter = this._chapters[this._chapters.length - 1], startPercent = cue.startTime / lastChapter.endTime * 100, endPercent = cue.endTime / lastChapter.endTime * 100;
    return Math.max(
      0,
      round(
        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
        3
      )
    );
  }
  _fillChapterGaps(cues) {
    const chapters = [];
    for (let i = 0; i < cues.length - 1; i++) {
      const currentCue = cues[i], nextCue = cues[i + 1];
      chapters.push(currentCue);
      if (nextCue) {
        const timeDiff = nextCue.startTime - currentCue.endTime;
        if (timeDiff > 0) {
          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
        }
      }
    }
    chapters.push(cues[cues.length - 1]);
    return chapters;
  }
};

// src/player/ui/sliders/time-slider/time-slider.tsx
var TimeSlider2 = class extends Slider {
  constructor(instance) {
    super(instance);
    this._readonly = true;
    this._swipeGesture = true;
    this._track = signal(null);
    this._playingBeforeDragStart = false;
    // -------------------------------------------------------------------------------------------
    // Chapters
    // -------------------------------------------------------------------------------------------
    this._chapterTitleEl = null;
    this._chapterTitle = signal("");
    provideContext(sliderValueFormatContext, {
      value: this._formatValue.bind(this),
      time: this._formatTime.bind(this)
    });
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "aria-label", "Media time");
    super.onAttach(el);
    this._chaptersRenderer = new SliderChaptersRenderer(
      this._media.$store,
      this.$store,
      this._chapterTitle.set
    );
    this.setAttributes({
      "data-chapters": this._hasChapters.bind(this)
    });
    this.setStyles({
      "--media-buffered-percent": this._calcBufferedPercent.bind(this)
    });
    effect2(this._watchCurrentTime.bind(this));
    effect2(this._watchSeekingThrottle.bind(this));
    effect2(this._onTrackChange.bind(this));
    scopedRaf(() => {
      effect2(this._watchPreviewing.bind(this));
    });
  }
  _calcBufferedPercent() {
    const { bufferedEnd, duration } = this._media.$store;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
  }
  _hasChapters() {
    const { duration } = this._media.$store;
    this._classManager?._requestUpdate();
    return this._track()?.cues.length && Number.isFinite(duration()) && duration() > 0;
  }
  onConnect(el) {
    super.onConnect(el);
    this._onTrackModeChange();
    listenEvent(this._media.textTracks, "mode-change", this._onTrackModeChange.bind(this));
    const { chapterContainerClass, chapterClass, trackClass, trackFillClass, trackProgressClass } = this.$props;
    this._classManager = new ClassManager(el)._observe('[part="chapter-container"]', chapterContainerClass)._observe('[part="chapter"]', chapterClass)._observe('[part="track"]', trackClass)._observe('[part~="track-fill"]', trackFillClass)._observe('[part~="track-progress"]', trackProgressClass);
  }
  render() {
    const tracks = super.render(), { chaptersClass } = this.$props;
    return [this._chaptersRenderer.render(this._track()?.cues, chaptersClass), tracks];
  }
  _watchSeekingThrottle() {
    this._dispatchSeeking = functionThrottle(
      this._seeking.bind(this),
      this.$props.seekingRequestThrottle()
    );
  }
  _watchCurrentTime() {
    const { currentTime } = this._media.$store, { value, dragging } = this.$store, newValue = this._timeToPercent(currentTime());
    if (!peek(dragging)) {
      value.set(newValue);
      this.dispatch("value-change", { detail: newValue });
    }
  }
  _watchPreviewing() {
    const player = this._media.player;
    player && this._preview && setAttribute(player, "data-preview", this.$store.interactive());
  }
  _seeking(time, event) {
    this._media.remote.seeking(time, event);
  }
  _seek(time, percent, event) {
    this._dispatchSeeking.cancel();
    const { live } = this._media.$store;
    if (live() && percent >= 99) {
      this._media.remote.seekToLiveEdge(event);
      return;
    }
    this._media.remote.seek(time, event);
  }
  _onDragStart(event) {
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging()) {
      const { paused } = this._media.$store;
      this._playingBeforeDragStart = !paused();
      this._media.remote.pause(event);
    }
  }
  _onDragValueChange(event) {
    this._dispatchSeeking(this._percentToTime(event.detail), event);
  }
  _onDragEnd(event) {
    const percent = event.detail;
    this._seek(this._percentToTime(percent), percent, event);
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging() && this._playingBeforeDragStart) {
      this._media.remote.play(event);
      this._playingBeforeDragStart = false;
    }
  }
  _onValueChange(event) {
    const { dragging } = this.$store;
    if (dragging() || !event.trigger)
      return;
    this._onDragEnd(event);
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  _getStep() {
    const value = this.$props.step() / this._media.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  _getKeyStep() {
    const value = this.$props.keyStep() / this._media.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  _roundValue(value) {
    return round(value, 3);
  }
  _isDisabled() {
    const { canSeek } = this._media.$store;
    return super._isDisabled() || !canSeek();
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  _getARIAValueMin() {
    return 0;
  }
  _getARIAValueMax() {
    return 100;
  }
  _getARIAValueText() {
    const time = this._percentToTime(this.$store.value()), { duration } = this._media.$store;
    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
  }
  // -------------------------------------------------------------------------------------------
  // Format
  // -------------------------------------------------------------------------------------------
  _percentToTime(percent) {
    const { duration } = this._media.$store;
    return Math.round(percent / 100 * duration());
  }
  _timeToPercent(time) {
    const { liveEdge, duration } = this._media.$store, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
  }
  _formatValue(percent) {
    const time = this._percentToTime(percent), { live, duration } = this._media.$store;
    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
  }
  _formatTime(percent, padHours, padMinutes, showHours) {
    const time = this._percentToTime(percent), { live, duration } = this._media.$store, value = live() ? time - duration() : time;
    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(
      Math.abs(value),
      padHours,
      isNull(padMinutes) ? Math.abs(value) >= 3600 : padMinutes,
      showHours
    )}` : "LIVE";
  }
  _onTrackModeChange() {
    onTrackChapterChange(this._media.textTracks, peek(this._track), this._track.set);
  }
  _onTrackChange() {
    this._track();
    this._chapterTitleEl = this.el?.querySelector('[part="chapter-title"]') ?? null;
    if (!this._chapterTitleEl)
      return;
    effect2(this._onChapterTitleChange.bind(this));
    return () => {
      this._chapterTitleEl.textContent = "";
      this._chapterTitleEl = null;
    };
  }
  _onChapterTitleChange() {
    this._chapterTitleEl.textContent = this._chapterTitle();
  }
};
TimeSlider2.el = defineElement({
  tagName: "media-time-slider",
  props: {
    ...sliderProps,
    min: defineProp({ value: 0, attribute: false }),
    max: defineProp({ value: 100, attribute: false }),
    value: defineProp({ value: 0, attribute: false }),
    pauseWhileDragging: false,
    seekingRequestThrottle: 100,
    chaptersClass: null,
    chapterContainerClass: null,
    chapterClass: null
  },
  store: SliderStoreFactory
});

// src/player/ui/sliders/volume-slider.tsx
var VolumeSlider2 = class extends Slider {
  constructor() {
    super(...arguments);
    this._readonly = true;
    this._throttleVolumeChange = functionThrottle(this._onVolumeChange.bind(this), 25);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "aria-label", "Media volume");
    super.onAttach(el);
    {
      canChangeVolume().then((canSet) => {
        if (!canSet)
          setAttribute(el, "aria-hidden", "true");
      });
    }
    effect2(this._watchVolume.bind(this));
  }
  _watchVolume() {
    const { muted, volume } = this._media.$store;
    const newValue = muted() ? 0 : volume() * 100;
    this.$store.value.set(newValue);
    this.dispatch("value-change", { detail: newValue });
  }
  _onVolumeChange(event) {
    if (!event.trigger)
      return;
    const mediaVolume = round(event.detail / 100, 3);
    this._media.remote.changeVolume(mediaVolume, event);
  }
  _onValueChange(event) {
    this._throttleVolumeChange(event);
  }
  _onDragValueChange(event) {
    this._throttleVolumeChange(event);
  }
  _getARIAValueMin() {
    return 0;
  }
  _getARIAValueMax() {
    return 100;
  }
};
VolumeSlider2.el = defineElement({
  tagName: "media-volume-slider",
  props: {
    ...sliderProps,
    min: defineProp({ value: 0, attribute: false }),
    max: defineProp({ value: 100, attribute: false }),
    value: defineProp({ value: 100, attribute: false })
  },
  store: SliderStoreFactory
});

// src/player/ui/time.tsx
var $$_templ25 = /* @__PURE__ */ $$_create_template(`<span></span>`);
var Time = class extends Component {
  onAttach() {
    this._media = useMedia();
    this._time = computed(this._getTime.bind(this));
  }
  _getTime() {
    const { type, remainder, padHours, padMinutes, showHours } = this.$props, seconds = this._getSeconds(type()), duration = this._media.$store.duration();
    if (!Number.isFinite(seconds + duration))
      return "LIVE";
    const time = remainder() ? Math.max(0, duration - seconds) : seconds;
    return formatTime(
      time,
      padHours(),
      isNull(padMinutes()) ? time >= 3600 : padMinutes(),
      showHours()
    );
  }
  _getSeconds(type) {
    const { bufferedEnd, duration, currentTime } = this._media.$store;
    switch (type) {
      case "buffered":
        return bufferedEnd();
      case "duration":
        return duration();
      default:
        return currentTime();
    }
  }
  render() {
    return (() => {
      const $$_root = $$_clone($$_templ25);
      $$_insert_lite($$_root, this._time);
      return $$_root;
    })();
  }
};
Time.el = defineElement({
  tagName: "media-time",
  props: {
    type: "current",
    showHours: false,
    padHours: null,
    padMinutes: null,
    remainder: false
  }
});

// src/player/ui/tooltip/tooltip.tsx
var Tooltip = class extends Component {
  onAttach(el) {
    if (hasProvidedContext(tooltipContext)) {
      scopedRaf(() => {
        if (!el.isConnected)
          return;
        const tooltip = useContext(tooltipContext);
        tooltip._attachTooltip(el);
      });
    }
    this.setAttributes({
      position: this.$props.position
    });
  }
};
Tooltip.el = defineElement({
  tagName: "media-tooltip",
  props: { position: "top center" }
});

// src/register.ts
function getUIComponents() {
  return [
    Poster,
    BufferingIndicator,
    Tooltip,
    Thumbnail,
    PlayButton2,
    MuteButton2,
    PIPButton,
    FullscreenButton2,
    CaptionButton2,
    SeekButton2,
    Slider,
    TimeSlider2,
    VolumeSlider2,
    SliderThumbnail,
    SliderValue,
    SliderVideo,
    Time,
    ToggleButton,
    LiveIndicator,
    Captions,
    Gesture,
    Menu,
    MenuButton,
    MenuItems,
    RadioGroup,
    Radio,
    AudioMenuButton,
    AudioMenuItems,
    CaptionsMenuButton,
    CaptionsMenuItems,
    ChaptersMenuItems,
    QualityMenuButton,
    QualityMenuItems,
    PlaybackRateMenuButton,
    PlaybackRateMenuItems
  ];
}
function registerAllElements() {
  [Player, Outlet, ...getUIComponents(), CommunitySkin].map(registerLiteCustomElement);
}

// src/cdn.ts
registerAllElements();
registerLiteCustomElement(Icon);
/*! Bundled license information:

maverick.js/dist/dev/chunks/chunk-FIEGXSET.js:
  (**
   * The code below this comment was adapted from Lit: https://github.dev/lit/lit
   *
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
