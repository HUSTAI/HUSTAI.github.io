import { AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunk-FRNAFKFA.js';
import { isHLSSupported, IS_SAFARI, canPlayHLSNatively } from './chunk-WSYKLWQE.js';
import { TextTrack } from './chunk-2SNW2HZF.js';
import { getRequestCredentials, preconnect } from './chunk-IVW6GMZV.js';
import { scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { signal, tick, onDispose, peek, computed, effect } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { animationFrameThrottle, listenEvent, setStyle, isString, isArray } from 'maverick.js/std';
import { $$_create_walker, $$_effect, $$_attr, $$_ref, $$_create_template } from 'maverick.js/dom';

var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><audio preload="none" aria-hidden="true"></audio>`);
var $$_templ_2 = $$_templ;
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    if (!this._audio) {
      throw Error(
        "[vidstack] `<audio>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-6RNK3INB.js')).AudioProvider(this._audio);
  }
  render($store) {
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_ref($$_root, (el) => void (this._audio = el));
      return $$_root;
    })();
  }
};
var $$_templ2 = /* @__PURE__ */ $$_create_template(`<!$><video preload="none" aria-hidden="true"></video>`);
var $$_templ_22 = $$_templ2;
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && canPlayHLSNatively() : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-DAVI2CVZ.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const $poster = computed(() => $store.poster() && $store.controls() ? $store.poster() : null);
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ_22);
      $$_effect(() => $$_attr($$_root, "controls", $store.controls()));
      $$_effect(() => $$_attr($$_root, "crossorigin", $store.crossorigin()));
      $$_effect(() => $$_attr($$_root, "poster", $poster()));
      $$_ref($$_root, (el) => void (this._video = el));
      return $$_root;
    })();
  }
};

// src/player/core/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    if (!this._video) {
      throw Error(
        "[vidstack] `<video>` element was not found - did you forget to include `<media-outlet>`?"
      );
    }
    return new (await import('./provider-CMXM2KBN.js')).HLSProvider(this._video, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/core/outlet/source-select.ts
var warned = /* @__PURE__ */ new Set() ;
var SourceSelection = class {
  constructor(_domSources, _media, _loader) {
    this._domSources = _domSources;
    this._media = _media;
    this._loader = _loader;
    const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
    this._loaders = computed(() => {
      return _media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
    });
    effect(this._onSourcesChange.bind(this));
    effect(this._onSourceChange.bind(this));
    effect(this._onPreconnect.bind(this));
    effect(this._onLoadSource.bind(this));
  }
  _onSourcesChange() {
    this._media.delegate._dispatch("sources-change", {
      detail: [...normalizeSrc(this._media.$props.src()), ...this._domSources()]
    });
  }
  _onSourceChange() {
    const { $store } = this._media;
    const sources = $store.sources(), currentSource = peek($store.source), newSource = this._findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;
    if (noMatch && !warned.has(newSource.src) && !peek(this._loader)) {
      const source = sources[0];
      console.warn(
        `[vidstack] could not find a loader for any of the given media sources, consider providing \`type\`:

<media-outlet>
  <source src="${source.src}" type="video/mp4" />
</media-outlet>"

Falling back to fetching source headers...`
      );
      warned.add(newSource.src);
    }
    if (noMatch) {
      const { crossorigin } = $store, credentials = getRequestCredentials(crossorigin()), abort = new AbortController();
      Promise.all(
        sources.map(
          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
            method: "HEAD",
            credentials,
            signal: abort.signal
          }).then((res) => {
            source.type = res.headers.get("content-type") || "??";
            return source;
          }).catch(() => source) : source
        )
      ).then((sources2) => {
        if (abort.signal.aborted)
          return;
        this._findNewSource(peek($store.source), sources2);
        tick();
      });
      return () => abort.abort();
    }
    tick();
  }
  _findNewSource(currentSource, sources) {
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek(this._loaders).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    this._notifySourceChange(currentSource, newSource, newLoader);
    this._notifyLoaderChange(peek(this._loader), newLoader);
    return newSource;
  }
  _notifySourceChange(currentSource, newSource, newLoader) {
    if (newSource.src === currentSource.src && newSource.type === currentSource.type)
      return;
    this._media.delegate._dispatch("source-change", { detail: newSource });
    this._media.delegate._dispatch("media-type-change", {
      detail: newLoader?.mediaType(newSource) || "unknown"
    });
  }
  _notifyLoaderChange(currentLoader, newLoader) {
    if (newLoader === currentLoader)
      return;
    this._media.delegate._dispatch("provider-change", { detail: null });
    newLoader && peek(() => newLoader.preconnect?.(this._media));
    this._loader.set(newLoader);
    this._media.delegate._dispatch("provider-loader-change", { detail: newLoader });
  }
  _onPreconnect() {
    const provider = this._media.$provider();
    if (!provider)
      return;
    if (this._media.$store.canLoad()) {
      peek(
        () => provider.setup({
          ...this._media,
          player: this._media.player
        })
      );
      return;
    }
    peek(() => provider.preconnect?.(this._media));
  }
  _onLoadSource() {
    const provider = this._media.$provider(), source = this._media.$store.source();
    if (this._media.$store.canLoad()) {
      peek(() => provider?.loadSource(source, peek(this._media.$store.preload)));
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
      {
        this._media.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog("Error", e).dispatch();
      }
    }
  }
};
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}
var Tracks = class {
  constructor(_domTracks, _media) {
    this._domTracks = _domTracks;
    this._media = _media;
    this._prevTracks = [];
    effect(this._onTracksChange.bind(this));
  }
  _onTracksChange() {
    const newTracks = [...this._media.$props.textTracks(), ...this._domTracks()];
    for (const oldTrack of this._prevTracks) {
      if (!newTracks.some((t) => t.id === oldTrack.id)) {
        const track = oldTrack.id && this._media.textTracks.getById(oldTrack.id);
        if (track)
          this._media.textTracks.remove(track);
      }
    }
    for (const newTrack of newTracks) {
      const id = newTrack.id || TextTrack.createId(newTrack);
      if (!this._media.textTracks.getById(id)) {
        newTrack.id = id;
        this._media.textTracks.add(newTrack);
      }
    }
    this._prevTracks = newTracks;
  }
};

// src/player/core/outlet/outlet.tsx
var Outlet = class extends Component {
  constructor(instance) {
    super(instance);
    this._domSources = signal([]);
    this._domTracks = signal([]);
    this._loader = signal(null);
    this._media = useMedia();
    new SourceSelection(this._domSources, this._media, this._loader);
    new Tracks(this._domTracks, this._media);
  }
  onAttach(el) {
    el.setAttribute("keep-alive", "");
  }
  onConnect(el) {
    const resize = new ResizeObserver(animationFrameThrottle(this._onResize.bind(this)));
    resize.observe(el);
    const mutation = new MutationObserver(this._onMutation.bind(this));
    mutation.observe(el, { attributes: true, childList: true });
    if (IS_SAFARI) {
      listenEvent(el, "touchstart", (e) => e.preventDefault(), { passive: false });
    }
    scopedRaf(() => {
      this._onResize();
      this._onMutation();
    });
    return () => {
      resize.disconnect();
      mutation.disconnect();
    };
  }
  onDestroy() {
    this._media.$store.currentTime.set(0);
  }
  _onResize() {
    const player = this._media.player, width = this.el.offsetWidth, height = this.el.offsetHeight;
    if (!player)
      return;
    player.$store.mediaWidth.set(width);
    player.$store.mediaHeight.set(height);
    setStyle(player, "--media-width", width + "px");
    setStyle(player, "--media-height", height + "px");
  }
  _onMutation() {
    const sources = [], tracks = [], children = this.el.children;
    for (const el of children) {
      if (el instanceof HTMLSourceElement) {
        sources.push({
          src: el.src,
          type: el.type
        });
      } else if (el instanceof HTMLTrackElement) {
        tracks.push({
          id: el.id,
          src: el.src,
          kind: el.track.kind,
          language: el.srclang,
          label: el.label,
          default: el.default,
          type: el.getAttribute("data-type")
        });
      }
    }
    this._domSources.set(sources);
    this._domTracks.set(tracks);
    tick();
  }
  render() {
    let currentProvider;
    onDispose(() => currentProvider?.destroy?.());
    return () => {
      currentProvider?.destroy();
      const loader = this._loader();
      if (!loader)
        return null;
      const el = loader.render(this._media.$store);
      peek(() => {
        loader.load(this._media).then((provider) => {
          if (peek(this._loader) !== loader)
            return;
          this._media.delegate._dispatch("provider-change", {
            detail: provider
          });
          currentProvider = provider;
        });
      });
      return el;
    };
  }
};
Outlet.el = defineElement({
  tagName: "media-outlet"
});

export { Outlet };
