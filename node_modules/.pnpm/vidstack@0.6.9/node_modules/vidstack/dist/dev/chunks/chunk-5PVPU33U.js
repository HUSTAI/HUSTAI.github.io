import { sliderProps, Slider } from './chunk-LWTGALKS.js';
import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { formatSpokenTime, formatTime } from './chunk-JY53PGKC.js';
import { round } from './chunk-CVLY5S52.js';
import { ClassManager } from './chunk-XCUHASYJ.js';
import { onTrackChapterChange } from './chunk-NOPW2CG3.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-HQQTSFXD.js';
import { $$_computed, $$_peek, $$_clone, $$_effect, $$_attr, $$_insert_lite, $$_create_template } from 'maverick.js/dom';
import { signal, provideContext, effect, peek, computed, onDispose } from 'maverick.js';
import { defineElement, defineProp } from 'maverick.js/element';
import { listenEvent, setAttribute, isNull, animationFrameThrottle } from 'maverick.js/std';

var $$_templ = /* @__PURE__ */ $$_create_template(`<div part="chapters"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<div part="chapter-container"><div part="chapter"><div part="track"></div><div part="track track-fill" style="width: 0%"></div><div part="track track-progress" style="width: 0%"></div></div></div>`);
var SliderChaptersRenderer = class {
  constructor(_media, _slider, _onChange) {
    this._media = _media;
    this._slider = _slider;
    this._onChange = _onChange;
    this._chapters = [];
    this._refs = [];
    this._activeChapterIndex = 0;
    this._bufferedChapterIndex = 0;
    this._updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {
      let width;
      for (let i = this._bufferedChapterIndex; i < this._refs.length; i++) {
        width = this._calcChapterPercent(this._chapters[i], bufferedPercent);
        this._getChapterTrackProgress(this._refs[i]).style.width = width + "%";
        if (width < 100) {
          this._bufferedChapterIndex = i;
          break;
        }
      }
    });
    this._bufferedPercent = computed(this._calcMediaBufferedPercent.bind(this));
  }
  render(cues, $class) {
    return cues?.length ? $$_peek(
      () => (() => {
        const $$_root = $$_clone($$_templ);
        $$_effect(() => $$_attr($$_root, "class", $class()));
        $$_insert_lite($$_root, () => this._renderChapters(cues));
        return $$_root;
      })()
    ) : null;
  }
  _renderChapters(cues) {
    this._chapters = this._fillChapterGaps(cues);
    const firstChapter = this._chapters[0];
    this._onChange(firstChapter.startTime === 0 ? firstChapter.text : "");
    for (let i = 0; i < this._chapters.length; i++)
      this._refs.push(this._renderChapter());
    this._updateContainerWidths();
    effect(this._watchFillPercent.bind(this));
    effect(this._watchPointerPercent.bind(this));
    effect(this._watchBufferedPercent.bind(this));
    onDispose(() => {
      this._refs = [];
      this._activeChapterIndex = 0;
      this._bufferedChapterIndex = 0;
    });
    return this._refs;
  }
  _renderChapter() {
    return $$_clone($$_templ_2);
  }
  _getChapterTrackFill(container) {
    return container.firstChild.firstChild.nextSibling;
  }
  _getChapterTrackProgress(container) {
    return container.firstChild.lastChild;
  }
  _getChaptersEndTime() {
    return this._chapters[this._chapters.length - 1].endTime;
  }
  _updateContainerWidths() {
    let cue, endTime = this._getChaptersEndTime();
    for (let i = 0; i < this._chapters.length; i++) {
      cue = this._chapters[i];
      this._refs[i].style.width = round((cue.endTime - cue.startTime) / endTime * 100, 3) + "%";
    }
  }
  _watchFillPercent() {
    let { fillPercent, value, pointing } = this._slider, currentChapter = this._chapters[this._activeChapterIndex], activeIndex = this._findActiveChapterIndex(
      currentChapter.startTime <= peek(value) ? this._activeChapterIndex : 0,
      fillPercent()
    );
    if (activeIndex > this._activeChapterIndex) {
      this._updateTrackFillWidths(this._activeChapterIndex, activeIndex, "100%");
    } else if (activeIndex < this._activeChapterIndex) {
      this._updateTrackFillWidths(activeIndex + 1, this._activeChapterIndex + 1, "0%");
    }
    if (!peek(pointing) && this._activeChapterIndex !== activeIndex) {
      this._onChange(this._chapters[activeIndex].text);
    }
    let trackFill = this._getChapterTrackFill(this._refs[activeIndex]), percent = this._calcChapterPercent(this._chapters[activeIndex], fillPercent()) + "%";
    if (trackFill.style.width !== percent)
      trackFill.style.width = percent;
    this._activeChapterIndex = activeIndex;
  }
  _watchPointerPercent() {
    let { pointing, pointerPercent } = this._slider;
    if (!pointing())
      return;
    const activeIndex = this._findActiveChapterIndex(0, pointerPercent());
    this._onChange(this._chapters[activeIndex].text);
  }
  _updateTrackFillWidths(start, end, width) {
    for (let i = start; i < end; i++)
      this._getChapterTrackFill(this._refs[i]).style.width = width;
  }
  _findActiveChapterIndex(startIndex, percent) {
    let chapterPercent = 0;
    for (let i = startIndex; i < this._chapters.length; i++) {
      chapterPercent = this._calcChapterPercent(this._chapters[i], percent);
      if (chapterPercent >= 0 && chapterPercent < 100)
        return i;
    }
    return 0;
  }
  _watchBufferedPercent() {
    this._updateBufferedPercent(this._bufferedPercent());
  }
  _calcMediaBufferedPercent() {
    const { bufferedEnd, duration } = this._media;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
  }
  _calcChapterPercent(cue, percent) {
    const lastChapter = this._chapters[this._chapters.length - 1], startPercent = cue.startTime / lastChapter.endTime * 100, endPercent = cue.endTime / lastChapter.endTime * 100;
    return Math.max(
      0,
      round(
        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
        3
      )
    );
  }
  _fillChapterGaps(cues) {
    const chapters = [];
    for (let i = 0; i < cues.length - 1; i++) {
      const currentCue = cues[i], nextCue = cues[i + 1];
      chapters.push(currentCue);
      if (nextCue) {
        const timeDiff = nextCue.startTime - currentCue.endTime;
        if (timeDiff > 0) {
          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
        }
      }
    }
    chapters.push(cues[cues.length - 1]);
    return chapters;
  }
};

// src/player/ui/sliders/time-slider/time-slider.tsx
var TimeSlider = class extends Slider {
  constructor(instance) {
    super(instance);
    this._readonly = true;
    this._swipeGesture = true;
    this._track = signal(null);
    this._playingBeforeDragStart = false;
    // -------------------------------------------------------------------------------------------
    // Chapters
    // -------------------------------------------------------------------------------------------
    this._chapterTitleEl = null;
    this._chapterTitle = signal("");
    provideContext(sliderValueFormatContext, {
      value: this._formatValue.bind(this),
      time: this._formatTime.bind(this)
    });
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "aria-label", "Media time");
    super.onAttach(el);
    this._chaptersRenderer = new SliderChaptersRenderer(
      this._media.$store,
      this.$store,
      this._chapterTitle.set
    );
    this.setAttributes({
      "data-chapters": this._hasChapters.bind(this)
    });
    this.setStyles({
      "--media-buffered-percent": this._calcBufferedPercent.bind(this)
    });
    effect(this._watchCurrentTime.bind(this));
    effect(this._watchSeekingThrottle.bind(this));
    effect(this._onTrackChange.bind(this));
    scopedRaf(() => {
      effect(this._watchPreviewing.bind(this));
    });
  }
  _calcBufferedPercent() {
    const { bufferedEnd, duration } = this._media.$store;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
  }
  _hasChapters() {
    const { duration } = this._media.$store;
    this._classManager?._requestUpdate();
    return this._track()?.cues.length && Number.isFinite(duration()) && duration() > 0;
  }
  onConnect(el) {
    super.onConnect(el);
    this._onTrackModeChange();
    listenEvent(this._media.textTracks, "mode-change", this._onTrackModeChange.bind(this));
    const { chapterContainerClass, chapterClass, trackClass, trackFillClass, trackProgressClass } = this.$props;
    this._classManager = new ClassManager(el)._observe('[part="chapter-container"]', chapterContainerClass)._observe('[part="chapter"]', chapterClass)._observe('[part="track"]', trackClass)._observe('[part~="track-fill"]', trackFillClass)._observe('[part~="track-progress"]', trackProgressClass);
  }
  render() {
    const tracks = super.render(), { chaptersClass } = this.$props;
    return [$$_computed(() => this._chaptersRenderer.render(this._track()?.cues, chaptersClass)), tracks];
  }
  _watchSeekingThrottle() {
    this._dispatchSeeking = functionThrottle(
      this._seeking.bind(this),
      this.$props.seekingRequestThrottle()
    );
  }
  _watchCurrentTime() {
    const { currentTime } = this._media.$store, { value, dragging } = this.$store, newValue = this._timeToPercent(currentTime());
    if (!peek(dragging)) {
      value.set(newValue);
      this.dispatch("value-change", { detail: newValue });
    }
  }
  _watchPreviewing() {
    const player = this._media.player;
    player && this._preview && setAttribute(player, "data-preview", this.$store.interactive());
  }
  _seeking(time, event) {
    this._media.remote.seeking(time, event);
  }
  _seek(time, percent, event) {
    this._dispatchSeeking.cancel();
    const { live } = this._media.$store;
    if (live() && percent >= 99) {
      this._media.remote.seekToLiveEdge(event);
      return;
    }
    this._media.remote.seek(time, event);
  }
  _onDragStart(event) {
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging()) {
      const { paused } = this._media.$store;
      this._playingBeforeDragStart = !paused();
      this._media.remote.pause(event);
    }
  }
  _onDragValueChange(event) {
    this._dispatchSeeking(this._percentToTime(event.detail), event);
  }
  _onDragEnd(event) {
    const percent = event.detail;
    this._seek(this._percentToTime(percent), percent, event);
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging() && this._playingBeforeDragStart) {
      this._media.remote.play(event);
      this._playingBeforeDragStart = false;
    }
  }
  _onValueChange(event) {
    const { dragging } = this.$store;
    if (dragging() || !event.trigger)
      return;
    this._onDragEnd(event);
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  _getStep() {
    const value = this.$props.step() / this._media.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  _getKeyStep() {
    const value = this.$props.keyStep() / this._media.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  _roundValue(value) {
    return round(value, 3);
  }
  _isDisabled() {
    const { canSeek } = this._media.$store;
    return super._isDisabled() || !canSeek();
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  _getARIAValueMin() {
    return 0;
  }
  _getARIAValueMax() {
    return 100;
  }
  _getARIAValueText() {
    const time = this._percentToTime(this.$store.value()), { duration } = this._media.$store;
    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
  }
  // -------------------------------------------------------------------------------------------
  // Format
  // -------------------------------------------------------------------------------------------
  _percentToTime(percent) {
    const { duration } = this._media.$store;
    return Math.round(percent / 100 * duration());
  }
  _timeToPercent(time) {
    const { liveEdge, duration } = this._media.$store, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
  }
  _formatValue(percent) {
    const time = this._percentToTime(percent), { live, duration } = this._media.$store;
    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
  }
  _formatTime(percent, padHours, padMinutes, showHours) {
    const time = this._percentToTime(percent), { live, duration } = this._media.$store, value = live() ? time - duration() : time;
    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(
      Math.abs(value),
      padHours,
      isNull(padMinutes) ? Math.abs(value) >= 3600 : padMinutes,
      showHours
    )}` : "LIVE";
  }
  _onTrackModeChange() {
    onTrackChapterChange(this._media.textTracks, peek(this._track), this._track.set);
  }
  _onTrackChange() {
    this._track();
    this._chapterTitleEl = this.el?.querySelector('[part="chapter-title"]') ?? null;
    if (!this._chapterTitleEl)
      return;
    effect(this._onChapterTitleChange.bind(this));
    return () => {
      this._chapterTitleEl.textContent = "";
      this._chapterTitleEl = null;
    };
  }
  _onChapterTitleChange() {
    this._chapterTitleEl.textContent = this._chapterTitle();
  }
};
TimeSlider.el = defineElement({
  tagName: "media-time-slider",
  props: {
    ...sliderProps,
    min: defineProp({ value: 0, attribute: false }),
    max: defineProp({ value: 100, attribute: false }),
    value: defineProp({ value: 0, attribute: false }),
    pauseWhileDragging: false,
    seekingRequestThrottle: 100,
    chaptersClass: null,
    chapterContainerClass: null,
    chapterClass: null
  },
  store: SliderStoreFactory
});

export { TimeSlider };
