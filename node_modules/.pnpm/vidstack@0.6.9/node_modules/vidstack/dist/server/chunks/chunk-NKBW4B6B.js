import { AUDIO_EXTENSIONS, AUDIO_TYPES, VIDEO_EXTENSIONS, VIDEO_TYPES, isHLSSrc, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES } from './chunk-TEKTM4DZ.js';
import { isHLSSupported, IS_SAFARI } from './chunk-M727CDUQ.js';
import { TextTrack } from './chunk-ZG64VF3W.js';
import { getRequestCredentials, preconnect } from './chunk-72VYJ2OF.js';
import { scopedRaf } from './chunk-JTTKMFDW.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { signal, tick, onDispose, peek, computed, effect } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { animationFrameThrottle, listenEvent, setStyle, isString, isArray } from 'maverick.js/std';
import { $$_ssr, $$_attr } from 'maverick.js/ssr';

var $$_templ = ["<!$><audio", "", "", "", "", ' preload="none" aria-hidden="true"></audio>'];
var AudioProviderLoader = class {
  canPlay({ src, type }) {
    return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith("blob:") && type === "audio/object" : type === "audio/object";
  }
  mediaType() {
    return "audio";
  }
  async load() {
    return new (await import('./provider-BYI4A2DQ.js')).AudioProvider(this._audio);
  }
  render($store) {
    {
      const src = $store.source().src;
      return $$_ssr(
        $$_templ,
        $$_attr("src", isString(src) ? src : null),
        $$_attr("muted", $store.muted),
        $$_attr("controls", $store.controls),
        $$_attr("crossorigin", $store.crossorigin),
        $$_attr("playsinline", $store.playsinline)
      );
    }
  }
};
var $$_templ2 = ["<!$><video", "", "", "", "", "", ' preload="none" aria-hidden="true"></video>'];
var VideoProviderLoader = class {
  canPlay(src) {
    return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith("blob:") && src.type === "video/object" || isHLSSrc(src) && true : src.type === "video/object";
  }
  mediaType() {
    return "video";
  }
  async load(context) {
    return new (await import('./provider-AMPDDP57.js')).VideoProvider(this._video, context);
  }
  render($store) {
    const $poster = computed(() => $store.poster() && $store.controls() ? $store.poster() : null);
    {
      const src = $store.source().src;
      return $$_ssr(
        $$_templ2,
        $$_attr("src", isString(src) ? src : null),
        $$_attr("poster", $poster),
        $$_attr("muted", $store.muted),
        $$_attr("controls", $store.controls),
        $$_attr("crossorigin", $store.crossorigin),
        $$_attr("playsinline", $store.playsinline)
      );
    }
  }
};

// src/player/core/providers/hls/loader.tsx
var _HLSProviderLoader = class extends VideoProviderLoader {
  preconnect() {
    preconnect("https://cdn.jsdelivr.net", "preconnect");
  }
  canPlay({ src, type }) {
    return _HLSProviderLoader.supported && isString(src) && (HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type));
  }
  async load(context) {
    return new (await import('./provider-WTKJERR7.js')).HLSProvider(this._video, context);
  }
};
var HLSProviderLoader = _HLSProviderLoader;
HLSProviderLoader.supported = isHLSSupported();

// src/player/core/outlet/source-select.ts
var SourceSelection = class {
  constructor(_domSources, _media, _loader) {
    this._domSources = _domSources;
    this._media = _media;
    this._loader = _loader;
    const HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader();
    this._loaders = computed(() => {
      return _media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, HLS_LOADER] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER];
    });
    {
      const { $store } = _media;
      $store.sources.set(normalizeSrc(_media.$props.src()));
      for (const src of $store.sources()) {
        const loader = this._loaders().find((loader2) => loader2.canPlay(src));
        if (loader) {
          $store.source.set(src);
          $store.mediaType.set(loader.mediaType(src));
          this._loader.set(loader);
        }
      }
      return;
    }
  }
  _onSourcesChange() {
    this._media.delegate._dispatch("sources-change", {
      detail: [...normalizeSrc(this._media.$props.src()), ...this._domSources()]
    });
  }
  _onSourceChange() {
    var _a;
    const { $store } = this._media;
    const sources = $store.sources(), currentSource = peek($store.source), newSource = this._findNewSource(currentSource, sources), noMatch = ((_a = sources[0]) == null ? void 0 : _a.src) && !newSource.src && !newSource.type;
    if (noMatch) {
      const { crossorigin } = $store, credentials = getRequestCredentials(crossorigin()), abort = new AbortController();
      Promise.all(
        sources.map(
          (source) => isString(source.src) && source.type === "?" ? fetch(source.src, {
            method: "HEAD",
            credentials,
            signal: abort.signal
          }).then((res) => {
            source.type = res.headers.get("content-type") || "??";
            return source;
          }).catch(() => source) : source
        )
      ).then((sources2) => {
        if (abort.signal.aborted)
          return;
        this._findNewSource(peek($store.source), sources2);
        tick();
      });
      return () => abort.abort();
    }
    tick();
  }
  _findNewSource(currentSource, sources) {
    let newSource = { src: "", type: "" }, newLoader = null;
    for (const src of sources) {
      const loader = peek(this._loaders).find((loader2) => loader2.canPlay(src));
      if (loader) {
        newSource = src;
        newLoader = loader;
      }
    }
    this._notifySourceChange(currentSource, newSource, newLoader);
    this._notifyLoaderChange(peek(this._loader), newLoader);
    return newSource;
  }
  _notifySourceChange(currentSource, newSource, newLoader) {
    if (newSource.src === currentSource.src && newSource.type === currentSource.type)
      return;
    this._media.delegate._dispatch("source-change", { detail: newSource });
    this._media.delegate._dispatch("media-type-change", {
      detail: (newLoader == null ? void 0 : newLoader.mediaType(newSource)) || "unknown"
    });
  }
  _notifyLoaderChange(currentLoader, newLoader) {
    if (newLoader === currentLoader)
      return;
    this._media.delegate._dispatch("provider-change", { detail: null });
    newLoader && peek(() => {
      var _a;
      return (_a = newLoader.preconnect) == null ? void 0 : _a.call(newLoader, this._media);
    });
    this._loader.set(newLoader);
    this._media.delegate._dispatch("provider-loader-change", { detail: newLoader });
  }
  _onPreconnect() {
    const provider = this._media.$provider();
    if (!provider)
      return;
    if (this._media.$store.canLoad()) {
      peek(
        () => provider.setup({
          ...this._media,
          player: this._media.player
        })
      );
      return;
    }
    peek(() => {
      var _a;
      return (_a = provider.preconnect) == null ? void 0 : _a.call(provider, this._media);
    });
  }
  _onLoadSource() {
    const provider = this._media.$provider(), source = this._media.$store.source();
    if (this._media.$store.canLoad()) {
      peek(() => provider == null ? void 0 : provider.loadSource(source, peek(this._media.$store.preload)));
      return;
    }
    try {
      isString(source.src) && preconnect(new URL(source.src).origin, "preconnect");
    } catch (e) {
    }
  }
};
function normalizeSrc(src) {
  return (isArray(src) ? src : [!isString(src) && "src" in src ? src : { src }]).map(
    ({ src: src2, type }) => ({
      src: src2,
      type: type ?? (!isString(src2) || src2.startsWith("blob:") ? "video/object" : "?")
    })
  );
}
var Tracks = class {
  constructor(_domTracks, _media) {
    this._domTracks = _domTracks;
    this._media = _media;
    this._prevTracks = [];
    effect(this._onTracksChange.bind(this));
  }
  _onTracksChange() {
    const newTracks = [...this._media.$props.textTracks(), ...this._domTracks()];
    for (const oldTrack of this._prevTracks) {
      if (!newTracks.some((t) => t.id === oldTrack.id)) {
        const track = oldTrack.id && this._media.textTracks.getById(oldTrack.id);
        if (track)
          this._media.textTracks.remove(track);
      }
    }
    for (const newTrack of newTracks) {
      const id = newTrack.id || TextTrack.createId(newTrack);
      if (!this._media.textTracks.getById(id)) {
        newTrack.id = id;
        this._media.textTracks.add(newTrack);
      }
    }
    this._prevTracks = newTracks;
  }
};

// src/player/core/outlet/outlet.tsx
var Outlet = class extends Component {
  constructor(instance) {
    super(instance);
    this._domSources = signal([]);
    this._domTracks = signal([]);
    this._loader = signal(null);
    this._media = useMedia();
    new SourceSelection(this._domSources, this._media, this._loader);
    new Tracks(this._domTracks, this._media);
  }
  onAttach(el) {
    el.setAttribute("keep-alive", "");
  }
  onConnect(el) {
    const resize = new ResizeObserver(animationFrameThrottle(this._onResize.bind(this)));
    resize.observe(el);
    const mutation = new MutationObserver(this._onMutation.bind(this));
    mutation.observe(el, { attributes: true, childList: true });
    if (IS_SAFARI) {
      listenEvent(el, "touchstart", (e) => e.preventDefault(), { passive: false });
    }
    scopedRaf(() => {
      this._onResize();
      this._onMutation();
    });
    return () => {
      resize.disconnect();
      mutation.disconnect();
    };
  }
  onDestroy() {
    this._media.$store.currentTime.set(0);
  }
  _onResize() {
    const player = this._media.player, width = this.el.offsetWidth, height = this.el.offsetHeight;
    if (!player)
      return;
    player.$store.mediaWidth.set(width);
    player.$store.mediaHeight.set(height);
    setStyle(player, "--media-width", width + "px");
    setStyle(player, "--media-height", height + "px");
  }
  _onMutation() {
    const sources = [], tracks = [], children = this.el.children;
    for (const el of children) {
      if (el instanceof HTMLSourceElement) {
        sources.push({
          src: el.src,
          type: el.type
        });
      } else if (el instanceof HTMLTrackElement) {
        tracks.push({
          id: el.id,
          src: el.src,
          kind: el.track.kind,
          language: el.srclang,
          label: el.label,
          default: el.default,
          type: el.getAttribute("data-type")
        });
      }
    }
    this._domSources.set(sources);
    this._domTracks.set(tracks);
    tick();
  }
  render() {
    let currentProvider;
    onDispose(() => {
      var _a;
      return (_a = currentProvider == null ? void 0 : currentProvider.destroy) == null ? void 0 : _a.call(currentProvider);
    });
    return () => {
      currentProvider == null ? void 0 : currentProvider.destroy();
      const loader = this._loader();
      if (!loader)
        return null;
      const el = loader.render(this._media.$store);
      peek(() => {
        loader.load(this._media).then((provider) => {
          if (peek(this._loader) !== loader)
            return;
          this._media.delegate._dispatch("provider-change", {
            detail: provider
          });
          currentProvider = provider;
        });
      });
      return el;
    };
  }
};
Outlet.el = defineElement({
  tagName: "media-outlet"
});

export { Outlet };
