import { AUDIO_PROVIDER } from './chunk-H3U4YXTB.js';
import { HLS_PROVIDER, SET_AUTO_QUALITY, ENABLE_AUTO_QUALITY, coerceToError } from './chunk-2CNJRAGE.js';
import { VIDEO_PROVIDER } from './chunk-W4CS7QKB.js';
import { LIST_READONLY, LIST_ADD, LIST_REMOVE, LIST_ON_REMOVE, LIST_RESET, LIST_SET_READONLY, LIST_ON_RESET, LIST_ON_USER_SELECT, LIST_SELECT } from './chunk-TTEXQSM2.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { canOrientScreen, IS_IPHONE } from './chunk-M727CDUQ.js';
import { clampNumber } from './chunk-N2X5VJTG.js';
import { isTrackCaptionKind, ATTACH_VIDEO, TEXT_TRACK_NATIVE_HLS, TextTrack, TEXT_TRACK_CROSSORIGIN, TEXT_TRACK_CAN_LOAD, TEXT_TRACK_ON_MODE_CHANGE, TEXT_TRACK_NATIVE, TEXT_TRACK_UPDATE_ACTIVE_CUES } from './chunk-ZG64VF3W.js';
import { getRequestCredentials } from './chunk-72VYJ2OF.js';
import { setAttributeIfEmpty } from './chunk-JTTKMFDW.js';
import { mediaContext, useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-RLGAJ5QB.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { EventsTarget, DOMEvent, listenEvent, isArray, isUndefined, isKeyboardEvent, setAttribute, uppercaseFirstChar, camelToKebabCase, isKeyboardClick, deferredPromise, appendTriggerEvent, noop } from 'maverick.js/std';
import { defineProp, defineElement, prop, method, ComponentController, Component } from 'maverick.js/element';
import { StoreFactory, signal, peek, tick, effect, onDispose, getScope, computed, provideContext } from 'maverick.js';

var _a;
var List = class extends EventsTarget {
  constructor() {
    super(...arguments);
    this._items = [];
    /* @internal */
    this[_a] = false;
  }
  get length() {
    return this._items.length;
  }
  get readonly() {
    return this[LIST_READONLY];
  }
  /**
   * Transform list to an array.
   */
  toArray() {
    return [...this._items];
  }
  [(_a = LIST_READONLY, Symbol.iterator)]() {
    return this._items.values();
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    const index = this._items.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this._items[index];
        }
      });
    }
    if (this._items.includes(item))
      return;
    this._items.push(item);
    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
  }
  /* @internal */
  [LIST_REMOVE](item, trigger) {
    var _a2;
    const index = this._items.indexOf(item);
    if (index >= 0) {
      (_a2 = this[LIST_ON_REMOVE]) == null ? void 0 : _a2.call(this, item, trigger);
      this._items.splice(index, 1);
      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
    }
  }
  /* @internal */
  [LIST_RESET](trigger) {
    var _a2;
    for (const item of [...this._items])
      this[LIST_REMOVE](item, trigger);
    this._items = [];
    this[LIST_SET_READONLY](false, trigger);
    (_a2 = this[LIST_ON_RESET]) == null ? void 0 : _a2.call(this);
  }
  /* @internal */
  [LIST_SET_READONLY](readonly, trigger) {
    if (this[LIST_READONLY] === readonly)
      return;
    this[LIST_READONLY] = readonly;
    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
  }
};

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document2[vendor[key.exitFullscreen]].bind(document2);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document2.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document2.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document2[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document2[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;
var CAN_FULLSCREEN = fscreen_esm_default.fullscreenEnabled;
var FullscreenController = class extends ComponentController {
  constructor() {
    super(...arguments);
    /**
     * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
     * listened to globally on the document so we need to know if they relate to the current host
     * element or not.
     */
    this._listening = false;
    this._active = false;
  }
  get active() {
    return this._active;
  }
  get supported() {
    return CAN_FULLSCREEN;
  }
  onConnect() {
    listenEvent(fscreen_esm_default, "fullscreenchange", this._onFullscreenChange.bind(this));
    listenEvent(fscreen_esm_default, "fullscreenerror", this._onFullscreenError.bind(this));
  }
  async onDisconnect() {
    if (CAN_FULLSCREEN)
      await this.exit();
  }
  _onFullscreenChange(event) {
    const active = isFullscreen(this.el);
    if (active === this._active)
      return;
    if (!active)
      this._listening = false;
    this._active = active;
    this.dispatch("fullscreen-change", { detail: active, trigger: event });
  }
  _onFullscreenError(event) {
    if (!this._listening)
      return;
    this.dispatch("fullscreen-error", { detail: null, trigger: event });
    this._listening = false;
  }
  async enter() {
    try {
      this._listening = true;
      if (!this.el || isFullscreen(this.el))
        return;
      assertFullscreenAPI();
      return fscreen_esm_default.requestFullscreen(this.el);
    } catch (error) {
      this._listening = false;
      throw error;
    }
  }
  async exit() {
    if (!this.el || !isFullscreen(this.el))
      return;
    assertFullscreenAPI();
    return fscreen_esm_default.exitFullscreen();
  }
};
function canFullscreen() {
  return CAN_FULLSCREEN;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
function assertFullscreenAPI() {
  if (CAN_FULLSCREEN)
    return;
  throw Error(
    "[vidstack] no fullscreen API"
  );
}
var CAN_USE_SCREEN_ORIENTATION_API = canOrientScreen();
var ScreenOrientationController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._type = signal(getScreenOrientation());
    this._locked = signal(false);
  }
  /**
   * The current screen orientation type.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get type() {
    return this._type();
  }
  /**
   * Whether the screen orientation is currently locked.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get locked() {
    return this._locked();
  }
  /**
   * Whether the viewport is in a portrait orientation.
   *
   * @signal
   */
  get portrait() {
    return this._type().startsWith("portrait");
  }
  /**
   * Whether the viewport is in a landscape orientation.
   *
   * @signal
   */
  get landscape() {
    return this._type().startsWith("landscape");
  }
  /**
   * Whether the native Screen Orientation API is available.
   */
  get supported() {
    return CAN_USE_SCREEN_ORIENTATION_API;
  }
  onConnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API) {
      listenEvent(screen.orientation, "change", this._onOrientationChange.bind(this));
    } else {
      const query = window.matchMedia("(orientation: landscape)");
      query.onchange = this._onOrientationChange.bind(this);
      return () => query.onchange = null;
    }
  }
  async onDisconnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API && this._locked())
      await this.unlock();
  }
  _onOrientationChange(event) {
    this._type.set(getScreenOrientation());
    this.dispatch("orientation-change", {
      detail: {
        orientation: peek(this._type),
        lock: this._currentLock
      },
      trigger: event
    });
  }
  /**
   * Locks the orientation of the screen to the desired orientation type using the
   * Screen Orientation API.
   *
   * @param lockType - The screen lock orientation type.
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async lock(lockType) {
    if (peek(this._locked) || this._currentLock === lockType)
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    this._locked.set(true);
    this._currentLock = lockType;
  }
  /**
   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
   * API. This method will throw an error if the API is unavailable.
   *
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async unlock() {
    if (!peek(this._locked))
      return;
    assertScreenOrientationAPI();
    this._currentLock = void 0;
    await screen.orientation.unlock();
    this._locked.set(false);
  }
};
function assertScreenOrientationAPI() {
  if (CAN_USE_SCREEN_ORIENTATION_API)
    return;
  throw Error(
    "[vidstack] no orientation API"
  );
}
function getScreenOrientation() {
  return "portrait-primary";
}

// src/player/core/providers/type-check.ts
function isAudioProvider(provider) {
  return !!(provider == null ? void 0 : provider[AUDIO_PROVIDER]);
}
function isVideoProvider(provider) {
  return !!(provider == null ? void 0 : provider[VIDEO_PROVIDER]);
}
function isHLSProvider(provider) {
  return !!(provider == null ? void 0 : provider[HLS_PROVIDER]);
}
function isHTMLAudioElement(element) {
  return false;
}
function isHTMLVideoElement(element) {
  return false;
}
function isHTMLMediaElement(element) {
  return isHTMLVideoElement();
}
var MEDIA_KEY_SHORTCUTS = {
  togglePaused: "k Space",
  toggleMuted: "m",
  toggleFullscreen: "f",
  togglePictureInPicture: "i",
  toggleCaptions: "c",
  seekBackward: "ArrowLeft",
  seekForward: "ArrowRight",
  volumeUp: "ArrowUp",
  volumeDown: "ArrowDown"
};
var MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Control"]);
var BUTTON_SELECTORS = 'button, [role="button"]';
var IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"]';
var MediaKeyboardController = class extends ComponentController {
  constructor(instance, _media) {
    super(instance);
    this._media = _media;
    this._timeSlider = null;
  }
  onConnect() {
    effect(this._onTargetChange.bind(this));
  }
  _onTargetChange() {
    const { keyDisabled, keyTarget } = this.$props;
    if (keyDisabled())
      return;
    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
    if (target === this.el) {
      this.listen("focusin", () => $active.set(true));
      this.listen("focusout", (event) => {
        if (!this.el.contains(event.target))
          $active.set(false);
      });
    } else {
      if (!peek($active))
        $active.set(document.querySelector("media-player") === this.el);
      listenEvent(document, "focusin", (event) => {
        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
        if (activePlayer !== void 0)
          $active.set(this.el === activePlayer);
      });
    }
    effect(() => {
      if (!$active())
        return;
      listenEvent(target, "keyup", this._onKeyUp.bind(this));
      listenEvent(target, "keydown", this._onKeyDown.bind(this));
      listenEvent(target, "keydown", this._onPreventVideoKeys.bind(this), { capture: true });
    });
  }
  _onKeyUp(event) {
    const focused = document.activeElement, sliderFocused = focused == null ? void 0 : focused.hasAttribute("data-media-slider");
    if (!event.key || !this.$store.canSeek() || sliderFocused || (focused == null ? void 0 : focused.matches(IGNORE_SELECTORS))) {
      return;
    }
    const method2 = this._getMatchingMethod(event);
    if (method2 == null ? void 0 : method2.startsWith("seek")) {
      event.preventDefault();
      event.stopPropagation();
      if (this._timeSlider) {
        this._forwardTimeKeyboardEvent(event);
        this._timeSlider = null;
      } else {
        this._media.remote.seek(this._seekTotal, event);
        this._seekTotal = void 0;
      }
    }
    if (method2 == null ? void 0 : method2.startsWith("volume")) {
      const volumeSlider = this.el.querySelector("media-volume-slider");
      volumeSlider == null ? void 0 : volumeSlider.dispatchEvent(new DOMEvent("keyup", { trigger: event }));
    }
  }
  _onKeyDown(event) {
    var _a2, _b;
    if (!event.key || MODIFIER_KEYS.has(event.key))
      return;
    const focused = document.activeElement;
    if ((focused == null ? void 0 : focused.matches(IGNORE_SELECTORS)) || isKeyboardClick(event) && (focused == null ? void 0 : focused.matches(BUTTON_SELECTORS))) {
      return;
    }
    const sliderFocused = focused == null ? void 0 : focused.hasAttribute("data-media-slider"), method2 = this._getMatchingMethod(event);
    if (!method2 && !event.metaKey && /[0-9]/.test(event.key) && !sliderFocused) {
      event.preventDefault();
      event.stopPropagation();
      this._media.remote.seek(this.$store.duration() / 10 * Number(event.key), event);
      return;
    }
    if (!method2 || /volume|seek/.test(method2) && sliderFocused)
      return;
    event.preventDefault();
    event.stopPropagation();
    switch (method2) {
      case "seekForward":
      case "seekBackward":
        this._seeking(event, method2);
        break;
      case "volumeUp":
      case "volumeDown":
        const volumeSlider = this.el.querySelector("media-volume-slider");
        if (volumeSlider) {
          volumeSlider.dispatchEvent(new DOMEvent("keydown", { trigger: event }));
        } else {
          const value = event.shiftKey ? 0.1 : 0.05;
          this._media.remote.changeVolume(
            this.$store.volume() + (method2 === "volumeUp" ? +value : -value),
            event
          );
        }
        break;
      case "toggleFullscreen":
        this._media.remote.toggleFullscreen("prefer-media", event);
        break;
      default:
        (_b = (_a2 = this._media.remote)[method2]) == null ? void 0 : _b.call(_a2, event);
    }
  }
  _onPreventVideoKeys(event) {
    if (isHTMLMediaElement(event.target) ) ;
  }
  _getMatchingMethod(event) {
    const keyShortcuts = {
      ...this.$props.keyShortcuts(),
      ...this._media.ariaKeys
    };
    return Object.keys(keyShortcuts).find(
      (method2) => keyShortcuts[method2].split(" ").some(
        (keys) => replaceSymbolKeys(keys).replace(/Control/g, "Ctrl").split("+").every(
          (key2) => MODIFIER_KEYS.has(key2) ? event[key2.toLowerCase() + "Key"] : event.key === key2.replace("Space", " ")
        )
      )
    );
  }
  _calcSeekAmount(event, type) {
    const seekBy = event.shiftKey ? 10 : 5;
    return this._seekTotal = Math.max(
      0,
      Math.min(
        (this._seekTotal ?? this.$store.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
        this.$store.duration()
      )
    );
  }
  _forwardTimeKeyboardEvent(event) {
    var _a2;
    (_a2 = this._timeSlider) == null ? void 0 : _a2.dispatchEvent(new DOMEvent(event.type, { trigger: event }));
  }
  _seeking(event, type) {
    if (!this.$store.canSeek())
      return;
    if (!this._timeSlider)
      this._timeSlider = this.el.querySelector("media-time-slider");
    if (this._timeSlider) {
      this._forwardTimeKeyboardEvent(event);
    } else {
      this._media.remote.seeking(this._calcSeekAmount(event, type), event);
    }
  }
};
var SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
function replaceSymbolKeys(key2) {
  return key2.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
}
var mediaPlayerProps = {
  autoplay: false,
  aspectRatio: defineProp({
    value: null,
    type: {
      from(value) {
        if (!value)
          return null;
        if (!value.includes("/"))
          return +value;
        const [width, height] = value.split("/").map(Number);
        return +(width / height).toFixed(4);
      }
    }
  }),
  controls: false,
  currentTime: 0,
  crossorigin: null,
  fullscreenOrientation: "landscape",
  load: "visible",
  logLevel: "silent",
  loop: false,
  muted: false,
  paused: true,
  playsinline: false,
  playbackRate: 1,
  poster: "",
  preload: "metadata",
  preferNativeHLS: defineProp({
    value: false,
    attribute: "prefer-native-hls"
  }),
  src: "",
  userIdleDelay: 2e3,
  viewType: "unknown",
  streamType: "unknown",
  volume: 1,
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  keyDisabled: false,
  keyTarget: "player",
  keyShortcuts: MEDIA_KEY_SHORTCUTS,
  title: "",
  thumbnails: null,
  textTracks: defineProp({
    value: [],
    attribute: false
  }),
  smallBreakpointX: 600,
  largeBreakpointX: 980,
  smallBreakpointY: 380,
  largeBreakpointY: 600
};
var TimeRange = class {
  get length() {
    return this._ranges.length;
  }
  constructor(start, end) {
    if (isArray(start)) {
      this._ranges = start;
    } else if (!isUndefined(start) && !isUndefined(end)) {
      this._ranges = [[start, end]];
    } else {
      this._ranges = [];
    }
  }
  start(index) {
    return this._ranges[index][0] ?? Infinity;
  }
  end(index) {
    return this._ranges[index][1] ?? Infinity;
  }
};
function getTimeRangesStart(range) {
  if (!range.length)
    return null;
  let min = range.start(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(range) {
  if (!range.length)
    return null;
  let max = range.end(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
var MediaStoreFactory = new StoreFactory({
  audioTracks: [],
  audioTrack: null,
  autoplay: false,
  autoplayError: void 0,
  buffered: new TimeRange(),
  duration: 0,
  canLoad: false,
  canFullscreen: false,
  canPictureInPicture: false,
  canPlay: false,
  controls: false,
  crossorigin: null,
  poster: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  loop: false,
  logLevel: "silent",
  mediaType: "unknown",
  muted: false,
  paused: true,
  played: new TimeRange(),
  playing: false,
  playsinline: false,
  pictureInPicture: false,
  preload: "metadata",
  playbackRate: 1,
  qualities: [],
  quality: null,
  autoQuality: false,
  canSetQuality: true,
  seekable: new TimeRange(),
  seeking: false,
  source: { src: "", type: "" },
  sources: [],
  started: false,
  title: "",
  textTracks: [],
  textTrack: null,
  thumbnails: null,
  thumbnailCues: [],
  volume: 1,
  waiting: false,
  get viewType() {
    return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
  },
  get streamType() {
    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
  },
  get currentSrc() {
    return this.source;
  },
  get bufferedStart() {
    return getTimeRangesStart(this.buffered) ?? 0;
  },
  get bufferedEnd() {
    return getTimeRangesEnd(this.buffered) ?? 0;
  },
  get seekableStart() {
    return getTimeRangesStart(this.seekable) ?? 0;
  },
  get seekableEnd() {
    return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
  },
  get seekableWindow() {
    return Math.max(0, this.seekableEnd - this.seekableStart);
  },
  // ~~ responsive design ~~
  touchPointer: false,
  orientation: "landscape",
  mediaWidth: 0,
  mediaHeight: 0,
  breakpointX: "sm",
  breakpointY: "sm",
  // ~~ user props ~~
  userIdle: false,
  userBehindLiveEdge: false,
  // ~~ live props ~~
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  get canSeek() {
    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
  },
  get live() {
    return this.streamType.includes("live") || !Number.isFinite(this.duration);
  },
  get liveEdgeStart() {
    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
  },
  get liveEdge() {
    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
  },
  get liveEdgeWindow() {
    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
  },
  // ~~ internal props ~~
  autoplaying: false,
  providedViewType: "unknown",
  providedStreamType: "unknown",
  inferredStreamType: "unknown",
  liveSyncPosition: null
});
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "breakpointX",
  "breakpointY",
  "canFullscreen",
  "canLoad",
  "canPictureInPicture",
  "controls",
  "fullscreen",
  "logLevel",
  "loop",
  "mediaHeight",
  "mediaWidth",
  "muted",
  "orientation",
  "pictureInPicture",
  "playsinline",
  "poster",
  "preload",
  "providedStreamType",
  "providedViewType",
  "source",
  "sources",
  "textTrack",
  "textTracks",
  "thumbnailCues",
  "thumbnails",
  "title",
  "touchPointer",
  "volume"
]);
function softResetMediaStore($media) {
  MediaStoreFactory.reset($media, (prop2) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop2));
  tick();
}
var SELECTED = Symbol(0);
var SelectList = class extends List {
  get selected() {
    return this._items.find((item) => item.selected) ?? null;
  }
  get selectedIndex() {
    return this._items.findIndex((item) => item.selected);
  }
  /* @internal */
  [LIST_ON_REMOVE](item, trigger) {
    this[LIST_SELECT](item, false, trigger);
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    item[SELECTED] = false;
    Object.defineProperty(item, "selected", {
      get() {
        return this[SELECTED];
      },
      set: (selected) => {
        var _a2;
        if (this.readonly)
          return;
        (_a2 = this[LIST_ON_USER_SELECT]) == null ? void 0 : _a2.call(this);
        this[LIST_SELECT](item, selected);
      }
    });
    super[LIST_ADD](item, trigger);
  }
  /* @internal */
  [LIST_SELECT](item, selected, trigger) {
    if (selected === item[SELECTED])
      return;
    const prev = this.selected;
    item[SELECTED] = selected;
    const changed = !selected ? prev === item : prev !== item;
    if (changed) {
      if (prev)
        prev[SELECTED] = false;
      this.dispatchEvent(
        new DOMEvent("change", {
          detail: { prev, current: this.selected },
          trigger
        })
      );
    }
  }
};

// src/player/core/quality/video-quality.ts
var VideoQualityList = class extends SelectList {
  constructor() {
    super(...arguments);
    this._auto = false;
    /**
     * Configures quality switching:
     *
     * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
     * request if any, flush the whole buffer, and fetch fragment matching with current position
     * and requested quality level.
     *
     * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
     * already buffered next fragment.
     *
     * - `load`: Set quality level for next loaded fragment.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/quality#switch}
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
     */
    this.switch = "current";
  }
  /**
   * Whether automatic quality selection is enabled.
   */
  get auto() {
    return this._auto || this.readonly;
  }
  /* @internal */
  [(LIST_ON_USER_SELECT)]() {
    this[SET_AUTO_QUALITY](false);
  }
  /* @internal */
  [LIST_ON_RESET](trigger) {
    this[SET_AUTO_QUALITY](false, trigger);
  }
  /**
   * Request automatic quality selection (if supported). This will be a no-op if the list is
   * `readonly` as that already implies auto-selection.
   */
  autoSelect(trigger) {
    if (this.readonly || this._auto || !this[ENABLE_AUTO_QUALITY])
      return;
    this[ENABLE_AUTO_QUALITY]();
    this[SET_AUTO_QUALITY](true, trigger);
  }
  /* @internal */
  [SET_AUTO_QUALITY](auto, trigger) {
    if (this._auto === auto)
      return;
    this._auto = auto;
    this.dispatchEvent(
      new DOMEvent("auto-change", {
        detail: auto,
        trigger
      })
    );
  }
};
var MediaUserController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this._idleTimer = -2;
    this._delay = 2e3;
    this._pausedTracking = false;
    this._focusedItem = null;
  }
  /**
   * Whether the media user is currently idle.
   */
  get idling() {
    return this.$store.userIdle();
  }
  /**
   * The amount of delay in milliseconds while media playback is progressing without user
   * activity to indicate an idle state.
   *
   * @defaultValue 2000
   */
  get idleDelay() {
    return this._delay;
  }
  set idleDelay(newDelay) {
    this._delay = newDelay;
  }
  /**
   * Change the user idle state.
   */
  idle(idle, delay = this._delay, trigger) {
    this._clearIdleTimer();
    if (!this._pausedTracking)
      this._requestIdleChange(idle, delay, trigger);
  }
  /**
   * Whether all idle tracking should be paused until resumed again.
   */
  pauseIdleTracking(paused, trigger) {
    this._pausedTracking = paused;
    if (paused) {
      this._clearIdleTimer();
      this._requestIdleChange(false, 0, trigger);
    }
  }
  onConnect() {
    effect(this._watchPaused.bind(this));
    listenEvent(this.el, "play", this._onMediaPlay.bind(this));
    listenEvent(this.el, "pause", this._onMediaPause.bind(this));
  }
  _watchPaused() {
    if (this.$store.paused())
      return;
    const onStopIdle = this._onStopIdle.bind(this);
    for (const eventType of ["pointerup", "keydown"]) {
      listenEvent(this.el, eventType, onStopIdle);
    }
    effect(() => {
      if (!this.$store.touchPointer())
        listenEvent(this.el, "pointermove", onStopIdle);
    });
  }
  _onMediaPlay(event) {
    this.idle(true, this._delay, event);
  }
  _onMediaPause(event) {
    this.idle(false, 0, event);
  }
  _clearIdleTimer() {
    window.clearTimeout(this._idleTimer);
    this._idleTimer = -1;
  }
  _onStopIdle(event) {
    var _a2;
    if (event.MEDIA_GESTURE)
      return;
    if (isKeyboardEvent(event)) {
      if (event.key === "Escape") {
        (_a2 = this.el) == null ? void 0 : _a2.focus();
        this._focusedItem = null;
      } else if (this._focusedItem) {
        event.preventDefault();
        requestAnimationFrame(() => {
          var _a3;
          (_a3 = this._focusedItem) == null ? void 0 : _a3.focus();
          this._focusedItem = null;
        });
      }
    }
    this.idle(false, 0, event);
    this.idle(true, this._delay, event);
  }
  _requestIdleChange(idle, delay, trigger) {
    if (delay === 0) {
      this._onIdleChange(idle, trigger);
      return;
    }
    this._idleTimer = window.setTimeout(() => {
      this._onIdleChange(idle && !this._pausedTracking, trigger);
    }, delay);
  }
  _onIdleChange(idle, trigger) {
    var _a2;
    if (this.$store.userIdle() === idle)
      return;
    this.$store.userIdle.set(idle);
    if (idle && document.activeElement && ((_a2 = this.el) == null ? void 0 : _a2.contains(document.activeElement))) {
      this._focusedItem = document.activeElement;
      requestAnimationFrame(() => {
        var _a3;
        return (_a3 = this.el) == null ? void 0 : _a3.focus();
      });
    }
    this.dispatch("user-idle-change", {
      detail: idle,
      trigger
    });
  }
};
var MediaRemoteControl = class {
  constructor(_logger) {
    this._logger = _logger;
    this._target = null;
    this._player = null;
    this._prevTrackIndex = -1;
  }
  /**
   * Set the target from which to dispatch media requests events from. The events should bubble
   * up from this target to the `<media-player>` element.
   *
   * @example
   * ```ts
   * const button = document.querySelector('button');
   * remote.setTarget(button);
   * ```
   */
  setTarget(target) {
    this._target = target;
  }
  /**
   * Returns the current `<media-player>` element. This method will attempt to find the player by
   * searching up from either the given `target` or default target set via `remote.setTarget`.
   *
   * @example
   * ```ts
   * const player = remote.getPlayer();
   * ```
   */
  getPlayer(target) {
    var _a2;
    if (this._player)
      return this._player;
    (_a2 = target ?? this._target) == null ? void 0 : _a2.dispatchEvent(
      new DOMEvent("find-media-player", {
        detail: (player) => void (this._player = player),
        bubbles: true,
        composed: true
      })
    );
    return this._player;
  }
  /**
   * Set the current `<media-player>` element so the remote can support toggle methods such as
   * `togglePaused` as they rely on the current media state.
   */
  setPlayer(player) {
    this._player = player;
  }
  /**
   * Dispatch a request to start the media loading process. This will only work if the media
   * player has been initialized with a custom loading strategy `<media-player load="custom">`.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#loading-strategies}
   */
  startLoading(trigger) {
    this._dispatchRequest("media-start-loading", trigger);
  }
  /**
   * Dispatch a request to begin/resume media playback.
   */
  play(trigger) {
    this._dispatchRequest("media-play-request", trigger);
  }
  /**
   * Dispatch a request to pause media playback.
   */
  pause(trigger) {
    this._dispatchRequest("media-pause-request", trigger);
  }
  /**
   * Dispatch a request to set the media volume to mute (0).
   */
  mute(trigger) {
    this._dispatchRequest("media-mute-request", trigger);
  }
  /**
   * Dispatch a request to unmute the media volume and set it back to it's previous state.
   */
  unmute(trigger) {
    this._dispatchRequest("media-unmute-request", trigger);
  }
  /**
   * Dispatch a request to enter fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  enterFullscreen(target, trigger) {
    this._dispatchRequest("media-enter-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to exit fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  exitFullscreen(target, trigger) {
    this._dispatchRequest("media-exit-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to enter picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  enterPictureInPicture(trigger) {
    this._dispatchRequest("media-enter-pip-request", trigger);
  }
  /**
   * Dispatch a request to exit picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  exitPictureInPicture(trigger) {
    this._dispatchRequest("media-exit-pip-request", trigger);
  }
  /**
   * Notify the media player that a seeking process is happening and to seek to the given `time`.
   */
  seeking(time, trigger) {
    this._dispatchRequest("media-seeking-request", trigger, time);
  }
  /**
   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
   * This is generally called after a series of `remote.seeking()` calls.
   */
  seek(time, trigger) {
    this._dispatchRequest("media-seek-request", trigger, time);
  }
  seekToLiveEdge(trigger) {
    this._dispatchRequest("media-live-edge-request", trigger);
  }
  /**
   * Dispatch a request to update the media volume to the given `volume` level which is a value
   * between 0 and 1.
   *
   * @example
   * ```ts
   * remote.changeVolume(0); // 0%
   * remote.changeVolume(0.05); // 5%
   * remote.changeVolume(0.5); // 50%
   * remote.changeVolume(0.75); // 70%
   * remote.changeVolume(1); // 100%
   * ```
   */
  changeVolume(volume, trigger) {
    this._dispatchRequest("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
  }
  /**
   * Dispatch a request to change the current audio track.
   *
   * @example
   * ```ts
   * remote.changeAudioTrack(1); // track at index 1
   * ```
   */
  changeAudioTrack(index, trigger) {
    this._dispatchRequest("media-audio-track-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
   * selection.
   *
   * @example
   * ```ts
   * remote.changeQuality(-1); // auto
   * remote.changeQuality(1); // quality at index 1
   * ```
   */
  changeQuality(index, trigger) {
    this._dispatchRequest("media-quality-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the mode of the text track at the given index.
   *
   * @example
   * ```ts
   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
   * ```
   */
  changeTextTrackMode(index, mode, trigger) {
    this._dispatchRequest("media-text-track-change-request", trigger, {
      index,
      mode
    });
  }
  /**
   * Dispatch a request to change the media playback rate.
   *
   * @example
   * ```ts
   * remote.changePlaybackRate(0.5); // Half the normal speed
   * remote.changePlaybackRate(1); // Normal speed
   * remote.changePlaybackRate(1.5); // 50% faster than normal
   * remote.changePlaybackRate(2); // Double the normal speed
   * ```
   */
  changePlaybackRate(rate, trigger) {
    this._dispatchRequest("media-rate-change-request", trigger, rate);
  }
  /**
   * Dispatch a request to resume user idle tracking. Refer to {@link MediaRemoteControl.pauseUserIdle}
   * for more information.
   */
  resumeUserIdle(trigger) {
    this._dispatchRequest("media-resume-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to pause user idle tracking. Pausing tracking will result in the `user-idle`
   * attribute and state being `false` until `remote.resumeUserIdle()` is called. This method
   * is generally used when building custom controls and you'd like to prevent the UI from
   * dissapearing.
   *
   * @example
   * ```ts
   * // Prevent user idling while menu is being interacted with.
   * function onSettingsOpen() {
   *   remote.pauseUserIdle();
   * }
   *
   * function onSettingsClose() {
   *   remote.resumeUserIdle();
   * }
   * ```
   */
  pauseUserIdle(trigger) {
    this._dispatchRequest("media-pause-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to toggle the media playback state.
   */
  togglePaused(trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    if (player.state.paused)
      this.play(trigger);
    else
      this.pause(trigger);
  }
  /**
   * Dispatch a request to toggle the user idle state.
   */
  toggleUserIdle(trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    player.user.idle(!player.user.idling, 0, trigger);
  }
  /**
   * Dispatch a request to toggle the media muted state.
   */
  toggleMuted(trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    if (player.state.muted)
      this.unmute(trigger);
    else
      this.mute(trigger);
  }
  /**
   * Dispatch a request to toggle the media fullscreen state.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  toggleFullscreen(target, trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    if (player.state.fullscreen)
      this.exitFullscreen(target, trigger);
    else
      this.enterFullscreen(target, trigger);
  }
  /**
   * Dispatch a request to toggle the media picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  togglePictureInPicture(trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    if (player.state.pictureInPicture)
      this.exitPictureInPicture(trigger);
    else
      this.enterPictureInPicture(trigger);
  }
  /**
   * Dispatch a request to toggle the current captions mode.
   */
  toggleCaptions(trigger) {
    const player = this.getPlayer(trigger == null ? void 0 : trigger.target);
    if (!player) {
      return;
    }
    const tracks = player.state.textTracks, track = player.state.textTrack;
    if (track) {
      const index = tracks.indexOf(track);
      this.changeTextTrackMode(index, "disabled", trigger);
      this._prevTrackIndex = index;
    } else {
      let index = this._prevTrackIndex;
      if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
        index = -1;
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2) && track2.default);
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2));
      }
      if (index >= 0)
        this.changeTextTrackMode(index, "showing", trigger);
      this._prevTrackIndex = -1;
    }
  }
  _dispatchRequest(type, trigger, detail) {
    const request = new DOMEvent(type, {
      bubbles: true,
      composed: true,
      detail,
      trigger
    });
    const shouldUsePlayer = (trigger == null ? void 0 : trigger.target) && (trigger.target === document || trigger.target === window || trigger.target === document.body || this._player && !this._player.contains(trigger.target));
    const target = shouldUsePlayer ? this._target ?? this.getPlayer() : (trigger == null ? void 0 : trigger.target) ?? this._target;
    target == null ? void 0 : target.dispatchEvent(request);
  }
  _noPlayerWarning(method2) {
  }
};

// src/player/core/tracks/audio-tracks.ts
var AudioTrackList = class extends SelectList {
  getById(id) {
    if (id === "")
      return null;
    return this._items.find((track) => track.id === id) ?? null;
  }
};

// src/player/core/tracks/text/render/native-text-renderer.ts
var NativeTextRenderer = class {
  constructor() {
    this.priority = 0;
    this._display = true;
    this._video = null;
    this._track = null;
    this._tracks = /* @__PURE__ */ new Set();
  }
  canRender() {
    return true;
  }
  attach(video) {
    this._video = video;
    if (!video.crossOrigin)
      video.crossOrigin = "anonymous";
    video.textTracks.onchange = this._onChange.bind(this);
  }
  addTrack(track) {
    this._tracks.add(track);
    this._attachTrack(track);
  }
  removeTrack(track) {
    var _a2, _b;
    (_b = (_a2 = track[TEXT_TRACK_NATIVE]) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2);
    track[TEXT_TRACK_NATIVE] = null;
    this._tracks.delete(track);
  }
  changeTrack(track) {
    var _a2;
    const prev = (_a2 = this._track) == null ? void 0 : _a2[TEXT_TRACK_NATIVE], current = track == null ? void 0 : track[TEXT_TRACK_NATIVE];
    if (prev && this._track !== track)
      prev.track.mode = "disabled";
    if (current)
      current.track.mode = "showing";
    this._track = track;
  }
  setDisplay(display) {
    this._display = display;
  }
  detach() {
    if (this._video)
      this._video.textTracks.onchange = null;
    for (const track of this._tracks)
      this.removeTrack(track);
    this._tracks.clear();
    this._video = null;
    this._track = null;
  }
  _attachTrack(track) {
    if (!this._video)
      return;
    const el = track[TEXT_TRACK_NATIVE] ??= this._createTrackElement(track);
    if (el instanceof HTMLElement)
      this._video.append(el);
  }
  _createTrackElement(track) {
    const el = document.createElement("track");
    el.src = "https://cdn.jsdelivr.net/npm/vidstack/empty.vtt";
    el.id = track.id;
    el.label = track.label;
    el.kind = track.kind;
    el.default = track.default;
    track.language && (el.srclang = track.language);
    return el;
  }
  _copyCues(track, native) {
    var _a2;
    if ((_a2 = native.cues) == null ? void 0 : _a2.length)
      return;
    for (const cue of track.cues)
      native.addCue(cue);
  }
  _onChange(event) {
    var _a2;
    for (const track of this._tracks) {
      const nativeTrack = (_a2 = track[TEXT_TRACK_NATIVE]) == null ? void 0 : _a2.track;
      if (!nativeTrack)
        continue;
      if (!this._display) {
        nativeTrack.mode = "disabled";
        continue;
      }
      if (nativeTrack.mode === "showing") {
        this._copyCues(track, nativeTrack);
        track.setMode("showing", event);
      } else if (track.mode === "showing") {
        track.setMode("disabled", event);
      }
    }
  }
};

// src/player/core/tracks/text/render/text-renderer.ts
var TextRenderers = class {
  constructor(_media) {
    this._media = _media;
    this._video = null;
    this._renderers = [];
    this._nativeDisplay = false;
    this._nativeRenderer = null;
    this._customRenderer = null;
    const textTracks = _media.textTracks;
    this._textTracks = textTracks;
    effect(this._watchControls.bind(this));
    onDispose(this._detach.bind(this));
    listenEvent(textTracks, "add", this._onAddTrack.bind(this));
    listenEvent(textTracks, "remove", this._onRemoveTrack.bind(this));
    listenEvent(textTracks, "mode-change", this._update.bind(this));
  }
  _watchControls() {
    const { $store, $iosControls } = this._media;
    this._nativeDisplay = $store.controls() || $iosControls();
    this._update();
  }
  add(renderer) {
    this._renderers.push(renderer);
    this._update();
  }
  remove(renderer) {
    renderer.detach();
    this._renderers.splice(this._renderers.indexOf(renderer), 1);
    this._update();
  }
  /* @internal */
  [ATTACH_VIDEO](video) {
    requestAnimationFrame(() => {
      this._video = video;
      if (video) {
        this._nativeRenderer = new NativeTextRenderer();
        this._nativeRenderer.attach(video);
        for (const track of this._textTracks)
          this._addNativeTrack(track);
      }
      this._update();
    });
  }
  _addNativeTrack(track) {
    var _a2;
    if (!isTrackCaptionKind(track))
      return;
    (_a2 = this._nativeRenderer) == null ? void 0 : _a2.addTrack(track);
  }
  _removeNativeTrack(track) {
    var _a2;
    if (!isTrackCaptionKind(track))
      return;
    (_a2 = this._nativeRenderer) == null ? void 0 : _a2.removeTrack(track);
  }
  _onAddTrack(event) {
    this._addNativeTrack(event.detail);
  }
  _onRemoveTrack(event) {
    this._removeNativeTrack(event.detail);
  }
  _update() {
    var _a2, _b, _c;
    if (!this._video) {
      this._detach();
      return;
    }
    const currentTrack = this._textTracks.selected;
    if (this._nativeDisplay || (currentTrack == null ? void 0 : currentTrack[TEXT_TRACK_NATIVE_HLS])) {
      (_a2 = this._customRenderer) == null ? void 0 : _a2.changeTrack(null);
      this._nativeRenderer.setDisplay(true);
      this._nativeRenderer.changeTrack(currentTrack);
      return;
    }
    this._nativeRenderer.setDisplay(false);
    this._nativeRenderer.changeTrack(null);
    if (!currentTrack) {
      (_b = this._customRenderer) == null ? void 0 : _b.changeTrack(null);
      return;
    }
    const customRenderer = this._renderers.sort((a, b) => a.priority - b.priority).find((loader) => loader.canRender(currentTrack));
    if (this._customRenderer !== customRenderer) {
      (_c = this._customRenderer) == null ? void 0 : _c.detach();
      customRenderer == null ? void 0 : customRenderer.attach(this._video);
      this._customRenderer = customRenderer ?? null;
    }
    customRenderer == null ? void 0 : customRenderer.changeTrack(currentTrack);
  }
  _detach() {
    var _a2, _b;
    (_a2 = this._nativeRenderer) == null ? void 0 : _a2.detach();
    this._nativeRenderer = null;
    (_b = this._customRenderer) == null ? void 0 : _b.detach();
    this._customRenderer = null;
  }
};
var TextTrackList = class extends List {
  constructor() {
    super(...arguments);
    this._canLoad = false;
    this._defaults = {};
    this._onTrackModeChangeBind = this._onTrackModeChange.bind(this);
  }
  get selected() {
    const track = this._items.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
    return track ?? null;
  }
  add(init, trigger) {
    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init);
    if (this._defaults[init.kind] && init.default)
      delete init.default;
    track.addEventListener("mode-change", this._onTrackModeChangeBind);
    this[LIST_ADD](track, trigger);
    track[TEXT_TRACK_CROSSORIGIN] = this[TEXT_TRACK_CROSSORIGIN];
    if (this._canLoad)
      track[TEXT_TRACK_CAN_LOAD]();
    if (init.default) {
      this._defaults[init.kind] = track;
      track.mode = "showing";
    }
    return this;
  }
  remove(track, trigger) {
    if (!this._items.includes(track))
      return;
    if (track === this._defaults[track.kind])
      delete this._defaults[track.kind];
    track.mode = "disabled";
    track[TEXT_TRACK_ON_MODE_CHANGE] = null;
    track.removeEventListener("mode-change", this._onTrackModeChangeBind);
    this[LIST_REMOVE](track, trigger);
    return this;
  }
  clear(trigger) {
    for (const track of this._items)
      this.remove(track, trigger);
    return this;
  }
  getById(id) {
    return this._items.find((track) => track.id === id) ?? null;
  }
  getByKind(kind) {
    const kinds = Array.isArray(kind) ? kind : [kind];
    return this._items.filter((track) => kinds.includes(track.kind));
  }
  /* @internal */
  [(TEXT_TRACK_CAN_LOAD)]() {
    if (this._canLoad)
      return;
    for (const track of this._items)
      track[TEXT_TRACK_CAN_LOAD]();
    this._canLoad = true;
  }
  _onTrackModeChange(event) {
    const track = event.detail;
    if (track.mode === "showing") {
      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
      for (const t of this._items) {
        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
          t.mode = "disabled";
        }
      }
    }
    this.dispatchEvent(
      new DOMEvent("mode-change", {
        detail: event.detail,
        trigger: event
      })
    );
  }
};
var RequestQueue = class {
  constructor() {
    this._serving = false;
    this._pending = deferredPromise();
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * The number of callbacks that are currently in queue.
   */
  get _size() {
    return this._queue.size;
  }
  /**
   * Whether items in the queue are being served immediately, otherwise they're queued to
   * be processed later.
   */
  get _isServing() {
    return this._serving;
  }
  /**
   * Waits for the queue to be flushed (ie: start serving).
   */
  async _waitForFlush() {
    if (this._serving)
      return;
    await this._pending.promise;
  }
  /**
   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
   * then the callback will be invoked immediately.
   *
   * @param key - Uniquely identifies this callback so duplicates are ignored.
   * @param callback - The function to call when this item in the queue is being served.
   */
  _enqueue(key2, callback) {
    if (this._serving) {
      callback();
      return;
    }
    this._queue.delete(key2);
    this._queue.set(key2, callback);
  }
  /**
   * Invokes the callback with the given `key` in the queue (if it exists).
   */
  _serve(key2) {
    var _a2;
    (_a2 = this._queue.get(key2)) == null ? void 0 : _a2();
    this._queue.delete(key2);
  }
  /**
   * Flush all queued items and start serving future requests immediately until `stop()` is called.
   */
  _start() {
    this._flush();
    this._serving = true;
    if (this._queue.size > 0)
      this._flush();
  }
  /**
   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
   */
  _stop() {
    this._serving = false;
  }
  /**
   * Stop serving requests, empty the request queue, and release any promises waiting for the
   * queue to flush.
   */
  _reset() {
    this._stop();
    this._queue.clear();
    this._release();
  }
  _flush() {
    for (const key2 of this._queue.keys())
      this._serve(key2);
    this._release();
  }
  _release() {
    this._pending.resolve();
    this._pending = deferredPromise();
  }
};

// src/player/core/api/media-attrs.ts
var MEDIA_ATTRIBUTES = [
  "autoplay",
  "autoplayError",
  "canFullscreen",
  "canPictureInPicture",
  "canLoad",
  "canPlay",
  "canSeek",
  "ended",
  "error",
  "fullscreen",
  "loop",
  "live",
  "liveEdge",
  "mediaType",
  "muted",
  "paused",
  "pictureInPicture",
  "playing",
  "playsinline",
  "seeking",
  "started",
  "streamType",
  "userIdle",
  "viewType",
  "waiting"
];
var MediaLoadController = class extends ComponentController {
  constructor(instance, _callback) {
    super(instance);
    this._callback = _callback;
  }
  async onAttach(el) {
    return;
  }
};
var MediaPlayerDelegate = class {
  constructor(_handle, _media) {
    this._handle = _handle;
    this._media = _media;
  }
  _dispatch(type, ...init) {
    return;
  }
  async _ready(info, trigger) {
    return;
  }
  async _attemptAutoplay() {
    const { player, $store } = this._media;
    $store.autoplaying.set(true);
    try {
      await player.play();
      this._dispatch("autoplay", { detail: { muted: $store.muted() } });
    } catch (error) {
      this._dispatch("autoplay-fail", {
        detail: {
          muted: $store.muted(),
          error
        }
      });
    } finally {
      $store.autoplaying.set(false);
    }
  }
};

// src/foundation/queue/queue.ts
var Queue = class {
  constructor() {
    this._queue = /* @__PURE__ */ new Map();
  }
  /**
   * Queue the given `item` under the given `key` to be processed at a later time by calling
   * `serve(key)`.
   */
  _enqueue(key2, item) {
    if (!this._queue.has(key2))
      this._queue.set(key2, /* @__PURE__ */ new Set());
    this._queue.get(key2).add(item);
  }
  /**
   * Process all items in queue for the given `key`.
   */
  _serve(key2, callback) {
    const items = this._queue.get(key2);
    if (items)
      for (const item of items)
        callback(item);
    this._queue.delete(key2);
  }
  /**
   * Removes all queued items under the given `key`.
   */
  _delete(key2) {
    this._queue.delete(key2);
  }
  /**
   * The number of items currently queued under the given `key`.
   */
  _size(key2) {
    var _a2;
    return ((_a2 = this._queue.get(key2)) == null ? void 0 : _a2.size) ?? 0;
  }
  /**
   * Clear all items in the queue.
   */
  _reset() {
    this._queue.clear();
  }
};

// src/player/core/state/media-request-manager.ts
var MediaRequestContext = class {
  constructor() {
    this._seeking = false;
    this._looping = false;
    this._replaying = false;
    this._queue = new Queue();
  }
};
var MediaRequestManager = class extends ComponentController {
  constructor(instance, _stateMgr, _request, _media) {
    super(instance);
    this._stateMgr = _stateMgr;
    this._request = _request;
    this._media = _media;
    this._wasPIPActive = false;
    this._store = _media.$store;
    this._provider = _media.$provider;
    this._user = new MediaUserController(instance);
    this._fullscreen = new FullscreenController(instance);
    this._orientation = new ScreenOrientationController(instance);
  }
  onConnect() {
    effect(this._onIdleDelayChange.bind(this));
    effect(this._onFullscreenSupportChange.bind(this));
    effect(this._onPiPSupportChange.bind(this));
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), handle = this._handleRequest.bind(this);
    for (const name of names) {
      if (name.startsWith("media-")) {
        this.listen(name, handle);
      }
    }
    this.listen("fullscreen-change", this._onFullscreenChange.bind(this));
  }
  _handleRequest(event) {
    var _b;
    event.stopPropagation();
    if (peek(this._provider))
      (_b = this[event.type]) == null ? void 0 : _b.call(this, event);
  }
  async _play() {
    return;
  }
  async _pause() {
    return;
  }
  _seekToLiveEdge() {
    return;
  }
  async _enterFullscreen(target = "prefer-media") {
    return;
  }
  async _exitFullscreen(target = "prefer-media") {
    return;
  }
  async _enterPictureInPicture() {
    return;
  }
  async _exitPictureInPicture() {
    return;
  }
  _throwIfPIPNotSupported() {
    if (this._store.canPictureInPicture())
      return;
    throw Error(
      "[vidstack] no pip support"
    );
  }
  _onIdleDelayChange() {
    this._user.idleDelay = this.$props.userIdleDelay();
  }
  _onFullscreenSupportChange() {
    var _a2, _b;
    const { canLoad, canFullscreen: canFullscreen2 } = this._store, supported = this._fullscreen.supported || ((_b = (_a2 = this._provider()) == null ? void 0 : _a2.fullscreen) == null ? void 0 : _b.supported) || false;
    if (canLoad() && peek(canFullscreen2) === supported)
      return;
    canFullscreen2.set(supported);
  }
  _onPiPSupportChange() {
    var _a2, _b;
    const { canLoad, canPictureInPicture } = this._store, supported = ((_b = (_a2 = this._provider()) == null ? void 0 : _a2.pictureInPicture) == null ? void 0 : _b.supported) || false;
    if (canLoad() && peek(canPictureInPicture) === supported)
      return;
    canPictureInPicture.set(supported);
  }
  ["media-audio-track-change-request"](event) {
    if (this._media.audioTracks.readonly) {
      return;
    }
    const index = event.detail, track = this._media.audioTracks[index];
    if (track) {
      this._request._queue._enqueue("audioTrack", event);
      track.selected = true;
    }
  }
  async ["media-enter-fullscreen-request"](event) {
    try {
      this._request._queue._enqueue("fullscreen", event);
      await this._enterFullscreen(event.detail);
    } catch (error) {
      this._onFullscreenError(error);
    }
  }
  async ["media-exit-fullscreen-request"](event) {
    try {
      this._request._queue._enqueue("fullscreen", event);
      await this._exitFullscreen(event.detail);
    } catch (error) {
      this._onFullscreenError(error);
    }
  }
  async _onFullscreenChange(event) {
    if (!event.detail)
      return;
    try {
      const lockType = peek(this.$props.fullscreenOrientation);
      if (this._orientation.supported && !isUndefined(lockType)) {
        await this._orientation.lock(lockType);
      }
    } catch (e) {
    }
  }
  _onFullscreenError(error) {
    this._stateMgr._handle(
      this.createEvent("fullscreen-error", {
        detail: coerceToError(error)
      })
    );
  }
  async ["media-enter-pip-request"](event) {
    try {
      this._request._queue._enqueue("pip", event);
      await this._enterPictureInPicture();
    } catch (error) {
      this._onPictureInPictureError(error);
    }
  }
  async ["media-exit-pip-request"](event) {
    try {
      this._request._queue._enqueue("pip", event);
      await this._exitPictureInPicture();
    } catch (error) {
      this._onPictureInPictureError(error);
    }
  }
  _onPictureInPictureError(error) {
    this._stateMgr._handle(
      this.createEvent("picture-in-picture-error", {
        detail: coerceToError(error)
      })
    );
  }
  ["media-live-edge-request"](event) {
    const { live, liveEdge, canSeek } = this._store;
    if (!live() || liveEdge() || !canSeek())
      return;
    this._request._queue._enqueue("seeked", event);
    try {
      this._seekToLiveEdge();
    } catch (e) {
    }
  }
  ["media-loop-request"]() {
    window.requestAnimationFrame(async () => {
      try {
        this._request._looping = true;
        this._request._replaying = true;
        await this._play();
      } catch (e) {
        this._request._looping = false;
        this._request._replaying = false;
      }
    });
  }
  async ["media-pause-request"](event) {
    if (this._store.paused())
      return;
    try {
      this._request._queue._enqueue("pause", event);
      await this._provider().pause();
    } catch (e) {
      this._request._queue._delete("pause");
    }
  }
  async ["media-play-request"](event) {
    if (!this._store.paused())
      return;
    try {
      this._request._queue._enqueue("play", event);
      await this._provider().play();
    } catch (e) {
      const errorEvent = this.createEvent("play-fail", { detail: coerceToError(e) });
      this._stateMgr._handle(errorEvent);
    }
  }
  ["media-rate-change-request"](event) {
    if (this._store.playbackRate() === event.detail)
      return;
    this._request._queue._enqueue("rate", event);
    this._provider().playbackRate = event.detail;
  }
  ["media-quality-change-request"](event) {
    if (this._media.qualities.readonly) {
      return;
    }
    this._request._queue._enqueue("quality", event);
    const index = event.detail;
    if (index < 0) {
      this._media.qualities.autoSelect(event);
    } else {
      const quality = this._media.qualities[index];
      if (quality) {
        quality.selected = true;
      }
    }
  }
  ["media-resume-user-idle-request"](event) {
    this._request._queue._enqueue("userIdle", event);
    this._user.pauseIdleTracking(false, event);
  }
  ["media-pause-user-idle-request"](event) {
    this._request._queue._enqueue("userIdle", event);
    this._user.pauseIdleTracking(true, event);
  }
  ["media-seek-request"](event) {
    const { seekableStart, seekableEnd, ended, canSeek, live, userBehindLiveEdge } = this._store;
    if (ended())
      this._request._replaying = true;
    this._request._seeking = false;
    this._request._queue._delete("seeking");
    const boundTime = Math.min(Math.max(seekableStart() + 0.1, event.detail), seekableEnd() - 0.1);
    if (!Number.isFinite(boundTime) || !canSeek())
      return;
    this._request._queue._enqueue("seeked", event);
    this._provider().currentTime = boundTime;
    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundTime) >= 2) {
      userBehindLiveEdge.set(true);
    }
  }
  ["media-seeking-request"](event) {
    this._request._queue._enqueue("seeking", event);
    this._store.seeking.set(true);
    this._request._seeking = true;
  }
  ["media-start-loading"](event) {
    if (this._store.canLoad())
      return;
    this._request._queue._enqueue("load", event);
    this._stateMgr._handle(this.createEvent("can-load"));
  }
  ["media-text-track-change-request"](event) {
    const { index, mode } = event.detail, track = this._media.textTracks[index];
    if (track) {
      this._request._queue._enqueue("textTrack", event);
      track.setMode(mode, event);
    }
  }
  ["media-mute-request"](event) {
    if (this._store.muted())
      return;
    this._request._queue._enqueue("volume", event);
    this._provider().muted = true;
  }
  ["media-unmute-request"](event) {
    const { muted, volume } = this._store;
    if (!muted())
      return;
    this._request._queue._enqueue("volume", event);
    this._media.$provider().muted = false;
    if (volume() === 0) {
      this._request._queue._enqueue("volume", event);
      this._provider().volume = 0.25;
    }
  }
  ["media-volume-change-request"](event) {
    const { muted, volume } = this._store;
    const newVolume = event.detail;
    if (volume() === newVolume)
      return;
    this._request._queue._enqueue("volume", event);
    this._provider().volume = newVolume;
    if (newVolume > 0 && muted()) {
      this._request._queue._enqueue("volume", event);
      this._provider().muted = false;
    }
  }
};

// ../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}
var MediaStateManager = class extends ComponentController {
  constructor(instance, _request, _media) {
    super(instance);
    this._request = _request;
    this._media = _media;
    this._trackedEvents = /* @__PURE__ */ new Map();
    this._skipInitialSrcChange = true;
    this._firingWaiting = false;
    this["seeking"] = functionThrottle(
      (event) => {
        const { seeking, currentTime, paused } = this._store;
        seeking.set(true);
        currentTime.set(event.detail);
        this._satisfyRequest("seeking", event);
        if (paused()) {
          this._waitingTrigger = event;
          this._fireWaiting();
        }
      },
      150,
      { leading: true }
    );
    this._fireWaiting = functionDebounce(() => {
      if (!this._waitingTrigger)
        return;
      this._firingWaiting = true;
      const { waiting, playing } = this._store;
      waiting.set(true);
      playing.set(false);
      const event = this.createEvent("waiting", { trigger: this._waitingTrigger });
      this._trackedEvents.set("waiting", event);
      this.el.dispatchEvent(event);
      this._waitingTrigger = void 0;
      this._firingWaiting = false;
    }, 300);
    this._store = _media.$store;
  }
  onAttach(el) {
    el.setAttribute("aria-busy", "true");
  }
  onConnect(el) {
    this._addTextTrackListeners();
    this._addQualityListeners();
    this._addAudioTrackListeners();
    this.listen("fullscreen-change", this["fullscreen-change"].bind(this));
    this.listen("fullscreen-error", this["fullscreen-error"].bind(this));
  }
  _handle(event) {
    var _a2;
    event.type;
    (_a2 = this[event.type]) == null ? void 0 : _a2.call(this, event);
  }
  _resetTracking() {
    this._stopWaiting();
    this._request._replaying = false;
    this._request._looping = false;
    this._firingWaiting = false;
    this._waitingTrigger = void 0;
    this._trackedEvents.clear();
  }
  _satisfyRequest(request, event) {
    this._request._queue._serve(request, (requestEvent) => {
      event.request = requestEvent;
      appendTriggerEvent(event, requestEvent);
    });
  }
  _addTextTrackListeners() {
    this._onTextTracksChange();
    this._onTextTrackModeChange();
    const textTracks = this._media.textTracks;
    listenEvent(textTracks, "add", this._onTextTracksChange.bind(this));
    listenEvent(textTracks, "remove", this._onTextTracksChange.bind(this));
    listenEvent(textTracks, "mode-change", this._onTextTrackModeChange.bind(this));
  }
  _addQualityListeners() {
    const qualities = this._media.qualities;
    listenEvent(qualities, "add", this._onQualitiesChange.bind(this));
    listenEvent(qualities, "remove", this._onQualitiesChange.bind(this));
    listenEvent(qualities, "change", this._onQualityChange.bind(this));
    listenEvent(qualities, "auto-change", this._onAutoQualityChange.bind(this));
    listenEvent(qualities, "readonly-change", this._onCanSetQualityChange.bind(this));
  }
  _addAudioTrackListeners() {
    const audioTracks = this._media.audioTracks;
    listenEvent(audioTracks, "add", this._onAudioTracksChange.bind(this));
    listenEvent(audioTracks, "remove", this._onAudioTracksChange.bind(this));
    listenEvent(audioTracks, "change", this._onAudioTrackChange.bind(this));
  }
  _onTextTracksChange(event) {
    const { textTracks } = this._store;
    textTracks.set(this._media.textTracks.toArray());
    this.dispatch("text-tracks-change", {
      detail: textTracks(),
      trigger: event
    });
  }
  _onTextTrackModeChange(event) {
    if (event)
      this._satisfyRequest("textTrack", event);
    const current = this._media.textTracks.selected, { textTrack } = this._store;
    if (textTrack() !== current) {
      textTrack.set(current);
      this.dispatch("text-track-change", {
        detail: current,
        trigger: event
      });
    }
  }
  _onAudioTracksChange(event) {
    const { audioTracks } = this._store;
    audioTracks.set(this._media.audioTracks.toArray());
    this.dispatch("audio-tracks-change", {
      detail: audioTracks(),
      trigger: event
    });
  }
  _onAudioTrackChange(event) {
    const { audioTrack } = this._store;
    audioTrack.set(this._media.audioTracks.selected);
    this._satisfyRequest("audioTrack", event);
    this.dispatch("audio-track-change", {
      detail: audioTrack(),
      trigger: event
    });
  }
  _onQualitiesChange(event) {
    const { qualities } = this._store;
    qualities.set(this._media.qualities.toArray());
    this.dispatch("qualities-change", {
      detail: qualities(),
      trigger: event
    });
  }
  _onQualityChange(event) {
    const { quality } = this._store;
    quality.set(this._media.qualities.selected);
    this._satisfyRequest("quality", event);
    this.dispatch("quality-change", {
      detail: quality(),
      trigger: event
    });
  }
  _onAutoQualityChange() {
    this._store.autoQuality.set(this._media.qualities.auto);
  }
  _onCanSetQualityChange() {
    this._store.canSetQuality.set(!this._media.qualities.readonly);
  }
  ["provider-change"](event) {
    this._media.$provider.set(event.detail);
  }
  ["autoplay"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play"));
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
    this._store.autoplayError.set(void 0);
  }
  ["autoplay-fail"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play-fail"));
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
    this._store.autoplayError.set(event.detail);
    this._resetTracking();
  }
  ["can-load"](event) {
    this._store.canLoad.set(true);
    this._trackedEvents.set("can-load", event);
    this._satisfyRequest("load", event);
    this._media.textTracks[TEXT_TRACK_CAN_LOAD]();
  }
  ["media-type-change"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    const viewType = this._store.viewType();
    this._store.mediaType.set(event.detail);
    if (viewType !== this._store.viewType()) {
      setTimeout(
        () => this.dispatch("view-type-change", {
          detail: this._store.viewType(),
          trigger: event
        }),
        0
      );
    }
  }
  ["stream-type-change"](event) {
    const { streamType, inferredStreamType } = this._store;
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    inferredStreamType.set(event.detail);
    event.detail = streamType();
  }
  ["rate-change"](event) {
    this._store.playbackRate.set(event.detail);
    this._satisfyRequest("rate", event);
  }
  ["sources-change"](event) {
    this._store.sources.set(event.detail);
  }
  ["source-change"](event) {
    var _a2;
    appendTriggerEvent(event, this._trackedEvents.get("sources-change"));
    this._store.source.set(event.detail);
    (_a2 = this.el) == null ? void 0 : _a2.setAttribute("aria-busy", "true");
    if (this._skipInitialSrcChange) {
      this._skipInitialSrcChange = false;
      return;
    }
    this._media.audioTracks[LIST_RESET](event);
    this._media.qualities[LIST_RESET](event);
    this._resetTracking();
    softResetMediaStore(this._media.$store);
    this._trackedEvents.set(event.type, event);
  }
  ["abort"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
    appendTriggerEvent(event, this._trackedEvents.get("can-load"));
  }
  ["load-start"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("source-change"));
  }
  ["error"](event) {
    this._store.error.set(event.detail);
    appendTriggerEvent(event, this._trackedEvents.get("abort"));
  }
  ["loaded-metadata"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("load-start"));
  }
  ["loaded-data"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("load-start"));
  }
  ["can-play"](event) {
    var _a2, _b;
    if (((_a2 = event.trigger) == null ? void 0 : _a2.type) !== "loadedmetadata") {
      appendTriggerEvent(event, this._trackedEvents.get("loaded-metadata"));
    }
    this._onCanPlayDetail(event.detail);
    (_b = this.el) == null ? void 0 : _b.setAttribute("aria-busy", "false");
  }
  ["can-play-through"](event) {
    this._onCanPlayDetail(event.detail);
    appendTriggerEvent(event, this._trackedEvents.get("can-play"));
  }
  _onCanPlayDetail(detail) {
    const { seekable, seekableEnd, buffered, duration, canPlay } = this._store;
    seekable.set(detail.seekable);
    buffered.set(detail.buffered);
    duration.set(seekableEnd);
    canPlay.set(true);
  }
  ["duration-change"](event) {
    const { live, duration } = this._store, time = event.detail;
    if (!live())
      duration.set(!Number.isNaN(time) ? time : 0);
  }
  ["progress"](event) {
    const { buffered, seekable, live, duration, seekableEnd } = this._store, detail = event.detail;
    buffered.set(detail.buffered);
    seekable.set(detail.seekable);
    if (live()) {
      duration.set(seekableEnd);
      this.dispatch("duration-change", {
        detail: seekableEnd(),
        trigger: event
      });
    }
  }
  ["play"](event) {
    const { paused, autoplayError, ended, autoplaying } = this._store;
    event.autoplay = autoplaying();
    if (this._request._looping || !paused()) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this._trackedEvents.get("waiting"));
    this._satisfyRequest("play", event);
    paused.set(false);
    autoplayError.set(void 0);
    if (ended() || this._request._replaying) {
      this._request._replaying = false;
      ended.set(false);
      this._handle(this.createEvent("replay", { trigger: event }));
    }
  }
  ["play-fail"](event) {
    appendTriggerEvent(event, this._trackedEvents.get("play"));
    this._satisfyRequest("play", event);
    const { paused, playing } = this._store;
    paused.set(true);
    playing.set(false);
    this._resetTracking();
  }
  ["playing"](event) {
    const playEvent = this._trackedEvents.get("play");
    if (playEvent) {
      appendTriggerEvent(event, this._trackedEvents.get("waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, this._trackedEvents.get("seeked"));
    }
    setTimeout(() => this._resetTracking(), 0);
    const { paused, playing, seeking, ended } = this._store;
    paused.set(false);
    playing.set(true);
    seeking.set(false);
    ended.set(false);
    if (this._request._looping) {
      event.stopImmediatePropagation();
      this._request._looping = false;
      return;
    }
    this["started"](event);
  }
  ["started"](event) {
    const { started, live, liveSyncPosition, seekableEnd } = this._store;
    if (!started()) {
      if (live()) {
        const end = liveSyncPosition() ?? seekableEnd() - 2;
        if (Number.isFinite(end))
          this._media.$provider().currentTime = end;
      }
      started.set(true);
      this._handle(this.createEvent("started", { trigger: event }));
    }
  }
  ["pause"](event) {
    if (this._request._looping) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this._trackedEvents.get("seeked"));
    this._satisfyRequest("pause", event);
    const { paused, playing, seeking } = this._store;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    this._resetTracking();
  }
  ["time-update"](event) {
    const { currentTime, played, waiting } = this._store, detail = event.detail;
    currentTime.set(detail.currentTime);
    played.set(detail.played);
    waiting.set(false);
    for (const track of this._media.textTracks) {
      if (track.mode === "disabled")
        continue;
      track[TEXT_TRACK_UPDATE_ACTIVE_CUES](detail.currentTime, event);
    }
  }
  ["volume-change"](event) {
    const { volume, muted } = this._store, detail = event.detail;
    volume.set(detail.volume);
    muted.set(detail.muted || detail.volume === 0);
    this._satisfyRequest("volume", event);
  }
  ["seeked"](event) {
    var _a2;
    const { seeking, currentTime, paused, duration, ended } = this._store;
    if (this._request._seeking) {
      seeking.set(true);
      event.stopImmediatePropagation();
    } else if (seeking()) {
      const waitingEvent = this._trackedEvents.get("waiting");
      appendTriggerEvent(event, waitingEvent);
      if (((_a2 = waitingEvent == null ? void 0 : waitingEvent.trigger) == null ? void 0 : _a2.type) !== "seeking") {
        appendTriggerEvent(event, this._trackedEvents.get("seeking"));
      }
      if (paused())
        this._stopWaiting();
      seeking.set(false);
      if (event.detail !== duration())
        ended.set(false);
      currentTime.set(event.detail);
      this._satisfyRequest("seeked", event);
      const origin = event.originEvent;
      if (origin && origin.isTrusted && !/seek/.test(origin.type)) {
        this["started"](event);
      }
    }
  }
  ["waiting"](event) {
    if (this._firingWaiting || this._request._seeking)
      return;
    event.stopImmediatePropagation();
    this._waitingTrigger = event;
    this._fireWaiting();
  }
  ["ended"](event) {
    if (this._request._looping) {
      event.stopImmediatePropagation();
      return;
    }
    const { paused, playing, seeking, ended } = this._store;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    ended.set(true);
    this._resetTracking();
  }
  _stopWaiting() {
    this._fireWaiting.cancel();
    this._store.waiting.set(false);
  }
  ["fullscreen-change"](event) {
    this._store.fullscreen.set(event.detail);
    this._satisfyRequest("fullscreen", event);
  }
  ["fullscreen-error"](event) {
    this._satisfyRequest("fullscreen", event);
  }
  ["picture-in-picture-change"](event) {
    this._store.pictureInPicture.set(event.detail);
    this._satisfyRequest("pip", event);
  }
  ["picture-in-picture-error"](event) {
    this._satisfyRequest("pip", event);
  }
};
var MediaStoreSync = class extends ComponentController {
  onAttach(el) {
    return;
  }
  _onLogLevelChange() {
    return;
  }
  _onAutoplayChange() {
    const autoplay = this.$props.autoplay();
    this.$store.autoplay.set(autoplay);
    this.dispatch("autoplay-change", { detail: autoplay });
  }
  _onLoopChange() {
    const loop = this.$props.loop();
    this.$store.loop.set(loop);
    this.dispatch("loop-change", { detail: loop });
  }
  _onControlsChange() {
    const controls = this.$props.controls();
    this.$store.controls.set(controls);
    this.dispatch("controls-change", { detail: controls });
  }
  _onPosterChange() {
    const poster = this.$props.poster();
    this.$store.poster.set(poster);
    this.dispatch("poster-change", { detail: poster });
  }
  _onCrossOriginChange() {
    this.$store.crossorigin.set(this.$props.crossorigin());
  }
  _onPlaysinlineChange() {
    const playsinline = this.$props.playsinline();
    this.$store.playsinline.set(playsinline);
    this.dispatch("playsinline-change", { detail: playsinline });
  }
  _onLiveChange() {
    this.dispatch("live-change", { detail: this.$store.live() });
  }
  _onLiveToleranceChange() {
    this.$store.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
    this.$store.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
  }
  _onLiveEdgeChange() {
    this.dispatch("live-edge-change", { detail: this.$store.liveEdge() });
  }
  _onThumbnailsChange() {
    this.$store.thumbnails.set(this.$props.thumbnails());
  }
};
var ThumbnailsLoader = class extends ComponentController {
  onConnect() {
    this._media = useMedia();
    effect(this._onLoadCues.bind(this));
  }
  _onLoadCues() {
    const { canLoad, thumbnailCues } = this._media.$store;
    if (!canLoad())
      return;
    const controller = new AbortController(), { crossorigin, thumbnails } = this._media.$store;
    const src = thumbnails();
    if (!src)
      return;
    import('media-captions').then(({ parseResponse }) => {
      parseResponse(
        fetch(src, {
          signal: controller.signal,
          credentials: getRequestCredentials(crossorigin())
        })
      ).then(({ cues }) => thumbnailCues.set(cues)).catch(noop);
    });
    return () => {
      controller.abort();
      thumbnailCues.set([]);
    };
  }
};

// src/player/core/player.tsx
var Player = class extends Component {
  constructor(instance) {
    super(instance);
    this._canPlayQueue = new RequestQueue();
    this._initStore();
    new MediaStoreSync(instance);
    const context = {
      player: null,
      scope: getScope(),
      qualities: new VideoQualityList(),
      audioTracks: new AudioTrackList(),
      $provider: signal(null),
      $props: this.$props,
      $store: this.$store
    };
    context.remote = new MediaRemoteControl(void 0);
    context.$iosControls = computed(this._isIOSControls.bind(this));
    context.textTracks = new TextTrackList();
    context.textTracks[TEXT_TRACK_CROSSORIGIN] = this.$props.crossorigin;
    context.textRenderers = new TextRenderers(context);
    context.ariaKeys = {};
    this._media = context;
    provideContext(mediaContext, context);
    this.orientation = new ScreenOrientationController(instance);
    new FocusVisibleController(instance);
    new MediaKeyboardController(instance, context);
    new ThumbnailsLoader(instance);
    const request = new MediaRequestContext();
    this._stateMgr = new MediaStateManager(instance, request, context);
    this._requestMgr = new MediaRequestManager(instance, this._stateMgr, request, context);
    context.delegate = new MediaPlayerDelegate(
      this._stateMgr._handle.bind(this._stateMgr),
      context
    );
    new MediaLoadController(instance, this.startLoading.bind(this));
  }
  get _provider() {
    return this._media.$provider();
  }
  onAttach(el) {
    el.setAttribute("tabindex", "0");
    setAttributeIfEmpty(el, "role", "region");
    this._watchTitle();
    this._watchOrientation();
    effect(this._watchCanPlay.bind(this));
    effect(this._watchMuted.bind(this));
    effect(this._watchPaused.bind(this));
    effect(this._watchVolume.bind(this));
    effect(this._watchCurrentTime.bind(this));
    effect(this._watchPlaysinline.bind(this));
    effect(this._watchPlaybackRate.bind(this));
    this._setMediaAttributes();
    this._setMediaVars();
    this._media.player = el;
    this._media.remote.setTarget(el);
    this._media.remote.setPlayer(el);
    listenEvent(el, "find-media-player", this._onFindPlayer.bind(this));
  }
  onConnect(el) {
    if (IS_IPHONE)
      setAttribute(el, "data-iphone", "");
    const pointerQuery = window.matchMedia("(pointer: coarse)");
    this._onTouchChange(pointerQuery);
    pointerQuery.onchange = this._onTouchChange.bind(this);
    const resize = new ResizeObserver(this._onResize.bind(this));
    resize.observe(el);
    effect(this._onResize.bind(this));
    this.dispatch("media-player-connect", {
      detail: this.el,
      bubbles: true,
      composed: true
    });
    return () => {
      resize.disconnect();
      pointerQuery.onchange = null;
    };
  }
  _initStore() {
    var _a2;
    const providedProps = {
      viewType: "providedViewType",
      streamType: "providedStreamType"
    };
    for (const prop2 of Object.keys(this.$props)) {
      (_a2 = this.$store[providedProps[prop2] ?? prop2]) == null ? void 0 : _a2.set(this.$props[prop2]());
    }
    this._onProvidedTypesChange();
    this.$store.muted.set(this.$props.muted() || this.$props.volume() === 0);
  }
  _watchTitle() {
    var _a2, _b, _c;
    const { title } = this.$props, { live, viewType } = this.$store, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media";
    const newTitle = title();
    if (newTitle) {
      (_a2 = this.el) == null ? void 0 : _a2.setAttribute("data-title", newTitle);
      (_b = this.el) == null ? void 0 : _b.removeAttribute("title");
    }
    const currentTitle = ((_c = this.el) == null ? void 0 : _c.getAttribute("data-title")) || "";
    this.$store.title.set(currentTitle);
    setAttribute(
      this.el,
      "aria-label",
      currentTitle ? `${typeText} - ${currentTitle}` : typeText + " Player"
    );
  }
  _watchOrientation() {
    const orientation = this.orientation.landscape ? "landscape" : "portrait";
    this.$store.orientation.set(orientation);
    setAttribute(this.el, "data-orientation", orientation);
    this._onResize();
  }
  _watchCanPlay() {
    if (this.$store.canPlay() && this._provider)
      this._canPlayQueue._start();
    else
      this._canPlayQueue._stop();
  }
  _onProvidedTypesChange() {
    this.$store.providedViewType.set(this.$props.viewType());
    this.$store.providedStreamType.set(this.$props.streamType());
  }
  _setMediaAttributes() {
    const $attrs = {
      "aspect-ratio": this.$props.aspectRatio,
      "data-captions": () => {
        const track = this.$store.textTrack();
        return !!track && isTrackCaptionKind(track);
      },
      "data-ios-controls": this._media.$iosControls
    };
    const mediaAttrName = {
      canPictureInPicture: "can-pip",
      pictureInPicture: "pip"
    };
    for (const prop2 of MEDIA_ATTRIBUTES) {
      const attrName = "data-" + (mediaAttrName[prop2] ?? camelToKebabCase(prop2));
      $attrs[attrName] = this.$store[prop2];
    }
    delete $attrs.title;
    this.setAttributes($attrs);
  }
  _setMediaVars() {
    this.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = this.$props.aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      }
    });
  }
  _onFindPlayer(event) {
    event.detail(this.el);
  }
  _onResize() {
    return;
  }
  _onTouchChange(queryList) {
    return;
  }
  _isIOSControls() {
    return !canFullscreen() && this.$store.mediaType() === "video" && (this.$store.controls() && !this.$props.playsinline() || this.$store.fullscreen());
  }
  get provider() {
    return this._provider;
  }
  get user() {
    return this._requestMgr._user;
  }
  get qualities() {
    return this._media.qualities;
  }
  get audioTracks() {
    return this._media.audioTracks;
  }
  get textTracks() {
    return this._media.textTracks;
  }
  get textRenderers() {
    return this._media.textRenderers;
  }
  get paused() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.paused) ?? true;
  }
  set paused(paused) {
    if (paused) {
      this._canPlayQueue._enqueue("paused", () => this._requestMgr._pause());
    } else
      this._canPlayQueue._enqueue("paused", () => this._requestMgr._play());
  }
  _watchPaused() {
    this.paused = this.$props.paused();
  }
  get muted() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.muted) ?? false;
  }
  set muted(muted) {
    this._canPlayQueue._enqueue("muted", () => this._provider.muted = muted);
  }
  _watchMuted() {
    this.muted = this.$props.muted();
  }
  get currentTime() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.currentTime) ?? 0;
  }
  set currentTime(time) {
    this._canPlayQueue._enqueue("currentTime", () => {
      const adapter = this._provider;
      if (time !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max(this.$store.seekableStart() + 0.1, time),
            this.$store.seekableEnd() - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  _watchCurrentTime() {
    this.currentTime = this.$props.currentTime();
  }
  get volume() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.volume) ?? 1;
  }
  set volume(volume) {
    this._canPlayQueue._enqueue("volume", () => this._provider.volume = volume);
  }
  _watchVolume() {
    this.volume = clampNumber(0, this.$props.volume(), 1);
  }
  get playsinline() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.playsinline) ?? false;
  }
  set playsinline(inline) {
    this._canPlayQueue._enqueue("playsinline", () => this._provider.playsinline = inline);
  }
  _watchPlaysinline() {
    this.playsinline = this.$props.playsinline();
  }
  get playbackRate() {
    var _a2;
    return ((_a2 = this._provider) == null ? void 0 : _a2.playbackRate) ?? 1;
  }
  set playbackRate(rate) {
    this._canPlayQueue._enqueue("rate", () => this._provider.playbackRate = rate);
  }
  _watchPlaybackRate() {
    this.playbackRate = this.$props.playbackRate();
  }
  async play() {
    return this._requestMgr._play();
  }
  async pause() {
    return this._requestMgr._pause();
  }
  async enterFullscreen(target) {
    return this._requestMgr._enterFullscreen(target);
  }
  async exitFullscreen(target) {
    return this._requestMgr._exitFullscreen(target);
  }
  enterPictureInPicture() {
    return this._requestMgr._enterPictureInPicture();
  }
  exitPictureInPicture() {
    return this._requestMgr._exitPictureInPicture();
  }
  seekToLiveEdge() {
    this._requestMgr._seekToLiveEdge();
  }
  startLoading() {
    this._media.delegate._dispatch("can-load");
  }
  destroy() {
    this.dispatch("destroy");
  }
};
Player.el = defineElement({
  tagName: "media-player",
  props: mediaPlayerProps,
  store: MediaStoreFactory
});
__decorateClass([
  prop
], Player.prototype, "provider", 1);
__decorateClass([
  prop
], Player.prototype, "user", 1);
__decorateClass([
  prop
], Player.prototype, "orientation", 2);
__decorateClass([
  prop
], Player.prototype, "qualities", 1);
__decorateClass([
  prop
], Player.prototype, "audioTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textRenderers", 1);
__decorateClass([
  prop
], Player.prototype, "paused", 1);
__decorateClass([
  prop
], Player.prototype, "muted", 1);
__decorateClass([
  prop
], Player.prototype, "currentTime", 1);
__decorateClass([
  prop
], Player.prototype, "volume", 1);
__decorateClass([
  prop
], Player.prototype, "playsinline", 1);
__decorateClass([
  prop
], Player.prototype, "playbackRate", 1);
__decorateClass([
  method
], Player.prototype, "play", 1);
__decorateClass([
  method
], Player.prototype, "pause", 1);
__decorateClass([
  method
], Player.prototype, "enterFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "exitFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "enterPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "exitPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "seekToLiveEdge", 1);
__decorateClass([
  method
], Player.prototype, "startLoading", 1);

export { AudioTrackList, FullscreenController, List, MEDIA_KEY_SHORTCUTS, MediaRemoteControl, MediaStoreFactory, MediaUserController, Player, ScreenOrientationController, TextRenderers, TextTrackList, TimeRange, VideoQualityList, canFullscreen, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isHLSProvider, isHTMLAudioElement, isHTMLMediaElement, isHTMLVideoElement, isVideoProvider, softResetMediaStore };
