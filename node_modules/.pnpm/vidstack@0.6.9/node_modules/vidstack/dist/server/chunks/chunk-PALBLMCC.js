import { $ariaBool } from './chunk-EVP5E6AO.js';
import { onPress, setAttributeIfEmpty, isElementParent } from './chunk-JTTKMFDW.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { menuContext } from './chunk-HSL7QSWM.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { signal, hasProvidedContext, useContext, provideContext, effect, scoped, peek, tick, onDispose } from 'maverick.js';
import { defineElement, method, Component } from 'maverick.js/element';
import { setAttribute, setStyle, listenEvent, ariaBool, isKeyboardEvent } from 'maverick.js/std';

var FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
  "a[href]",
  "[tabindex]",
  "input",
  "select",
  "button"
].map((selector) => `${selector}:not([aria-hidden])`).join(",");
var VALID_KEYS = /* @__PURE__ */ new Set([
  "Escape",
  "Tab",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "PageUp",
  "End",
  "PageDown",
  "Enter",
  " "
]);
var MenuFocusController = class {
  constructor(_closeMenu) {
    this._closeMenu = _closeMenu;
    this._index = 0;
    this._el = null;
    this._elements = [];
  }
  get _items() {
    return this._elements;
  }
  _attach(el) {
    listenEvent(el, "focus", this._onFocus.bind(this));
    this._el = el;
  }
  _listen() {
    if (!this._el)
      return;
    this._update();
    listenEvent(this._el, "keyup", this._onKeyUp.bind(this));
    listenEvent(this._el, "keydown", this._onKeyDown.bind(this));
    onDispose(() => {
      this._index = 0;
      this._elements = [];
    });
  }
  _focusAt(index) {
    var _a, _b;
    this._index = index;
    (_a = this._elements[index]) == null ? void 0 : _a.focus();
    (_b = this._elements[index]) == null ? void 0 : _b.scrollIntoView({
      block: "center"
    });
  }
  _onFocus() {
    const index = this._elements.findIndex((el) => el.getAttribute("aria-checked") === "true");
    this._focusAt(index >= 0 ? index : 0);
  }
  _update() {
    this._index = 0;
    this._elements = this._getFocusableElements();
  }
  _onKeyUp(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
  }
  _onKeyDown(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
    switch (event.key) {
      case "Escape":
        this._closeMenu(event);
        break;
      case "Tab":
        this._focusAt(this._nextIndex(event.shiftKey ? -1 : 1));
        break;
      case "ArrowUp":
        this._focusAt(this._nextIndex(-1));
        break;
      case "ArrowDown":
        this._focusAt(this._nextIndex(1));
        break;
      case "Home":
      case "PageUp":
        this._focusAt(0);
        break;
      case "End":
      case "PageDown":
        this._focusAt(this._elements.length - 1);
        break;
    }
  }
  _nextIndex(delta) {
    let index = this._index;
    do {
      index = (index + delta + this._elements.length) % this._elements.length;
    } while (this._elements[index].offsetParent === null);
    return index;
  }
  _getFocusableElements() {
    if (!this._el)
      return [];
    const focusableElements = this._el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
    const is = (node) => node.hasAttribute("data-media-menu-items");
    for (const el of focusableElements) {
      if (el instanceof HTMLElement && el.offsetParent !== null && // does not have display: none
      isElementParent(this._el, el, is)) {
        elements.push(el);
      }
    }
    return elements;
  }
};

// src/player/ui/menu/menu.tsx
var idCount = 0;
var Menu = class extends Component {
  constructor(instance) {
    super(instance);
    this._expanded = signal(false);
    this._disabled = signal(false);
    this._buttonDisabled = signal(false);
    this._submenus = /* @__PURE__ */ new Set();
    this._menuButton = null;
    this._menuItems = null;
    this._menuObserver = null;
    this._disableBind = this._disable.bind(this);
    this._removeSubmenuBind = this._removeSubmenu.bind(this);
    this._onSubmenuOpenBind = this._onSubmenuOpen.bind(this);
    this._onSubmenuCloseBind = this._onSubmenuClose.bind(this);
    this._media = useMedia();
    const currentIdCount = ++idCount;
    this._menuId = `media-menu-${currentIdCount}`;
    this._menuButtonId = `media-menu-button-${currentIdCount}`;
    if (hasProvidedContext(menuContext)) {
      this._parentMenu = useContext(menuContext);
    }
    this._focus = new MenuFocusController(this.close.bind(this));
    provideContext(menuContext, {
      _expanded: this._expanded,
      _hint: signal(""),
      _disable: this._disable.bind(this),
      _attachMenuButton: this._attachMenuButton.bind(this),
      _attachMenuItems: this._attachMenuItems.bind(this),
      _attachObserver: this._attachObserver.bind(this),
      _disableMenuButton: this._disableMenuButton.bind(this),
      _addSubmenu: this._addSubmenu.bind(this)
    });
  }
  onAttach(el) {
    const { position } = this.$props;
    this.setAttributes({
      position,
      "data-open": this._expanded,
      "data-submenu": !!this._parentMenu,
      "data-disabled": this._isDisabled.bind(this),
      "data-media-menu": true
    });
  }
  onConnect(el) {
    var _a;
    if (!this._parentMenu) {
      effect(this._watchBreakpoint.bind(this));
    }
    effect(this._watchExpanded.bind(this));
    (_a = this._parentMenu) == null ? void 0 : _a._addSubmenu(el);
    requestAnimationFrame(() => this._onResize());
  }
  onDestroy() {
    this._removePopupMenu();
    this._menuButton = null;
    this._menuItems = null;
    this._menuObserver = null;
  }
  _removePopupMenu() {
    var _a, _b;
    if (!this._menuItems || ((_a = this.el) == null ? void 0 : _a.contains(this._menuItems)))
      return;
    const menu = (_b = this._menuItems) == null ? void 0 : _b.parentElement;
    this.el.append(this._menuItems);
    if ((menu == null ? void 0 : menu.localName) === "media-menu") {
      menu.destroy();
      menu.remove();
    }
  }
  _watchBreakpoint() {
    var _a, _b;
    if (!this.el)
      return;
    const { breakpointX, breakpointY, viewType, orientation, fullscreen } = this._media.$store, popup = viewType() === "audio" ? breakpointX() === "sm" : breakpointY() === "sm";
    if (!this._menuItems || this._parentMenu)
      return;
    setAttribute(this.el, "data-popup", popup);
    setAttribute(this.el, "data-popup-wide", popup && orientation() === "landscape");
    if (popup && !fullscreen()) {
      if ((_b = (_a = this.el).contains) == null ? void 0 : _b.call(_a, this._menuItems)) {
        const menu = this.el.cloneNode();
        menu.appendChild(this._menuItems);
        requestAnimationFrame(() => {
          if (!this.el)
            return;
          const mediaRing = "--media-focus-ring", mediaRingValue = getComputedStyle(this.el).getPropertyValue(mediaRing);
          if (mediaRingValue)
            setStyle(menu, mediaRing, mediaRingValue);
        });
        scoped(() => {
          document.body.append(menu);
        }, this._media.scope);
      }
    }
    this._onResize();
    return () => this._removePopupMenu();
  }
  _watchExpanded() {
    const expanded = this._isExpanded();
    this._onResize();
    this._updateMenuItemsHidden(expanded);
    if (!expanded)
      return;
    this._focus._listen();
    const closeTarget = this._getCloseTarget();
    if (closeTarget) {
      onPress(closeTarget, this._onCloseTargetPress.bind(this));
    }
    this.listen("pointerup", this._onPointerUp.bind(this));
    listenEvent(window, "pointerup", this._onWindowPointerUp.bind(this));
  }
  _attachMenuButton(el) {
    const isMenuItem = !!this._parentMenu, isExpanded = this._isExpanded.bind(this), isARIAExpanded = $ariaBool(isExpanded), isARIADisabled = $ariaBool(this._isDisabled.bind(this));
    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
    setAttribute(el, "id", this._menuButtonId);
    setAttribute(el, "aria-controls", this._menuId);
    setAttribute(el, "aria-haspopup", "true");
    effect(() => {
      setAttribute(el, "aria-disabled", isARIADisabled());
      setAttribute(el, "aria-expanded", isARIAExpanded());
      if (!isMenuItem)
        setAttribute(el, "aria-pressed", isARIAExpanded());
      setAttribute(el, "data-pressed", isExpanded());
    });
    setAttribute(el, "data-media-button", !isMenuItem);
    setAttribute(el, "data-media-menu-button", "");
    onPress(el, this._onMenuButtonPress.bind(this));
    this._menuButton = el;
  }
  _attachMenuItems(el) {
    setAttributeIfEmpty(el, "role", "menu");
    setAttributeIfEmpty(el, "tabindex", "-1");
    setAttribute(el, "id", this._menuId);
    setAttribute(el, "aria-describedby", this._menuButtonId);
    setAttribute(el, "data-media-menu-items", "");
    this._menuItems = el;
    this._focus._attach(el);
    this._watchBreakpoint();
    this._updateMenuItemsHidden(peek(this._expanded));
  }
  _attachObserver(observer) {
    this._menuObserver = observer;
  }
  _updateMenuItemsHidden(expanded) {
    if (this._menuItems)
      setAttribute(this._menuItems, "aria-hidden", ariaBool(!expanded));
  }
  _disableMenuButton(disabled) {
    this._buttonDisabled.set(disabled);
  }
  _onMenuButtonPress(event) {
    var _a;
    if (this._parentMenu)
      event.stopPropagation();
    if (this._isDisabled())
      return;
    this._expanded.set((expanded) => !expanded);
    this._changeIdleTracking();
    tick();
    if (isKeyboardEvent(event)) {
      (_a = this._menuItems) == null ? void 0 : _a.focus();
    }
    this._onChange(event);
  }
  _onChange(trigger) {
    var _a, _b, _c, _d, _e;
    const expanded = peek(this._expanded);
    this.dispatch(expanded ? "open" : "close", { trigger });
    if (!this._parentMenu) {
      if (expanded) {
        (_a = this._media.activeMenu) == null ? void 0 : _a.close(trigger);
        this._media.activeMenu = this;
      } else {
        for (const el of this._submenus)
          el.close(trigger);
        this._media.activeMenu = null;
      }
    }
    if (expanded)
      (_c = (_b = this._menuObserver) == null ? void 0 : _b._onOpen) == null ? void 0 : _c.call(_b, trigger);
    else
      (_e = (_d = this._menuObserver) == null ? void 0 : _d._onClose) == null ? void 0 : _e.call(_d, trigger);
  }
  _isExpanded() {
    return !this._isDisabled() && this._expanded();
  }
  _isDisabled() {
    return this._disabled() || this._buttonDisabled();
  }
  _disable(disabled) {
    this._disabled.set(disabled);
  }
  _onPointerUp(event) {
    event.stopPropagation();
  }
  _onWindowPointerUp() {
    if (this._parentMenu)
      return setTimeout(this.close.bind(this), 300);
    this.close();
  }
  _onCloseTargetPress(event) {
    event.stopPropagation();
    this.close(event);
  }
  _getCloseTarget() {
    const target = this.el.querySelector('[slot="close-target"]');
    return isElementParent(this.el, target) ? target : null;
  }
  _changeIdleTracking(trigger) {
    if (this._parentMenu)
      return;
    if (this._expanded())
      this._media.remote.pauseUserIdle(trigger);
    else
      this._media.remote.resumeUserIdle(trigger);
  }
  _addSubmenu(el) {
    this._submenus.add(el);
    listenEvent(el, "open", this._onSubmenuOpenBind);
    listenEvent(el, "close", this._onSubmenuCloseBind);
    onDispose(this._removeSubmenuBind);
  }
  _removeSubmenu(el) {
    this._submenus.delete(el);
  }
  _onSubmenuOpen(event) {
    for (const el of this._submenus) {
      if (el !== event.target)
        el.setAttribute("aria-hidden", "true");
    }
    this._onResize();
  }
  _onSubmenuClose() {
    for (const el of this._submenus)
      el.removeAttribute("aria-hidden");
    this._onResize();
  }
  _onResize() {
    var _a;
    if (!this._menuItems || true)
      return;
    let style = getComputedStyle(this._menuItems), height = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let children = [...this._menuItems.children];
    if (((_a = children[0]) == null ? void 0 : _a.localName) === "shadow-root") {
      children.push(...children[0].children);
    }
    for (const child of children) {
      height += child.offsetHeight;
    }
    requestAnimationFrame(() => {
      if (!this._menuItems)
        return;
      setAttribute(this._menuItems, "data-resizing", "");
      setTimeout(() => {
        if (!this._menuItems)
          return;
        setAttribute(this._menuItems, "data-resizing", false);
      }, 250);
      setStyle(this._menuItems, "--menu-height", height + "px");
    });
  }
  open(trigger) {
    var _a;
    if (peek(this._expanded))
      return;
    this._expanded.set(true);
    tick();
    this._onChange(trigger);
    if (isKeyboardEvent(trigger)) {
      (_a = this._menuItems) == null ? void 0 : _a.focus();
    }
    this._changeIdleTracking(trigger);
  }
  close(trigger) {
    if (!peek(this._expanded))
      return;
    this._expanded.set(false);
    tick();
    if (isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        var _a;
        (_a = this._menuButton) == null ? void 0 : _a.focus();
      });
    }
    this._onChange(trigger);
    this._changeIdleTracking(trigger);
  }
};
Menu.el = defineElement({
  tagName: "media-menu",
  props: { position: null }
});
__decorateClass([
  method
], Menu.prototype, "open", 1);
__decorateClass([
  method
], Menu.prototype, "close", 1);

export { Menu };
