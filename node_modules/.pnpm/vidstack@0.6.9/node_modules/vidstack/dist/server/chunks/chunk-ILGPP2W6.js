import { scopedRaf } from './chunk-JTTKMFDW.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { effect, peek } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { listenEvent, isPointerEvent, isMouseEvent, isTouchEvent, kebabToCamelCase } from 'maverick.js/std';

var Gesture = class extends Component {
  constructor() {
    super(...arguments);
    this._outlet = null;
    this._presses = 0;
    this._pressTimerId = -1;
  }
  onAttach() {
    const { event, action } = this.$props;
    this.setAttributes({
      event,
      action
    });
  }
  onConnect() {
    this._media = useMedia();
    scopedRaf(() => {
      this._outlet = this._media.player.querySelector("media-outlet");
      effect(this._attachListener.bind(this));
    });
  }
  _attachListener() {
    let eventType = this.$props.event();
    if (!this._outlet || !eventType)
      return;
    if (/^dbl/.test(eventType)) {
      eventType = eventType.split(/^dbl/)[1];
    }
    listenEvent(this._outlet, eventType, this._acceptEvent.bind(this));
  }
  _acceptEvent(event) {
    var _a;
    if (!this._inBounds(event) || isPointerEvent(event) && (event.button !== 0 || this._media.activeMenu)) {
      return;
    }
    event.MEDIA_GESTURE = true;
    event.preventDefault();
    const isDblEvent = (_a = peek(this.$props.event)) == null ? void 0 : _a.startsWith("dbl");
    if (!isDblEvent) {
      if (this._presses === 0) {
        setTimeout(() => {
          if (this._presses === 1)
            this._handleEvent(event);
        }, 250);
      }
    } else if (this._presses === 1) {
      queueMicrotask(() => this._handleEvent(event));
      clearTimeout(this._pressTimerId);
      this._presses = 0;
      return;
    }
    if (this._presses === 0) {
      this._pressTimerId = window.setTimeout(() => {
        this._presses = 0;
      }, 275);
    }
    this._presses++;
  }
  _handleEvent(event) {
    this.el.setAttribute("data-triggered", "");
    requestAnimationFrame(() => {
      if (this._isTopLayer()) {
        this._performAction(peek(this.$props.action), event);
      }
      requestAnimationFrame(() => {
        this.el.removeAttribute("data-triggered");
      });
    });
  }
  /** Validate event occurred in gesture bounds. */
  _inBounds(event) {
    if (!this.el)
      return false;
    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {
      const touch = isTouchEvent(event) ? event.touches[0] : void 0;
      const clientX = (touch == null ? void 0 : touch.clientX) ?? event.clientX;
      const clientY = (touch == null ? void 0 : touch.clientY) ?? event.clientY;
      const rect = this.el.getBoundingClientRect();
      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;
      return event.type.includes("leave") ? !inBounds : inBounds;
    }
    return true;
  }
  /** Validate gesture has the highest z-index in this triggered group. */
  _isTopLayer() {
    var _a;
    const gestures = this._media.player.querySelectorAll(
      "media-gesture[data-triggered]"
    );
    return ((_a = Array.from(gestures).sort(
      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex
    )[0]) == null ? void 0 : _a.component) === this;
  }
  _performAction(action, trigger) {
    if (!action)
      return;
    const [method, value] = action.replace(/:([a-z])/, "-$1").split(":");
    if (action.includes(":fullscreen")) {
      this._media.remote.toggleFullscreen("prefer-media", trigger);
    } else if (action.includes("seek:")) {
      this._media.remote.seek(peek(this._media.$store.currentTime) + (+value || 0), trigger);
    } else {
      this._media.remote[kebabToCamelCase(method)](trigger);
    }
  }
};
Gesture.el = defineElement({
  tagName: "media-gesture",
  props: {
    event: void 0,
    action: void 0
  }
});

export { Gesture };
