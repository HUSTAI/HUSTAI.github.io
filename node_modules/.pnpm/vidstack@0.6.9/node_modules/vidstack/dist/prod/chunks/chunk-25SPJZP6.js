import { AUDIO_PROVIDER } from './chunk-IMVDTPPP.js';
import { HLS_PROVIDER, SET_AUTO_QUALITY, ENABLE_AUTO_QUALITY, coerceToError } from './chunk-YBFM664V.js';
import { VIDEO_PROVIDER } from './chunk-F3MPEIU4.js';
import { LIST_READONLY, LIST_ADD, LIST_REMOVE, LIST_ON_REMOVE, LIST_RESET, LIST_SET_READONLY, LIST_ON_RESET, LIST_ON_USER_SELECT, LIST_SELECT } from './chunk-QSX4JG34.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { canOrientScreen, IS_IPHONE } from './chunk-WSYKLWQE.js';
import { clampNumber } from './chunk-CVLY5S52.js';
import { isTrackCaptionKind, ATTACH_VIDEO, TEXT_TRACK_NATIVE_HLS, TextTrack, TEXT_TRACK_CROSSORIGIN, TEXT_TRACK_CAN_LOAD, TEXT_TRACK_ON_MODE_CHANGE, TEXT_TRACK_NATIVE, TEXT_TRACK_UPDATE_ACTIVE_CUES } from './chunk-PXCLVUYU.js';
import { getRequestCredentials } from './chunk-IVW6GMZV.js';
import { setAttributeIfEmpty } from './chunk-HQQTSFXD.js';
import { mediaContext, useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-UMWH4QNT.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { EventsTarget, DOMEvent, listenEvent, isArray, isUndefined, isKeyboardEvent, setAttribute, uppercaseFirstChar, camelToKebabCase, isKeyboardClick, deferredPromise, appendTriggerEvent, noop } from 'maverick.js/std';
import { defineProp, defineElement, prop, method, ComponentController, Component } from 'maverick.js/element';
import { StoreFactory, signal, peek, tick, effect, onDispose, getScope, computed, provideContext } from 'maverick.js';

var _a;
var List = class extends EventsTarget {
  constructor() {
    super(...arguments);
    this.q = [];
    /* @internal */
    this[_a] = false;
  }
  get length() {
    return this.q.length;
  }
  get readonly() {
    return this[LIST_READONLY];
  }
  /**
   * Transform list to an array.
   */
  toArray() {
    return [...this.q];
  }
  [(_a = LIST_READONLY, Symbol.iterator)]() {
    return this.q.values();
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    const index = this.q.length;
    if (!("" + index in this)) {
      Object.defineProperty(this, index, {
        get() {
          return this.q[index];
        }
      });
    }
    if (this.q.includes(item))
      return;
    this.q.push(item);
    this.dispatchEvent(new DOMEvent("add", { detail: item, trigger }));
  }
  /* @internal */
  [LIST_REMOVE](item, trigger) {
    const index = this.q.indexOf(item);
    if (index >= 0) {
      this[LIST_ON_REMOVE]?.(item, trigger);
      this.q.splice(index, 1);
      this.dispatchEvent(new DOMEvent("remove", { detail: item, trigger }));
    }
  }
  /* @internal */
  [LIST_RESET](trigger) {
    for (const item of [...this.q])
      this[LIST_REMOVE](item, trigger);
    this.q = [];
    this[LIST_SET_READONLY](false, trigger);
    this[LIST_ON_RESET]?.();
  }
  /* @internal */
  [LIST_SET_READONLY](readonly, trigger) {
    if (this[LIST_READONLY] === readonly)
      return;
    this[LIST_READONLY] = readonly;
    this.dispatchEvent(new DOMEvent("readonly-change", { detail: readonly, trigger }));
  }
};

// ../../node_modules/.pnpm/fscreen@1.2.0/node_modules/fscreen/dist/fscreen.esm.js
var key = {
  fullscreenEnabled: 0,
  fullscreenElement: 1,
  requestFullscreen: 2,
  exitFullscreen: 3,
  fullscreenchange: 4,
  fullscreenerror: 5,
  fullscreen: 6
};
var webkit = [
  "webkitFullscreenEnabled",
  "webkitFullscreenElement",
  "webkitRequestFullscreen",
  "webkitExitFullscreen",
  "webkitfullscreenchange",
  "webkitfullscreenerror",
  "-webkit-full-screen"
];
var moz = [
  "mozFullScreenEnabled",
  "mozFullScreenElement",
  "mozRequestFullScreen",
  "mozCancelFullScreen",
  "mozfullscreenchange",
  "mozfullscreenerror",
  "-moz-full-screen"
];
var ms = [
  "msFullscreenEnabled",
  "msFullscreenElement",
  "msRequestFullscreen",
  "msExitFullscreen",
  "MSFullscreenChange",
  "MSFullscreenError",
  "-ms-fullscreen"
];
var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
var fscreen = {
  requestFullscreen: function(element) {
    return element[vendor[key.requestFullscreen]]();
  },
  requestFullscreenFunction: function(element) {
    return element[vendor[key.requestFullscreen]];
  },
  get exitFullscreen() {
    return document2[vendor[key.exitFullscreen]].bind(document2);
  },
  get fullscreenPseudoClass() {
    return ":" + vendor[key.fullscreen];
  },
  addEventListener: function(type, handler, options) {
    return document2.addEventListener(vendor[key[type]], handler, options);
  },
  removeEventListener: function(type, handler, options) {
    return document2.removeEventListener(vendor[key[type]], handler, options);
  },
  get fullscreenEnabled() {
    return Boolean(document2[vendor[key.fullscreenEnabled]]);
  },
  set fullscreenEnabled(val) {
  },
  get fullscreenElement() {
    return document2[vendor[key.fullscreenElement]];
  },
  set fullscreenElement(val) {
  },
  get onfullscreenchange() {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
  },
  set onfullscreenchange(handler) {
    return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
  },
  get onfullscreenerror() {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
  },
  set onfullscreenerror(handler) {
    return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
  }
};
var fscreen_esm_default = fscreen;
var CAN_FULLSCREEN = fscreen_esm_default.fullscreenEnabled;
var FullscreenController = class extends ComponentController {
  constructor() {
    super(...arguments);
    /**
     * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be
     * listened to globally on the document so we need to know if they relate to the current host
     * element or not.
     */
    this.Ra = false;
    this.Kb = false;
  }
  get active() {
    return this.Kb;
  }
  get supported() {
    return CAN_FULLSCREEN;
  }
  onConnect() {
    listenEvent(fscreen_esm_default, "fullscreenchange", this.Lb.bind(this));
    listenEvent(fscreen_esm_default, "fullscreenerror", this.mb.bind(this));
  }
  async onDisconnect() {
    if (CAN_FULLSCREEN)
      await this.exit();
  }
  Lb(event) {
    const active = isFullscreen(this.el);
    if (active === this.Kb)
      return;
    if (!active)
      this.Ra = false;
    this.Kb = active;
    this.dispatch("fullscreen-change", { detail: active, trigger: event });
  }
  mb(event) {
    if (!this.Ra)
      return;
    this.dispatch("fullscreen-error", { detail: null, trigger: event });
    this.Ra = false;
  }
  async enter() {
    try {
      this.Ra = true;
      if (!this.el || isFullscreen(this.el))
        return;
      assertFullscreenAPI();
      return fscreen_esm_default.requestFullscreen(this.el);
    } catch (error) {
      this.Ra = false;
      throw error;
    }
  }
  async exit() {
    if (!this.el || !isFullscreen(this.el))
      return;
    assertFullscreenAPI();
    return fscreen_esm_default.exitFullscreen();
  }
};
function canFullscreen() {
  return CAN_FULLSCREEN;
}
function isFullscreen(host) {
  if (fscreen_esm_default.fullscreenElement === host)
    return true;
  try {
    return host.matches(
      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.
      fscreen_esm_default.fullscreenPseudoClass
    );
  } catch (error) {
    return false;
  }
}
function assertFullscreenAPI() {
  if (CAN_FULLSCREEN)
    return;
  throw Error(
    "[vidstack] no fullscreen API"
  );
}
var CAN_USE_SCREEN_ORIENTATION_API = canOrientScreen();
var ScreenOrientationController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this.Sa = signal(getScreenOrientation());
    this.Aa = signal(false);
  }
  /**
   * The current screen orientation type.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get type() {
    return this.Sa();
  }
  /**
   * Whether the screen orientation is currently locked.
   *
   * @signal
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}
   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks
   */
  get locked() {
    return this.Aa();
  }
  /**
   * Whether the viewport is in a portrait orientation.
   *
   * @signal
   */
  get portrait() {
    return this.Sa().startsWith("portrait");
  }
  /**
   * Whether the viewport is in a landscape orientation.
   *
   * @signal
   */
  get landscape() {
    return this.Sa().startsWith("landscape");
  }
  /**
   * Whether the native Screen Orientation API is available.
   */
  get supported() {
    return CAN_USE_SCREEN_ORIENTATION_API;
  }
  onConnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API) {
      listenEvent(screen.orientation, "change", this.gd.bind(this));
    } else {
      const query = window.matchMedia("(orientation: landscape)");
      query.onchange = this.gd.bind(this);
      return () => query.onchange = null;
    }
  }
  async onDisconnect() {
    if (CAN_USE_SCREEN_ORIENTATION_API && this.Aa())
      await this.unlock();
  }
  gd(event) {
    this.Sa.set(getScreenOrientation());
    this.dispatch("orientation-change", {
      detail: {
        orientation: peek(this.Sa),
        lock: this.nb
      },
      trigger: event
    });
  }
  /**
   * Locks the orientation of the screen to the desired orientation type using the
   * Screen Orientation API.
   *
   * @param lockType - The screen lock orientation type.
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async lock(lockType) {
    if (peek(this.Aa) || this.nb === lockType)
      return;
    assertScreenOrientationAPI();
    await screen.orientation.lock(lockType);
    this.Aa.set(true);
    this.nb = lockType;
  }
  /**
   * Unlocks the orientation of the screen to it's default state using the Screen Orientation
   * API. This method will throw an error if the API is unavailable.
   *
   * @throws Error - If screen orientation API is unavailable.
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}
   * @see {@link https://w3c.github.io/screen-orientation}
   */
  async unlock() {
    if (!peek(this.Aa))
      return;
    assertScreenOrientationAPI();
    this.nb = void 0;
    await screen.orientation.unlock();
    this.Aa.set(false);
  }
};
function assertScreenOrientationAPI() {
  if (CAN_USE_SCREEN_ORIENTATION_API)
    return;
  throw Error(
    "[vidstack] no orientation API"
  );
}
function getScreenOrientation() {
  if (CAN_USE_SCREEN_ORIENTATION_API)
    return window.screen.orientation.type;
  return window.innerWidth >= window.innerHeight ? "landscape-primary" : "portrait-primary";
}

// src/player/core/providers/type-check.ts
function isAudioProvider(provider) {
  return !!provider?.[AUDIO_PROVIDER];
}
function isVideoProvider(provider) {
  return !!provider?.[VIDEO_PROVIDER];
}
function isHLSProvider(provider) {
  return !!provider?.[HLS_PROVIDER];
}
function isHTMLAudioElement(element) {
  return element instanceof HTMLAudioElement;
}
function isHTMLVideoElement(element) {
  return element instanceof HTMLVideoElement;
}
function isHTMLMediaElement(element) {
  return isHTMLAudioElement(element) || isHTMLVideoElement(element);
}
var MEDIA_KEY_SHORTCUTS = {
  togglePaused: "k Space",
  toggleMuted: "m",
  toggleFullscreen: "f",
  togglePictureInPicture: "i",
  toggleCaptions: "c",
  seekBackward: "ArrowLeft",
  seekForward: "ArrowRight",
  volumeUp: "ArrowUp",
  volumeDown: "ArrowDown"
};
var MODIFIER_KEYS = /* @__PURE__ */ new Set(["Shift", "Alt", "Meta", "Control"]);
var BUTTON_SELECTORS = 'button, [role="button"]';
var IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^="menuitem"]';
var MediaKeyboardController = class extends ComponentController {
  constructor(instance, _media) {
    super(instance);
    this.a = _media;
    this.Fa = null;
  }
  onConnect() {
    effect(this.Cf.bind(this));
  }
  Cf() {
    const { keyDisabled, keyTarget } = this.$props;
    if (keyDisabled())
      return;
    const target = keyTarget() === "player" ? this.el : document, $active = signal(false);
    if (target === this.el) {
      this.listen("focusin", () => $active.set(true));
      this.listen("focusout", (event) => {
        if (!this.el.contains(event.target))
          $active.set(false);
      });
    } else {
      if (!peek($active))
        $active.set(document.querySelector("media-player") === this.el);
      listenEvent(document, "focusin", (event) => {
        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === "media-player");
        if (activePlayer !== void 0)
          $active.set(this.el === activePlayer);
      });
    }
    effect(() => {
      if (!$active())
        return;
      listenEvent(target, "keyup", this._a.bind(this));
      listenEvent(target, "keydown", this.$a.bind(this));
      listenEvent(target, "keydown", this.Df.bind(this), { capture: true });
    });
  }
  _a(event) {
    const focused = document.activeElement, sliderFocused = focused?.hasAttribute("data-media-slider");
    if (!event.key || !this.$store.canSeek() || sliderFocused || focused?.matches(IGNORE_SELECTORS)) {
      return;
    }
    const method2 = this.bc(event);
    if (method2?.startsWith("seek")) {
      event.preventDefault();
      event.stopPropagation();
      if (this.Fa) {
        this.zd(event);
        this.Fa = null;
      } else {
        this.a.remote.seek(this.ub, event);
        this.ub = void 0;
      }
    }
    if (method2?.startsWith("volume")) {
      const volumeSlider = this.el.querySelector("media-volume-slider");
      volumeSlider?.dispatchEvent(new DOMEvent("keyup", { trigger: event }));
    }
  }
  $a(event) {
    if (!event.key || MODIFIER_KEYS.has(event.key))
      return;
    const focused = document.activeElement;
    if (focused?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focused?.matches(BUTTON_SELECTORS)) {
      return;
    }
    const sliderFocused = focused?.hasAttribute("data-media-slider"), method2 = this.bc(event);
    if (!method2 && !event.metaKey && /[0-9]/.test(event.key) && !sliderFocused) {
      event.preventDefault();
      event.stopPropagation();
      this.a.remote.seek(this.$store.duration() / 10 * Number(event.key), event);
      return;
    }
    if (!method2 || /volume|seek/.test(method2) && sliderFocused)
      return;
    event.preventDefault();
    event.stopPropagation();
    switch (method2) {
      case "seekForward":
      case "seekBackward":
        this.ca(event, method2);
        break;
      case "volumeUp":
      case "volumeDown":
        const volumeSlider = this.el.querySelector("media-volume-slider");
        if (volumeSlider) {
          volumeSlider.dispatchEvent(new DOMEvent("keydown", { trigger: event }));
        } else {
          const value = event.shiftKey ? 0.1 : 0.05;
          this.a.remote.changeVolume(
            this.$store.volume() + (method2 === "volumeUp" ? +value : -value),
            event
          );
        }
        break;
      case "toggleFullscreen":
        this.a.remote.toggleFullscreen("prefer-media", event);
        break;
      default:
        this.a.remote[method2]?.(event);
    }
  }
  Df(event) {
    if (isHTMLMediaElement(event.target) && this.bc(event)) {
      event.preventDefault();
    }
  }
  bc(event) {
    const keyShortcuts = {
      ...this.$props.keyShortcuts(),
      ...this.a.ariaKeys
    };
    return Object.keys(keyShortcuts).find(
      (method2) => keyShortcuts[method2].split(" ").some(
        (keys) => replaceSymbolKeys(keys).replace(/Control/g, "Ctrl").split("+").every(
          (key2) => MODIFIER_KEYS.has(key2) ? event[key2.toLowerCase() + "Key"] : event.key === key2.replace("Space", " ")
        )
      )
    );
  }
  Ef(event, type) {
    const seekBy = event.shiftKey ? 10 : 5;
    return this.ub = Math.max(
      0,
      Math.min(
        (this.ub ?? this.$store.currentTime()) + (type === "seekForward" ? +seekBy : -seekBy),
        this.$store.duration()
      )
    );
  }
  zd(event) {
    this.Fa?.dispatchEvent(new DOMEvent(event.type, { trigger: event }));
  }
  ca(event, type) {
    if (!this.$store.canSeek())
      return;
    if (!this.Fa)
      this.Fa = this.el.querySelector("media-time-slider");
    if (this.Fa) {
      this.zd(event);
    } else {
      this.a.remote.seeking(this.Ef(event, type), event);
    }
  }
};
var SYMBOL_KEY_MAP = ["!", "@", "#", "$", "%", "^", "&", "*", "(", ")"];
function replaceSymbolKeys(key2) {
  return key2.replace(/Shift\+(\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);
}
var mediaPlayerProps = {
  autoplay: false,
  aspectRatio: defineProp({
    value: null,
    type: {
      from(value) {
        if (!value)
          return null;
        if (!value.includes("/"))
          return +value;
        const [width, height] = value.split("/").map(Number);
        return +(width / height).toFixed(4);
      }
    }
  }),
  controls: false,
  currentTime: 0,
  crossorigin: null,
  fullscreenOrientation: "landscape",
  load: "visible",
  logLevel: "silent",
  loop: false,
  muted: false,
  paused: true,
  playsinline: false,
  playbackRate: 1,
  poster: "",
  preload: "metadata",
  preferNativeHLS: defineProp({
    value: false,
    attribute: "prefer-native-hls"
  }),
  src: "",
  userIdleDelay: 2e3,
  viewType: "unknown",
  streamType: "unknown",
  volume: 1,
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  keyDisabled: false,
  keyTarget: "player",
  keyShortcuts: MEDIA_KEY_SHORTCUTS,
  title: "",
  thumbnails: null,
  textTracks: defineProp({
    value: [],
    attribute: false
  }),
  smallBreakpointX: 600,
  largeBreakpointX: 980,
  smallBreakpointY: 380,
  largeBreakpointY: 600
};
var TimeRange = class {
  get length() {
    return this.Ga.length;
  }
  constructor(start, end) {
    if (isArray(start)) {
      this.Ga = start;
    } else if (!isUndefined(start) && !isUndefined(end)) {
      this.Ga = [[start, end]];
    } else {
      this.Ga = [];
    }
  }
  start(index) {
    return this.Ga[index][0] ?? Infinity;
  }
  end(index) {
    return this.Ga[index][1] ?? Infinity;
  }
};
function getTimeRangesStart(range) {
  if (!range.length)
    return null;
  let min = range.start(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.start(i);
    if (value < min)
      min = value;
  }
  return min;
}
function getTimeRangesEnd(range) {
  if (!range.length)
    return null;
  let max = range.end(0);
  for (let i = 1; i < range.length; i++) {
    const value = range.end(i);
    if (value > max)
      max = value;
  }
  return max;
}
var MediaStoreFactory = new StoreFactory({
  audioTracks: [],
  audioTrack: null,
  autoplay: false,
  autoplayError: void 0,
  buffered: new TimeRange(),
  duration: 0,
  canLoad: false,
  canFullscreen: false,
  canPictureInPicture: false,
  canPlay: false,
  controls: false,
  crossorigin: null,
  poster: "",
  currentTime: 0,
  ended: false,
  error: void 0,
  fullscreen: false,
  loop: false,
  logLevel: "silent",
  mediaType: "unknown",
  muted: false,
  paused: true,
  played: new TimeRange(),
  playing: false,
  playsinline: false,
  pictureInPicture: false,
  preload: "metadata",
  playbackRate: 1,
  qualities: [],
  quality: null,
  autoQuality: false,
  canSetQuality: true,
  seekable: new TimeRange(),
  seeking: false,
  source: { src: "", type: "" },
  sources: [],
  started: false,
  title: "",
  textTracks: [],
  textTrack: null,
  thumbnails: null,
  thumbnailCues: [],
  volume: 1,
  waiting: false,
  get viewType() {
    return this.providedViewType !== "unknown" ? this.providedViewType : this.mediaType;
  },
  get streamType() {
    return this.providedStreamType !== "unknown" ? this.providedStreamType : this.inferredStreamType;
  },
  get currentSrc() {
    return this.source;
  },
  get bufferedStart() {
    return getTimeRangesStart(this.buffered) ?? 0;
  },
  get bufferedEnd() {
    return getTimeRangesEnd(this.buffered) ?? 0;
  },
  get seekableStart() {
    return getTimeRangesStart(this.seekable) ?? 0;
  },
  get seekableEnd() {
    return this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;
  },
  get seekableWindow() {
    return Math.max(0, this.seekableEnd - this.seekableStart);
  },
  // ~~ responsive design ~~
  touchPointer: false,
  orientation: "landscape",
  mediaWidth: 0,
  mediaHeight: 0,
  breakpointX: "sm",
  breakpointY: "sm",
  // ~~ user props ~~
  userIdle: false,
  userBehindLiveEdge: false,
  // ~~ live props ~~
  liveEdgeTolerance: 10,
  minLiveDVRWindow: 60,
  get canSeek() {
    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);
  },
  get live() {
    return this.streamType.includes("live") || !Number.isFinite(this.duration);
  },
  get liveEdgeStart() {
    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;
  },
  get liveEdge() {
    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);
  },
  get liveEdgeWindow() {
    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;
  },
  // ~~ internal props ~~
  autoplaying: false,
  providedViewType: "unknown",
  providedStreamType: "unknown",
  inferredStreamType: "unknown",
  liveSyncPosition: null
});
var DO_NOT_RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([
  "autoplay",
  "breakpointX",
  "breakpointY",
  "canFullscreen",
  "canLoad",
  "canPictureInPicture",
  "controls",
  "fullscreen",
  "logLevel",
  "loop",
  "mediaHeight",
  "mediaWidth",
  "muted",
  "orientation",
  "pictureInPicture",
  "playsinline",
  "poster",
  "preload",
  "providedStreamType",
  "providedViewType",
  "source",
  "sources",
  "textTrack",
  "textTracks",
  "thumbnailCues",
  "thumbnails",
  "title",
  "touchPointer",
  "volume"
]);
function softResetMediaStore($media) {
  MediaStoreFactory.reset($media, (prop2) => !DO_NOT_RESET_ON_SRC_CHANGE.has(prop2));
  tick();
}
var SELECTED = Symbol(0);
var SelectList = class extends List {
  get selected() {
    return this.q.find((item) => item.selected) ?? null;
  }
  get selectedIndex() {
    return this.q.findIndex((item) => item.selected);
  }
  /* @internal */
  [LIST_ON_REMOVE](item, trigger) {
    this[LIST_SELECT](item, false, trigger);
  }
  /* @internal */
  [LIST_ADD](item, trigger) {
    item[SELECTED] = false;
    Object.defineProperty(item, "selected", {
      get() {
        return this[SELECTED];
      },
      set: (selected) => {
        if (this.readonly)
          return;
        this[LIST_ON_USER_SELECT]?.();
        this[LIST_SELECT](item, selected);
      }
    });
    super[LIST_ADD](item, trigger);
  }
  /* @internal */
  [LIST_SELECT](item, selected, trigger) {
    if (selected === item[SELECTED])
      return;
    const prev = this.selected;
    item[SELECTED] = selected;
    const changed = !selected ? prev === item : prev !== item;
    if (changed) {
      if (prev)
        prev[SELECTED] = false;
      this.dispatchEvent(
        new DOMEvent("change", {
          detail: { prev, current: this.selected },
          trigger
        })
      );
    }
  }
};

// src/player/core/quality/video-quality.ts
var VideoQualityList = class extends SelectList {
  constructor() {
    super(...arguments);
    this.vb = false;
    /**
     * Configures quality switching:
     *
     * - `current`: Trigger an immediate quality level switch. This will abort the current fragment
     * request if any, flush the whole buffer, and fetch fragment matching with current position
     * and requested quality level.
     *
     * - `next`: Trigger a quality level switch for next fragment. This could eventually flush
     * already buffered next fragment.
     *
     * - `load`: Set quality level for next loaded fragment.
     *
     * @see {@link https://vidstack.io/docs/player/core-concepts/quality#switch}
     * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}
     */
    this.switch = "current";
  }
  /**
   * Whether automatic quality selection is enabled.
   */
  get auto() {
    return this.vb || this.readonly;
  }
  /* @internal */
  [(LIST_ON_USER_SELECT)]() {
    this[SET_AUTO_QUALITY](false);
  }
  /* @internal */
  [LIST_ON_RESET](trigger) {
    this[SET_AUTO_QUALITY](false, trigger);
  }
  /**
   * Request automatic quality selection (if supported). This will be a no-op if the list is
   * `readonly` as that already implies auto-selection.
   */
  autoSelect(trigger) {
    if (this.readonly || this.vb || !this[ENABLE_AUTO_QUALITY])
      return;
    this[ENABLE_AUTO_QUALITY]();
    this[SET_AUTO_QUALITY](true, trigger);
  }
  /* @internal */
  [SET_AUTO_QUALITY](auto, trigger) {
    if (this.vb === auto)
      return;
    this.vb = auto;
    this.dispatchEvent(
      new DOMEvent("auto-change", {
        detail: auto,
        trigger
      })
    );
  }
};
var MediaUserController = class extends ComponentController {
  constructor() {
    super(...arguments);
    this.cc = -2;
    this.ab = 2e3;
    this.dc = false;
    this.bb = null;
  }
  /**
   * Whether the media user is currently idle.
   */
  get idling() {
    return this.$store.userIdle();
  }
  /**
   * The amount of delay in milliseconds while media playback is progressing without user
   * activity to indicate an idle state.
   *
   * @defaultValue 2000
   */
  get idleDelay() {
    return this.ab;
  }
  set idleDelay(newDelay) {
    this.ab = newDelay;
  }
  /**
   * Change the user idle state.
   */
  idle(idle, delay = this.ab, trigger) {
    this.Bd();
    if (!this.dc)
      this.Cd(idle, delay, trigger);
  }
  /**
   * Whether all idle tracking should be paused until resumed again.
   */
  pauseIdleTracking(paused, trigger) {
    this.dc = paused;
    if (paused) {
      this.Bd();
      this.Cd(false, 0, trigger);
    }
  }
  onConnect() {
    effect(this.ec.bind(this));
    listenEvent(this.el, "play", this.Hf.bind(this));
    listenEvent(this.el, "pause", this.If.bind(this));
  }
  ec() {
    if (this.$store.paused())
      return;
    const onStopIdle = this.Jf.bind(this);
    for (const eventType of ["pointerup", "keydown"]) {
      listenEvent(this.el, eventType, onStopIdle);
    }
    effect(() => {
      if (!this.$store.touchPointer())
        listenEvent(this.el, "pointermove", onStopIdle);
    });
  }
  Hf(event) {
    this.idle(true, this.ab, event);
  }
  If(event) {
    this.idle(false, 0, event);
  }
  Bd() {
    window.clearTimeout(this.cc);
    this.cc = -1;
  }
  Jf(event) {
    if (event.MEDIA_GESTURE)
      return;
    if (isKeyboardEvent(event)) {
      if (event.key === "Escape") {
        this.el?.focus();
        this.bb = null;
      } else if (this.bb) {
        event.preventDefault();
        requestAnimationFrame(() => {
          this.bb?.focus();
          this.bb = null;
        });
      }
    }
    this.idle(false, 0, event);
    this.idle(true, this.ab, event);
  }
  Cd(idle, delay, trigger) {
    if (delay === 0) {
      this.Dd(idle, trigger);
      return;
    }
    this.cc = window.setTimeout(() => {
      this.Dd(idle && !this.dc, trigger);
    }, delay);
  }
  Dd(idle, trigger) {
    if (this.$store.userIdle() === idle)
      return;
    this.$store.userIdle.set(idle);
    if (idle && document.activeElement && this.el?.contains(document.activeElement)) {
      this.bb = document.activeElement;
      requestAnimationFrame(() => this.el?.focus());
    }
    this.dispatch("user-idle-change", {
      detail: idle,
      trigger
    });
  }
};
var MediaRemoteControl = class {
  constructor(_logger) {
    this.Mb = _logger;
    this.ha = null;
    this.ma = null;
    this.lc = -1;
  }
  /**
   * Set the target from which to dispatch media requests events from. The events should bubble
   * up from this target to the `<media-player>` element.
   *
   * @example
   * ```ts
   * const button = document.querySelector('button');
   * remote.setTarget(button);
   * ```
   */
  setTarget(target) {
    this.ha = target;
  }
  /**
   * Returns the current `<media-player>` element. This method will attempt to find the player by
   * searching up from either the given `target` or default target set via `remote.setTarget`.
   *
   * @example
   * ```ts
   * const player = remote.getPlayer();
   * ```
   */
  getPlayer(target) {
    if (this.ma)
      return this.ma;
    (target ?? this.ha)?.dispatchEvent(
      new DOMEvent("find-media-player", {
        detail: (player) => void (this.ma = player),
        bubbles: true,
        composed: true
      })
    );
    return this.ma;
  }
  /**
   * Set the current `<media-player>` element so the remote can support toggle methods such as
   * `togglePaused` as they rely on the current media state.
   */
  setPlayer(player) {
    this.ma = player;
  }
  /**
   * Dispatch a request to start the media loading process. This will only work if the media
   * player has been initialized with a custom loading strategy `<media-player load="custom">`.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#loading-strategies}
   */
  startLoading(trigger) {
    this.t("media-start-loading", trigger);
  }
  /**
   * Dispatch a request to begin/resume media playback.
   */
  play(trigger) {
    this.t("media-play-request", trigger);
  }
  /**
   * Dispatch a request to pause media playback.
   */
  pause(trigger) {
    this.t("media-pause-request", trigger);
  }
  /**
   * Dispatch a request to set the media volume to mute (0).
   */
  mute(trigger) {
    this.t("media-mute-request", trigger);
  }
  /**
   * Dispatch a request to unmute the media volume and set it back to it's previous state.
   */
  unmute(trigger) {
    this.t("media-unmute-request", trigger);
  }
  /**
   * Dispatch a request to enter fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  enterFullscreen(target, trigger) {
    this.t("media-enter-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to exit fullscreen.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  exitFullscreen(target, trigger) {
    this.t("media-exit-fullscreen-request", trigger, target);
  }
  /**
   * Dispatch a request to enter picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  enterPictureInPicture(trigger) {
    this.t("media-enter-pip-request", trigger);
  }
  /**
   * Dispatch a request to exit picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  exitPictureInPicture(trigger) {
    this.t("media-exit-pip-request", trigger);
  }
  /**
   * Notify the media player that a seeking process is happening and to seek to the given `time`.
   */
  seeking(time, trigger) {
    this.t("media-seeking-request", trigger, time);
  }
  /**
   * Notify the media player that a seeking operation has completed and to seek to the given `time`.
   * This is generally called after a series of `remote.seeking()` calls.
   */
  seek(time, trigger) {
    this.t("media-seek-request", trigger, time);
  }
  seekToLiveEdge(trigger) {
    this.t("media-live-edge-request", trigger);
  }
  /**
   * Dispatch a request to update the media volume to the given `volume` level which is a value
   * between 0 and 1.
   *
   * @example
   * ```ts
   * remote.changeVolume(0); // 0%
   * remote.changeVolume(0.05); // 5%
   * remote.changeVolume(0.5); // 50%
   * remote.changeVolume(0.75); // 70%
   * remote.changeVolume(1); // 100%
   * ```
   */
  changeVolume(volume, trigger) {
    this.t("media-volume-change-request", trigger, Math.max(0, Math.min(1, volume)));
  }
  /**
   * Dispatch a request to change the current audio track.
   *
   * @example
   * ```ts
   * remote.changeAudioTrack(1); // track at index 1
   * ```
   */
  changeAudioTrack(index, trigger) {
    this.t("media-audio-track-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the video quality. The special value `-1` represents auto quality
   * selection.
   *
   * @example
   * ```ts
   * remote.changeQuality(-1); // auto
   * remote.changeQuality(1); // quality at index 1
   * ```
   */
  changeQuality(index, trigger) {
    this.t("media-quality-change-request", trigger, index);
  }
  /**
   * Dispatch a request to change the mode of the text track at the given index.
   *
   * @example
   * ```ts
   * remote.changeTextTrackMode(1, 'showing'); // track at index 1
   * ```
   */
  changeTextTrackMode(index, mode, trigger) {
    this.t("media-text-track-change-request", trigger, {
      index,
      mode
    });
  }
  /**
   * Dispatch a request to change the media playback rate.
   *
   * @example
   * ```ts
   * remote.changePlaybackRate(0.5); // Half the normal speed
   * remote.changePlaybackRate(1); // Normal speed
   * remote.changePlaybackRate(1.5); // 50% faster than normal
   * remote.changePlaybackRate(2); // Double the normal speed
   * ```
   */
  changePlaybackRate(rate, trigger) {
    this.t("media-rate-change-request", trigger, rate);
  }
  /**
   * Dispatch a request to resume user idle tracking. Refer to {@link MediaRemoteControl.pauseUserIdle}
   * for more information.
   */
  resumeUserIdle(trigger) {
    this.t("media-resume-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to pause user idle tracking. Pausing tracking will result in the `user-idle`
   * attribute and state being `false` until `remote.resumeUserIdle()` is called. This method
   * is generally used when building custom controls and you'd like to prevent the UI from
   * dissapearing.
   *
   * @example
   * ```ts
   * // Prevent user idling while menu is being interacted with.
   * function onSettingsOpen() {
   *   remote.pauseUserIdle();
   * }
   *
   * function onSettingsClose() {
   *   remote.resumeUserIdle();
   * }
   * ```
   */
  pauseUserIdle(trigger) {
    this.t("media-pause-user-idle-request", trigger);
  }
  /**
   * Dispatch a request to toggle the media playback state.
   */
  togglePaused(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    if (player.state.paused)
      this.play(trigger);
    else
      this.pause(trigger);
  }
  /**
   * Dispatch a request to toggle the user idle state.
   */
  toggleUserIdle(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    player.user.idle(!player.user.idling, 0, trigger);
  }
  /**
   * Dispatch a request to toggle the media muted state.
   */
  toggleMuted(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    if (player.state.muted)
      this.unmute(trigger);
    else
      this.mute(trigger);
  }
  /**
   * Dispatch a request to toggle the media fullscreen state.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/fullscreen#media-remote}
   */
  toggleFullscreen(target, trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    if (player.state.fullscreen)
      this.exitFullscreen(target, trigger);
    else
      this.enterFullscreen(target, trigger);
  }
  /**
   * Dispatch a request to toggle the media picture-in-picture mode.
   *
   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/picture-in-picture#media-remote}
   */
  togglePictureInPicture(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    if (player.state.pictureInPicture)
      this.exitPictureInPicture(trigger);
    else
      this.enterPictureInPicture(trigger);
  }
  /**
   * Dispatch a request to toggle the current captions mode.
   */
  toggleCaptions(trigger) {
    const player = this.getPlayer(trigger?.target);
    if (!player) {
      return;
    }
    const tracks = player.state.textTracks, track = player.state.textTrack;
    if (track) {
      const index = tracks.indexOf(track);
      this.changeTextTrackMode(index, "disabled", trigger);
      this.lc = index;
    } else {
      let index = this.lc;
      if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {
        index = -1;
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2) && track2.default);
      }
      if (index === -1) {
        index = tracks.findIndex((track2) => isTrackCaptionKind(track2));
      }
      if (index >= 0)
        this.changeTextTrackMode(index, "showing", trigger);
      this.lc = -1;
    }
  }
  t(type, trigger, detail) {
    const request = new DOMEvent(type, {
      bubbles: true,
      composed: true,
      detail,
      trigger
    });
    const shouldUsePlayer = trigger?.target && (trigger.target === document || trigger.target === window || trigger.target === document.body || this.ma && !this.ma.contains(trigger.target));
    const target = shouldUsePlayer ? this.ha ?? this.getPlayer() : trigger?.target ?? this.ha;
    target?.dispatchEvent(request);
  }
  wi(method2) {
  }
};

// src/player/core/tracks/audio-tracks.ts
var AudioTrackList = class extends SelectList {
  getById(id) {
    if (id === "")
      return null;
    return this.q.find((track) => track.id === id) ?? null;
  }
};

// src/player/core/tracks/text/render/native-text-renderer.ts
var NativeTextRenderer = class {
  constructor() {
    this.priority = 0;
    this.Qd = true;
    this.k = null;
    this.m = null;
    this.db = /* @__PURE__ */ new Set();
  }
  canRender() {
    return true;
  }
  attach(video) {
    this.k = video;
    if (!video.crossOrigin)
      video.crossOrigin = "anonymous";
    video.textTracks.onchange = this.o.bind(this);
  }
  addTrack(track) {
    this.db.add(track);
    this.dg(track);
  }
  removeTrack(track) {
    track[TEXT_TRACK_NATIVE]?.remove?.();
    track[TEXT_TRACK_NATIVE] = null;
    this.db.delete(track);
  }
  changeTrack(track) {
    const prev = this.m?.[TEXT_TRACK_NATIVE], current = track?.[TEXT_TRACK_NATIVE];
    if (prev && this.m !== track)
      prev.track.mode = "disabled";
    if (current)
      current.track.mode = "showing";
    this.m = track;
  }
  setDisplay(display) {
    this.Qd = display;
  }
  detach() {
    if (this.k)
      this.k.textTracks.onchange = null;
    for (const track of this.db)
      this.removeTrack(track);
    this.db.clear();
    this.k = null;
    this.m = null;
  }
  dg(track) {
    if (!this.k)
      return;
    const el = track[TEXT_TRACK_NATIVE] ??= this.eg(track);
    if (el instanceof HTMLElement)
      this.k.append(el);
  }
  eg(track) {
    const el = document.createElement("track");
    el.src = "https://cdn.jsdelivr.net/npm/vidstack/empty.vtt";
    el.id = track.id;
    el.label = track.label;
    el.kind = track.kind;
    el.default = track.default;
    track.language && (el.srclang = track.language);
    return el;
  }
  fg(track, native) {
    if (native.cues?.length)
      return;
    for (const cue of track.cues)
      native.addCue(cue);
  }
  o(event) {
    for (const track of this.db) {
      const nativeTrack = track[TEXT_TRACK_NATIVE]?.track;
      if (!nativeTrack)
        continue;
      if (!this.Qd) {
        nativeTrack.mode = "disabled";
        continue;
      }
      if (nativeTrack.mode === "showing") {
        this.fg(track, nativeTrack);
        track.setMode("showing", event);
      } else if (track.mode === "showing") {
        track.setMode("disabled", event);
      }
    }
  }
};

// src/player/core/tracks/text/render/text-renderer.ts
var TextRenderers = class {
  constructor(_media) {
    this.a = _media;
    this.k = null;
    this.xb = [];
    this.Rd = false;
    this.Q = null;
    this.na = null;
    const textTracks = _media.textTracks;
    this.mc = textTracks;
    effect(this.gg.bind(this));
    onDispose(this.Sd.bind(this));
    listenEvent(textTracks, "add", this.Vb.bind(this));
    listenEvent(textTracks, "remove", this.hg.bind(this));
    listenEvent(textTracks, "mode-change", this.V.bind(this));
  }
  gg() {
    const { $store, $iosControls } = this.a;
    this.Rd = $store.controls() || $iosControls();
    this.V();
  }
  add(renderer) {
    this.xb.push(renderer);
    this.V();
  }
  remove(renderer) {
    renderer.detach();
    this.xb.splice(this.xb.indexOf(renderer), 1);
    this.V();
  }
  /* @internal */
  [ATTACH_VIDEO](video) {
    requestAnimationFrame(() => {
      this.k = video;
      if (video) {
        this.Q = new NativeTextRenderer();
        this.Q.attach(video);
        for (const track of this.mc)
          this.Td(track);
      }
      this.V();
    });
  }
  Td(track) {
    if (!isTrackCaptionKind(track))
      return;
    this.Q?.addTrack(track);
  }
  ig(track) {
    if (!isTrackCaptionKind(track))
      return;
    this.Q?.removeTrack(track);
  }
  Vb(event) {
    this.Td(event.detail);
  }
  hg(event) {
    this.ig(event.detail);
  }
  V() {
    if (!this.k) {
      this.Sd();
      return;
    }
    const currentTrack = this.mc.selected;
    if (this.Rd || currentTrack?.[TEXT_TRACK_NATIVE_HLS]) {
      this.na?.changeTrack(null);
      this.Q.setDisplay(true);
      this.Q.changeTrack(currentTrack);
      return;
    }
    this.Q.setDisplay(false);
    this.Q.changeTrack(null);
    if (!currentTrack) {
      this.na?.changeTrack(null);
      return;
    }
    const customRenderer = this.xb.sort((a, b) => a.priority - b.priority).find((loader) => loader.canRender(currentTrack));
    if (this.na !== customRenderer) {
      this.na?.detach();
      customRenderer?.attach(this.k);
      this.na = customRenderer ?? null;
    }
    customRenderer?.changeTrack(currentTrack);
  }
  Sd() {
    this.Q?.detach();
    this.Q = null;
    this.na?.detach();
    this.na = null;
  }
};
var TextTrackList = class extends List {
  constructor() {
    super(...arguments);
    this.Da = false;
    this.yb = {};
    this.Ud = this.oa.bind(this);
  }
  get selected() {
    const track = this.q.find((t) => t.mode === "showing" && isTrackCaptionKind(t));
    return track ?? null;
  }
  add(init, trigger) {
    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init);
    if (this.yb[init.kind] && init.default)
      delete init.default;
    track.addEventListener("mode-change", this.Ud);
    this[LIST_ADD](track, trigger);
    track[TEXT_TRACK_CROSSORIGIN] = this[TEXT_TRACK_CROSSORIGIN];
    if (this.Da)
      track[TEXT_TRACK_CAN_LOAD]();
    if (init.default) {
      this.yb[init.kind] = track;
      track.mode = "showing";
    }
    return this;
  }
  remove(track, trigger) {
    if (!this.q.includes(track))
      return;
    if (track === this.yb[track.kind])
      delete this.yb[track.kind];
    track.mode = "disabled";
    track[TEXT_TRACK_ON_MODE_CHANGE] = null;
    track.removeEventListener("mode-change", this.Ud);
    this[LIST_REMOVE](track, trigger);
    return this;
  }
  clear(trigger) {
    for (const track of this.q)
      this.remove(track, trigger);
    return this;
  }
  getById(id) {
    return this.q.find((track) => track.id === id) ?? null;
  }
  getByKind(kind) {
    const kinds = Array.isArray(kind) ? kind : [kind];
    return this.q.filter((track) => kinds.includes(track.kind));
  }
  /* @internal */
  [(TEXT_TRACK_CAN_LOAD)]() {
    if (this.Da)
      return;
    for (const track of this.q)
      track[TEXT_TRACK_CAN_LOAD]();
    this.Da = true;
  }
  oa(event) {
    const track = event.detail;
    if (track.mode === "showing") {
      const kinds = isTrackCaptionKind(track) ? ["captions", "subtitles"] : [track.kind];
      for (const t of this.q) {
        if (t.mode === "showing" && t != track && kinds.includes(t.kind)) {
          t.mode = "disabled";
        }
      }
    }
    this.dispatchEvent(
      new DOMEvent("mode-change", {
        detail: event.detail,
        trigger: event
      })
    );
  }
};
var RequestQueue = class {
  constructor() {
    this.Va = false;
    this.Pb = deferredPromise();
    this.f = /* @__PURE__ */ new Map();
  }
  /**
   * The number of callbacks that are currently in queue.
   */
  get Le() {
    return this.f.size;
  }
  /**
   * Whether items in the queue are being served immediately, otherwise they're queued to
   * be processed later.
   */
  get ri() {
    return this.Va;
  }
  /**
   * Waits for the queue to be flushed (ie: start serving).
   */
  async si() {
    if (this.Va)
      return;
    await this.Pb.promise;
  }
  /**
   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or
   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),
   * then the callback will be invoked immediately.
   *
   * @param key - Uniquely identifies this callback so duplicates are ignored.
   * @param callback - The function to call when this item in the queue is being served.
   */
  l(key2, callback) {
    if (this.Va) {
      callback();
      return;
    }
    this.f.delete(key2);
    this.f.set(key2, callback);
  }
  /**
   * Invokes the callback with the given `key` in the queue (if it exists).
   */
  Qb(key2) {
    this.f.get(key2)?.();
    this.f.delete(key2);
  }
  /**
   * Flush all queued items and start serving future requests immediately until `stop()` is called.
   */
  pb() {
    this.hd();
    this.Va = true;
    if (this.f.size > 0)
      this.hd();
  }
  /**
   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.
   */
  ia() {
    this.Va = false;
  }
  /**
   * Stop serving requests, empty the request queue, and release any promises waiting for the
   * queue to flush.
   */
  Me() {
    this.ia();
    this.f.clear();
    this.jd();
  }
  hd() {
    for (const key2 of this.f.keys())
      this.Qb(key2);
    this.jd();
  }
  jd() {
    this.Pb.resolve();
    this.Pb = deferredPromise();
  }
};

// src/player/core/api/media-attrs.ts
var MEDIA_ATTRIBUTES = [
  "autoplay",
  "autoplayError",
  "canFullscreen",
  "canPictureInPicture",
  "canLoad",
  "canPlay",
  "canSeek",
  "ended",
  "error",
  "fullscreen",
  "loop",
  "live",
  "liveEdge",
  "mediaType",
  "muted",
  "paused",
  "pictureInPicture",
  "playing",
  "playsinline",
  "seeking",
  "started",
  "streamType",
  "userIdle",
  "viewType",
  "waiting"
];
var MediaLoadController = class extends ComponentController {
  constructor(instance, _callback) {
    super(instance);
    this.ja = _callback;
  }
  async onAttach(el) {
    const load = this.$props.load();
    if (load === "eager") {
      requestAnimationFrame(this.ja);
    } else if (load === "idle") {
      const { waitIdlePeriod } = await import('maverick.js/std');
      waitIdlePeriod(this.ja);
    } else if (load === "visible") {
      const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          observer.disconnect();
          this.ja();
        }
      });
      observer.observe(el);
      return observer.disconnect.bind(observer);
    }
  }
};
var MediaPlayerDelegate = class {
  constructor(_handle, _media) {
    this.O = _handle;
    this.a = _media;
  }
  d(type, ...init) {
    this.O(new DOMEvent(type, init?.[0]));
  }
  async pd(info, trigger) {
    const { $store, logger } = this.a;
    if (peek($store.canPlay))
      return;
    this.d("can-play", { detail: info, trigger });
    tick();
    if ($store.canPlay() && $store.autoplay() && !$store.started()) {
      await this.Gf();
    }
  }
  async Gf() {
    const { player, $store } = this.a;
    $store.autoplaying.set(true);
    try {
      await player.play();
      this.d("autoplay", { detail: { muted: $store.muted() } });
    } catch (error) {
      this.d("autoplay-fail", {
        detail: {
          muted: $store.muted(),
          error
        }
      });
    } finally {
      $store.autoplaying.set(false);
    }
  }
};

// src/foundation/queue/queue.ts
var Queue = class {
  constructor() {
    this.f = /* @__PURE__ */ new Map();
  }
  /**
   * Queue the given `item` under the given `key` to be processed at a later time by calling
   * `serve(key)`.
   */
  l(key2, item) {
    if (!this.f.has(key2))
      this.f.set(key2, /* @__PURE__ */ new Set());
    this.f.get(key2).add(item);
  }
  /**
   * Process all items in queue for the given `key`.
   */
  Qb(key2, callback) {
    const items = this.f.get(key2);
    if (items)
      for (const item of items)
        callback(item);
    this.f.delete(key2);
  }
  /**
   * Removes all queued items under the given `key`.
   */
  Ad(key2) {
    this.f.delete(key2);
  }
  /**
   * The number of items currently queued under the given `key`.
   */
  Le(key2) {
    return this.f.get(key2)?.size ?? 0;
  }
  /**
   * Clear all items in the queue.
   */
  Me() {
    this.f.clear();
  }
};

// src/player/core/state/media-request-manager.ts
var MediaRequestContext = class {
  constructor() {
    this.ca = false;
    this.da = false;
    this.Ha = false;
    this.f = new Queue();
  }
};
var MediaRequestManager = class extends ComponentController {
  constructor(instance, _stateMgr, _request, _media) {
    super(instance);
    this.P = _stateMgr;
    this.e = _request;
    this.a = _media;
    this.gc = false;
    this.b = _media.$store;
    this.j = _media.$provider;
    this.cb = new MediaUserController(instance);
    this.Ia = new FullscreenController(instance);
    this.K = new ScreenOrientationController(instance);
  }
  onConnect() {
    effect(this.Kf.bind(this));
    effect(this.Lf.bind(this));
    effect(this.Mf.bind(this));
    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), handle = this.Nf.bind(this);
    for (const name of names) {
      if (name.startsWith("media-")) {
        this.listen(name, handle);
      }
    }
    this.listen("fullscreen-change", this.Lb.bind(this));
  }
  Nf(event) {
    event.stopPropagation();
    if (peek(this.j))
      this[event.type]?.(event);
  }
  async fc() {
    const { canPlay, paused, ended, autoplaying, seekableStart } = this.b;
    if (!peek(paused))
      return;
    try {
      const provider = peek(this.j);
      throwIfNotReadyForPlayback(provider, peek(canPlay));
      if (peek(ended)) {
        provider.currentTime = seekableStart() + 0.1;
      }
      return provider.play();
    } catch (error) {
      const errorEvent = this.createEvent("play-fail", { detail: coerceToError(error) });
      errorEvent.autoplay = autoplaying();
      this.P.O(errorEvent);
      throw error;
    }
  }
  async Ed() {
    const { canPlay, paused } = this.b;
    if (peek(paused))
      return;
    const provider = peek(this.j);
    throwIfNotReadyForPlayback(provider, peek(canPlay));
    return provider.pause();
  }
  Fd() {
    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.b;
    userBehindLiveEdge.set(false);
    if (peek(() => !live() || liveEdge() || !canSeek()))
      return;
    const provider = peek(this.j);
    throwIfNotReadyForPlayback(provider, peek(canPlay));
    provider.currentTime = liveSyncPosition() ?? seekableEnd() - 2;
  }
  async Gd(target = "prefer-media") {
    const provider = peek(this.j);
    const adapter = target === "prefer-media" && this.Ia.supported || target === "media" ? this.Ia : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (adapter.active)
      return;
    if (peek(this.b.pictureInPicture)) {
      this.gc = true;
      await this.hc();
    }
    return adapter.enter();
  }
  async Hd(target = "prefer-media") {
    const provider = peek(this.j);
    const adapter = target === "prefer-media" && this.Ia.supported || target === "media" ? this.Ia : provider?.fullscreen;
    throwIfFullscreenNotSupported(target, adapter);
    if (!adapter.active)
      return;
    if (this.K.locked)
      await this.K.unlock();
    try {
      const result = await adapter.exit();
      if (this.gc && peek(this.b.canPictureInPicture)) {
        await this.ic();
      }
      return result;
    } finally {
      this.gc = false;
    }
  }
  async ic() {
    this.Id();
    if (this.b.pictureInPicture())
      return;
    return await this.j().pictureInPicture.enter();
  }
  async hc() {
    this.Id();
    if (!this.b.pictureInPicture())
      return;
    return await this.j().pictureInPicture.exit();
  }
  Id() {
    if (this.b.canPictureInPicture())
      return;
    throw Error(
      "[vidstack] no pip support"
    );
  }
  Kf() {
    this.cb.idleDelay = this.$props.userIdleDelay();
  }
  Lf() {
    const { canLoad, canFullscreen: canFullscreen2 } = this.b, supported = this.Ia.supported || this.j()?.fullscreen?.supported || false;
    if (canLoad() && peek(canFullscreen2) === supported)
      return;
    canFullscreen2.set(supported);
  }
  Mf() {
    const { canLoad, canPictureInPicture } = this.b, supported = this.j()?.pictureInPicture?.supported || false;
    if (canLoad() && peek(canPictureInPicture) === supported)
      return;
    canPictureInPicture.set(supported);
  }
  ["media-audio-track-change-request"](event) {
    if (this.a.audioTracks.readonly) {
      return;
    }
    const index = event.detail, track = this.a.audioTracks[index];
    if (track) {
      this.e.f.l("audioTrack", event);
      track.selected = true;
    }
  }
  async ["media-enter-fullscreen-request"](event) {
    try {
      this.e.f.l("fullscreen", event);
      await this.Gd(event.detail);
    } catch (error) {
      this.mb(error);
    }
  }
  async ["media-exit-fullscreen-request"](event) {
    try {
      this.e.f.l("fullscreen", event);
      await this.Hd(event.detail);
    } catch (error) {
      this.mb(error);
    }
  }
  async Lb(event) {
    if (!event.detail)
      return;
    try {
      const lockType = peek(this.$props.fullscreenOrientation);
      if (this.K.supported && !isUndefined(lockType)) {
        await this.K.lock(lockType);
      }
    } catch (e) {
    }
  }
  mb(error) {
    this.P.O(
      this.createEvent("fullscreen-error", {
        detail: coerceToError(error)
      })
    );
  }
  async ["media-enter-pip-request"](event) {
    try {
      this.e.f.l("pip", event);
      await this.ic();
    } catch (error) {
      this.Jd(error);
    }
  }
  async ["media-exit-pip-request"](event) {
    try {
      this.e.f.l("pip", event);
      await this.hc();
    } catch (error) {
      this.Jd(error);
    }
  }
  Jd(error) {
    this.P.O(
      this.createEvent("picture-in-picture-error", {
        detail: coerceToError(error)
      })
    );
  }
  ["media-live-edge-request"](event) {
    const { live, liveEdge, canSeek } = this.b;
    if (!live() || liveEdge() || !canSeek())
      return;
    this.e.f.l("seeked", event);
    try {
      this.Fd();
    } catch (e) {
    }
  }
  ["media-loop-request"]() {
    window.requestAnimationFrame(async () => {
      try {
        this.e.da = true;
        this.e.Ha = true;
        await this.fc();
      } catch (e) {
        this.e.da = false;
        this.e.Ha = false;
      }
    });
  }
  async ["media-pause-request"](event) {
    if (this.b.paused())
      return;
    try {
      this.e.f.l("pause", event);
      await this.j().pause();
    } catch (e) {
      this.e.f.Ad("pause");
    }
  }
  async ["media-play-request"](event) {
    if (!this.b.paused())
      return;
    try {
      this.e.f.l("play", event);
      await this.j().play();
    } catch (e) {
      const errorEvent = this.createEvent("play-fail", { detail: coerceToError(e) });
      this.P.O(errorEvent);
    }
  }
  ["media-rate-change-request"](event) {
    if (this.b.playbackRate() === event.detail)
      return;
    this.e.f.l("rate", event);
    this.j().playbackRate = event.detail;
  }
  ["media-quality-change-request"](event) {
    if (this.a.qualities.readonly) {
      return;
    }
    this.e.f.l("quality", event);
    const index = event.detail;
    if (index < 0) {
      this.a.qualities.autoSelect(event);
    } else {
      const quality = this.a.qualities[index];
      if (quality) {
        quality.selected = true;
      }
    }
  }
  ["media-resume-user-idle-request"](event) {
    this.e.f.l("userIdle", event);
    this.cb.pauseIdleTracking(false, event);
  }
  ["media-pause-user-idle-request"](event) {
    this.e.f.l("userIdle", event);
    this.cb.pauseIdleTracking(true, event);
  }
  ["media-seek-request"](event) {
    const { seekableStart, seekableEnd, ended, canSeek, live, userBehindLiveEdge } = this.b;
    if (ended())
      this.e.Ha = true;
    this.e.ca = false;
    this.e.f.Ad("seeking");
    const boundTime = Math.min(Math.max(seekableStart() + 0.1, event.detail), seekableEnd() - 0.1);
    if (!Number.isFinite(boundTime) || !canSeek())
      return;
    this.e.f.l("seeked", event);
    this.j().currentTime = boundTime;
    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundTime) >= 2) {
      userBehindLiveEdge.set(true);
    }
  }
  ["media-seeking-request"](event) {
    this.e.f.l("seeking", event);
    this.b.seeking.set(true);
    this.e.ca = true;
  }
  ["media-start-loading"](event) {
    if (this.b.canLoad())
      return;
    this.e.f.l("load", event);
    this.P.O(this.createEvent("can-load"));
  }
  ["media-text-track-change-request"](event) {
    const { index, mode } = event.detail, track = this.a.textTracks[index];
    if (track) {
      this.e.f.l("textTrack", event);
      track.setMode(mode, event);
    }
  }
  ["media-mute-request"](event) {
    if (this.b.muted())
      return;
    this.e.f.l("volume", event);
    this.j().muted = true;
  }
  ["media-unmute-request"](event) {
    const { muted, volume } = this.b;
    if (!muted())
      return;
    this.e.f.l("volume", event);
    this.a.$provider().muted = false;
    if (volume() === 0) {
      this.e.f.l("volume", event);
      this.j().volume = 0.25;
    }
  }
  ["media-volume-change-request"](event) {
    const { muted, volume } = this.b;
    const newVolume = event.detail;
    if (volume() === newVolume)
      return;
    this.e.f.l("volume", event);
    this.j().volume = newVolume;
    if (newVolume > 0 && muted()) {
      this.e.f.l("volume", event);
      this.j().muted = false;
    }
  }
};
function throwIfNotReadyForPlayback(provider, canPlay) {
  if (provider && canPlay)
    return;
  throw Error(
    "[vidstack] media not ready"
  );
}
function throwIfFullscreenNotSupported(target, fullscreen) {
  if (fullscreen?.supported)
    return;
  throw Error(
    "[vidstack] no fullscreen support"
  );
}

// ../../node_modules/.pnpm/just-debounce-it@3.2.0/node_modules/just-debounce-it/index.mjs
var functionDebounce = debounce;
function debounce(fn, wait, callFirst) {
  var timeout = null;
  var debouncedFn = null;
  var clear = function() {
    if (timeout) {
      clearTimeout(timeout);
      debouncedFn = null;
      timeout = null;
    }
  };
  var flush = function() {
    var call = debouncedFn;
    clear();
    if (call) {
      call();
    }
  };
  var debounceWrapper = function() {
    if (!wait) {
      return fn.apply(this, arguments);
    }
    var context = this;
    var args = arguments;
    var callNow = callFirst && !timeout;
    clear();
    debouncedFn = function() {
      fn.apply(context, args);
    };
    timeout = setTimeout(function() {
      timeout = null;
      if (!callNow) {
        var call = debouncedFn;
        debouncedFn = null;
        return call();
      }
    }, wait);
    if (callNow) {
      return debouncedFn();
    }
  };
  debounceWrapper.cancel = clear;
  debounceWrapper.flush = flush;
  return debounceWrapper;
}

// src/player/core/state/tracked-media-events.ts
var TRACKED_EVENT = /* @__PURE__ */ new Set([
  "autoplay",
  "autoplay-fail",
  "can-load",
  "sources-change",
  "source-change",
  "load-start",
  "abort",
  "error",
  "loaded-metadata",
  "loaded-data",
  "can-play",
  "play",
  "play-fail",
  "pause",
  "playing",
  "seeking",
  "seeked",
  "waiting"
]);

// src/player/core/state/media-state-manager.ts
var MediaStateManager = class extends ComponentController {
  constructor(instance, _request, _media) {
    super(instance);
    this.e = _request;
    this.a = _media;
    this.n = /* @__PURE__ */ new Map();
    this.Kd = true;
    this.wb = false;
    this["seeking"] = functionThrottle(
      (event) => {
        const { seeking, currentTime, paused } = this.b;
        seeking.set(true);
        currentTime.set(event.detail);
        this.C("seeking", event);
        if (paused()) {
          this.Ja = event;
          this.kc();
        }
      },
      150,
      { leading: true }
    );
    this.kc = functionDebounce(() => {
      if (!this.Ja)
        return;
      this.wb = true;
      const { waiting, playing } = this.b;
      waiting.set(true);
      playing.set(false);
      const event = this.createEvent("waiting", { trigger: this.Ja });
      this.n.set("waiting", event);
      this.el.dispatchEvent(event);
      this.Ja = void 0;
      this.wb = false;
    }, 300);
    this.b = _media.$store;
  }
  onAttach(el) {
    el.setAttribute("aria-busy", "true");
  }
  onConnect(el) {
    this.Of();
    this.Pf();
    this.Qf();
    this.listen("fullscreen-change", this["fullscreen-change"].bind(this));
    this.listen("fullscreen-error", this["fullscreen-error"].bind(this));
  }
  O(event) {
    const type = event.type;
    this[event.type]?.(event);
    {
      if (TRACKED_EVENT.has(type))
        this.n.set(type, event);
      this.el?.dispatchEvent(event);
    }
  }
  Ka() {
    this.Ld();
    this.e.Ha = false;
    this.e.da = false;
    this.wb = false;
    this.Ja = void 0;
    this.n.clear();
  }
  C(request, event) {
    this.e.f.Qb(request, (requestEvent) => {
      event.request = requestEvent;
      appendTriggerEvent(event, requestEvent);
    });
  }
  Of() {
    this.jc();
    this.Md();
    const textTracks = this.a.textTracks;
    listenEvent(textTracks, "add", this.jc.bind(this));
    listenEvent(textTracks, "remove", this.jc.bind(this));
    listenEvent(textTracks, "mode-change", this.Md.bind(this));
  }
  Pf() {
    const qualities = this.a.qualities;
    listenEvent(qualities, "add", this.Nd.bind(this));
    listenEvent(qualities, "remove", this.Nd.bind(this));
    listenEvent(qualities, "change", this.Zb.bind(this));
    listenEvent(qualities, "auto-change", this.Rf.bind(this));
    listenEvent(qualities, "readonly-change", this.Sf.bind(this));
  }
  Qf() {
    const audioTracks = this.a.audioTracks;
    listenEvent(audioTracks, "add", this.Od.bind(this));
    listenEvent(audioTracks, "remove", this.Od.bind(this));
    listenEvent(audioTracks, "change", this.Tf.bind(this));
  }
  jc(event) {
    const { textTracks } = this.b;
    textTracks.set(this.a.textTracks.toArray());
    this.dispatch("text-tracks-change", {
      detail: textTracks(),
      trigger: event
    });
  }
  Md(event) {
    if (event)
      this.C("textTrack", event);
    const current = this.a.textTracks.selected, { textTrack } = this.b;
    if (textTrack() !== current) {
      textTrack.set(current);
      this.dispatch("text-track-change", {
        detail: current,
        trigger: event
      });
    }
  }
  Od(event) {
    const { audioTracks } = this.b;
    audioTracks.set(this.a.audioTracks.toArray());
    this.dispatch("audio-tracks-change", {
      detail: audioTracks(),
      trigger: event
    });
  }
  Tf(event) {
    const { audioTrack } = this.b;
    audioTrack.set(this.a.audioTracks.selected);
    this.C("audioTrack", event);
    this.dispatch("audio-track-change", {
      detail: audioTrack(),
      trigger: event
    });
  }
  Nd(event) {
    const { qualities } = this.b;
    qualities.set(this.a.qualities.toArray());
    this.dispatch("qualities-change", {
      detail: qualities(),
      trigger: event
    });
  }
  Zb(event) {
    const { quality } = this.b;
    quality.set(this.a.qualities.selected);
    this.C("quality", event);
    this.dispatch("quality-change", {
      detail: quality(),
      trigger: event
    });
  }
  Rf() {
    this.b.autoQuality.set(this.a.qualities.auto);
  }
  Sf() {
    this.b.canSetQuality.set(!this.a.qualities.readonly);
  }
  ["provider-change"](event) {
    this.a.$provider.set(event.detail);
  }
  ["autoplay"](event) {
    appendTriggerEvent(event, this.n.get("play"));
    appendTriggerEvent(event, this.n.get("can-play"));
    this.b.autoplayError.set(void 0);
  }
  ["autoplay-fail"](event) {
    appendTriggerEvent(event, this.n.get("play-fail"));
    appendTriggerEvent(event, this.n.get("can-play"));
    this.b.autoplayError.set(event.detail);
    this.Ka();
  }
  ["can-load"](event) {
    this.b.canLoad.set(true);
    this.n.set("can-load", event);
    this.C("load", event);
    this.a.textTracks[TEXT_TRACK_CAN_LOAD]();
  }
  ["media-type-change"](event) {
    appendTriggerEvent(event, this.n.get("source-change"));
    const viewType = this.b.viewType();
    this.b.mediaType.set(event.detail);
    if (viewType !== this.b.viewType()) {
      setTimeout(
        () => this.dispatch("view-type-change", {
          detail: this.b.viewType(),
          trigger: event
        }),
        0
      );
    }
  }
  ["stream-type-change"](event) {
    const { streamType, inferredStreamType } = this.b;
    appendTriggerEvent(event, this.n.get("source-change"));
    inferredStreamType.set(event.detail);
    event.detail = streamType();
  }
  ["rate-change"](event) {
    this.b.playbackRate.set(event.detail);
    this.C("rate", event);
  }
  ["sources-change"](event) {
    this.b.sources.set(event.detail);
  }
  ["source-change"](event) {
    appendTriggerEvent(event, this.n.get("sources-change"));
    this.b.source.set(event.detail);
    this.el?.setAttribute("aria-busy", "true");
    if (this.Kd) {
      this.Kd = false;
      return;
    }
    this.a.audioTracks[LIST_RESET](event);
    this.a.qualities[LIST_RESET](event);
    this.Ka();
    softResetMediaStore(this.a.$store);
    this.n.set(event.type, event);
  }
  ["abort"](event) {
    appendTriggerEvent(event, this.n.get("source-change"));
    appendTriggerEvent(event, this.n.get("can-load"));
  }
  ["load-start"](event) {
    appendTriggerEvent(event, this.n.get("source-change"));
  }
  ["error"](event) {
    this.b.error.set(event.detail);
    appendTriggerEvent(event, this.n.get("abort"));
  }
  ["loaded-metadata"](event) {
    appendTriggerEvent(event, this.n.get("load-start"));
  }
  ["loaded-data"](event) {
    appendTriggerEvent(event, this.n.get("load-start"));
  }
  ["can-play"](event) {
    if (event.trigger?.type !== "loadedmetadata") {
      appendTriggerEvent(event, this.n.get("loaded-metadata"));
    }
    this.Pd(event.detail);
    this.el?.setAttribute("aria-busy", "false");
  }
  ["can-play-through"](event) {
    this.Pd(event.detail);
    appendTriggerEvent(event, this.n.get("can-play"));
  }
  Pd(detail) {
    const { seekable, seekableEnd, buffered, duration, canPlay } = this.b;
    seekable.set(detail.seekable);
    buffered.set(detail.buffered);
    duration.set(seekableEnd);
    canPlay.set(true);
  }
  ["duration-change"](event) {
    const { live, duration } = this.b, time = event.detail;
    if (!live())
      duration.set(!Number.isNaN(time) ? time : 0);
  }
  ["progress"](event) {
    const { buffered, seekable, live, duration, seekableEnd } = this.b, detail = event.detail;
    buffered.set(detail.buffered);
    seekable.set(detail.seekable);
    if (live()) {
      duration.set(seekableEnd);
      this.dispatch("duration-change", {
        detail: seekableEnd(),
        trigger: event
      });
    }
  }
  ["play"](event) {
    const { paused, autoplayError, ended, autoplaying } = this.b;
    event.autoplay = autoplaying();
    if (this.e.da || !paused()) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this.n.get("waiting"));
    this.C("play", event);
    paused.set(false);
    autoplayError.set(void 0);
    if (ended() || this.e.Ha) {
      this.e.Ha = false;
      ended.set(false);
      this.O(this.createEvent("replay", { trigger: event }));
    }
  }
  ["play-fail"](event) {
    appendTriggerEvent(event, this.n.get("play"));
    this.C("play", event);
    const { paused, playing } = this.b;
    paused.set(true);
    playing.set(false);
    this.Ka();
  }
  ["playing"](event) {
    const playEvent = this.n.get("play");
    if (playEvent) {
      appendTriggerEvent(event, this.n.get("waiting"));
      appendTriggerEvent(event, playEvent);
    } else {
      appendTriggerEvent(event, this.n.get("seeked"));
    }
    setTimeout(() => this.Ka(), 0);
    const { paused, playing, seeking, ended } = this.b;
    paused.set(false);
    playing.set(true);
    seeking.set(false);
    ended.set(false);
    if (this.e.da) {
      event.stopImmediatePropagation();
      this.e.da = false;
      return;
    }
    this["started"](event);
  }
  ["started"](event) {
    const { started, live, liveSyncPosition, seekableEnd } = this.b;
    if (!started()) {
      if (live()) {
        const end = liveSyncPosition() ?? seekableEnd() - 2;
        if (Number.isFinite(end))
          this.a.$provider().currentTime = end;
      }
      started.set(true);
      this.O(this.createEvent("started", { trigger: event }));
    }
  }
  ["pause"](event) {
    if (this.e.da) {
      event.stopImmediatePropagation();
      return;
    }
    appendTriggerEvent(event, this.n.get("seeked"));
    this.C("pause", event);
    const { paused, playing, seeking } = this.b;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    this.Ka();
  }
  ["time-update"](event) {
    const { currentTime, played, waiting } = this.b, detail = event.detail;
    currentTime.set(detail.currentTime);
    played.set(detail.played);
    waiting.set(false);
    for (const track of this.a.textTracks) {
      if (track.mode === "disabled")
        continue;
      track[TEXT_TRACK_UPDATE_ACTIVE_CUES](detail.currentTime, event);
    }
  }
  ["volume-change"](event) {
    const { volume, muted } = this.b, detail = event.detail;
    volume.set(detail.volume);
    muted.set(detail.muted || detail.volume === 0);
    this.C("volume", event);
  }
  ["seeked"](event) {
    const { seeking, currentTime, paused, duration, ended } = this.b;
    if (this.e.ca) {
      seeking.set(true);
      event.stopImmediatePropagation();
    } else if (seeking()) {
      const waitingEvent = this.n.get("waiting");
      appendTriggerEvent(event, waitingEvent);
      if (waitingEvent?.trigger?.type !== "seeking") {
        appendTriggerEvent(event, this.n.get("seeking"));
      }
      if (paused())
        this.Ld();
      seeking.set(false);
      if (event.detail !== duration())
        ended.set(false);
      currentTime.set(event.detail);
      this.C("seeked", event);
      const origin = event.originEvent;
      if (origin && origin.isTrusted && !/seek/.test(origin.type)) {
        this["started"](event);
      }
    }
  }
  ["waiting"](event) {
    if (this.wb || this.e.ca)
      return;
    event.stopImmediatePropagation();
    this.Ja = event;
    this.kc();
  }
  ["ended"](event) {
    if (this.e.da) {
      event.stopImmediatePropagation();
      return;
    }
    const { paused, playing, seeking, ended } = this.b;
    paused.set(true);
    playing.set(false);
    seeking.set(false);
    ended.set(true);
    this.Ka();
  }
  Ld() {
    this.kc.cancel();
    this.b.waiting.set(false);
  }
  ["fullscreen-change"](event) {
    this.b.fullscreen.set(event.detail);
    this.C("fullscreen", event);
  }
  ["fullscreen-error"](event) {
    this.C("fullscreen", event);
  }
  ["picture-in-picture-change"](event) {
    this.b.pictureInPicture.set(event.detail);
    this.C("pip", event);
  }
  ["picture-in-picture-error"](event) {
    this.C("pip", event);
  }
};
var MediaStoreSync = class extends ComponentController {
  onAttach(el) {
    effect(this.Uf.bind(this));
    effect(this.Vf.bind(this));
    effect(this.Wf.bind(this));
    effect(this.Xf.bind(this));
    effect(this.Yf.bind(this));
    effect(this.Zf.bind(this));
    effect(this._f.bind(this));
    effect(this.$f.bind(this));
    effect(this.ag.bind(this));
    effect(this.bg.bind(this));
  }
  vi() {
    return;
  }
  Uf() {
    const autoplay = this.$props.autoplay();
    this.$store.autoplay.set(autoplay);
    this.dispatch("autoplay-change", { detail: autoplay });
  }
  Wf() {
    const loop = this.$props.loop();
    this.$store.loop.set(loop);
    this.dispatch("loop-change", { detail: loop });
  }
  Xf() {
    const controls = this.$props.controls();
    this.$store.controls.set(controls);
    this.dispatch("controls-change", { detail: controls });
  }
  Vf() {
    const poster = this.$props.poster();
    this.$store.poster.set(poster);
    this.dispatch("poster-change", { detail: poster });
  }
  Yf() {
    this.$store.crossorigin.set(this.$props.crossorigin());
  }
  Zf() {
    const playsinline = this.$props.playsinline();
    this.$store.playsinline.set(playsinline);
    this.dispatch("playsinline-change", { detail: playsinline });
  }
  $f() {
    this.dispatch("live-change", { detail: this.$store.live() });
  }
  _f() {
    this.$store.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());
    this.$store.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());
  }
  ag() {
    this.dispatch("live-edge-change", { detail: this.$store.liveEdge() });
  }
  bg() {
    this.$store.thumbnails.set(this.$props.thumbnails());
  }
};
var ThumbnailsLoader = class extends ComponentController {
  onConnect() {
    this.a = useMedia();
    effect(this.cg.bind(this));
  }
  cg() {
    const { canLoad, thumbnailCues } = this.a.$store;
    if (!canLoad())
      return;
    const controller = new AbortController(), { crossorigin, thumbnails } = this.a.$store;
    const src = thumbnails();
    if (!src)
      return;
    import('media-captions').then(({ parseResponse }) => {
      parseResponse(
        fetch(src, {
          signal: controller.signal,
          credentials: getRequestCredentials(crossorigin())
        })
      ).then(({ cues }) => thumbnailCues.set(cues)).catch(noop);
    });
    return () => {
      controller.abort();
      thumbnailCues.set([]);
    };
  }
};

// src/player/core/player.tsx
var Player = class extends Component {
  constructor(instance) {
    super(instance);
    this.W = new RequestQueue();
    this.jg();
    new MediaStoreSync(instance);
    const context = {
      player: null,
      scope: getScope(),
      qualities: new VideoQualityList(),
      audioTracks: new AudioTrackList(),
      $provider: signal(null),
      $props: this.$props,
      $store: this.$store
    };
    context.remote = new MediaRemoteControl(void 0);
    context.$iosControls = computed(this.kg.bind(this));
    context.textTracks = new TextTrackList();
    context.textTracks[TEXT_TRACK_CROSSORIGIN] = this.$props.crossorigin;
    context.textRenderers = new TextRenderers(context);
    context.ariaKeys = {};
    this.a = context;
    provideContext(mediaContext, context);
    this.orientation = new ScreenOrientationController(instance);
    new FocusVisibleController(instance);
    new MediaKeyboardController(instance, context);
    new ThumbnailsLoader(instance);
    const request = new MediaRequestContext();
    this.P = new MediaStateManager(instance, request, context);
    this.L = new MediaRequestManager(instance, this.P, request, context);
    context.delegate = new MediaPlayerDelegate(
      this.P.O.bind(this.P),
      context
    );
    new MediaLoadController(instance, this.startLoading.bind(this));
  }
  get j() {
    return this.a.$provider();
  }
  onAttach(el) {
    el.setAttribute("tabindex", "0");
    setAttributeIfEmpty(el, "role", "region");
    effect(this.lg.bind(this));
    effect(this.mg.bind(this));
    effect(this.ng.bind(this));
    effect(this.og.bind(this));
    effect(this.ec.bind(this));
    effect(this.nc.bind(this));
    effect(this.eb.bind(this));
    effect(this.pg.bind(this));
    effect(this.qg.bind(this));
    this.rg();
    this.sg();
    this.a.player = el;
    this.a.remote.setTarget(el);
    this.a.remote.setPlayer(el);
    listenEvent(el, "find-media-player", this.tg.bind(this));
  }
  onConnect(el) {
    if (IS_IPHONE)
      setAttribute(el, "data-iphone", "");
    const pointerQuery = window.matchMedia("(pointer: coarse)");
    this.Vd(pointerQuery);
    pointerQuery.onchange = this.Vd.bind(this);
    const resize = new ResizeObserver(this.G.bind(this));
    resize.observe(el);
    effect(this.G.bind(this));
    this.dispatch("media-player-connect", {
      detail: this.el,
      bubbles: true,
      composed: true
    });
    return () => {
      resize.disconnect();
      pointerQuery.onchange = null;
    };
  }
  jg() {
    const providedProps = {
      viewType: "providedViewType",
      streamType: "providedStreamType"
    };
    for (const prop2 of Object.keys(this.$props)) {
      this.$store[providedProps[prop2] ?? prop2]?.set(this.$props[prop2]());
    }
    effect(this.ug.bind(this));
    this.$store.muted.set(this.$props.muted() || this.$props.volume() === 0);
  }
  lg() {
    const { title } = this.$props, { live, viewType } = this.$store, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== "Unknown" ? `${isLive ? "Live " : ""}${type}` : isLive ? "Live" : "Media";
    const newTitle = title();
    if (newTitle) {
      this.el?.setAttribute("data-title", newTitle);
      this.el?.removeAttribute("title");
    }
    const currentTitle = this.el?.getAttribute("data-title") || "";
    this.$store.title.set(currentTitle);
    setAttribute(
      this.el,
      "aria-label",
      currentTitle ? `${typeText} - ${currentTitle}` : typeText + " Player"
    );
  }
  mg() {
    const orientation = this.orientation.landscape ? "landscape" : "portrait";
    this.$store.orientation.set(orientation);
    setAttribute(this.el, "data-orientation", orientation);
    this.G();
  }
  ng() {
    if (this.$store.canPlay() && this.j)
      this.W.pb();
    else
      this.W.ia();
  }
  ug() {
    this.$store.providedViewType.set(this.$props.viewType());
    this.$store.providedStreamType.set(this.$props.streamType());
  }
  rg() {
    const $attrs = {
      "aspect-ratio": this.$props.aspectRatio,
      "data-captions": () => {
        const track = this.$store.textTrack();
        return !!track && isTrackCaptionKind(track);
      },
      "data-ios-controls": this.a.$iosControls
    };
    const mediaAttrName = {
      canPictureInPicture: "can-pip",
      pictureInPicture: "pip"
    };
    for (const prop2 of MEDIA_ATTRIBUTES) {
      const attrName = "data-" + (mediaAttrName[prop2] ?? camelToKebabCase(prop2));
      $attrs[attrName] = this.$store[prop2];
    }
    delete $attrs.title;
    this.setAttributes($attrs);
  }
  sg() {
    this.setCSSVars({
      "--media-aspect-ratio": () => {
        const ratio = this.$props.aspectRatio();
        return ratio ? +ratio.toFixed(4) : null;
      }
    });
  }
  tg(event) {
    event.detail(this.el);
  }
  G() {
    if (!this.el)
      return;
    const width = this.el.clientWidth, height = this.el.clientHeight, { smallBreakpointX, smallBreakpointY, largeBreakpointX, largeBreakpointY } = this.$props, bpx = width < smallBreakpointX() ? "sm" : width < largeBreakpointX() ? "md" : "lg", bpy = height < smallBreakpointY() ? "sm" : height < largeBreakpointY() ? "md" : "lg";
    this.$store.breakpointX.set(bpx);
    this.$store.breakpointY.set(bpy);
    setAttribute(this.el, "data-bp-x", bpx);
    setAttribute(this.el, "data-bp-y", bpy);
  }
  Vd(queryList) {
    const isTouch = queryList.matches;
    setAttribute(this.el, "data-touch", isTouch);
    this.$store.touchPointer.set(isTouch);
    this.G();
  }
  kg() {
    return !canFullscreen() && this.$store.mediaType() === "video" && (this.$store.controls() && !this.$props.playsinline() || this.$store.fullscreen());
  }
  get provider() {
    return this.j;
  }
  get user() {
    return this.L.cb;
  }
  get qualities() {
    return this.a.qualities;
  }
  get audioTracks() {
    return this.a.audioTracks;
  }
  get textTracks() {
    return this.a.textTracks;
  }
  get textRenderers() {
    return this.a.textRenderers;
  }
  get paused() {
    return this.j?.paused ?? true;
  }
  set paused(paused) {
    if (paused) {
      this.W.l("paused", () => this.L.Ed());
    } else
      this.W.l("paused", () => this.L.fc());
  }
  ec() {
    this.paused = this.$props.paused();
  }
  get muted() {
    return this.j?.muted ?? false;
  }
  set muted(muted) {
    this.W.l("muted", () => this.j.muted = muted);
  }
  og() {
    this.muted = this.$props.muted();
  }
  get currentTime() {
    return this.j?.currentTime ?? 0;
  }
  set currentTime(time) {
    this.W.l("currentTime", () => {
      const adapter = this.j;
      if (time !== adapter.currentTime) {
        peek(() => {
          const boundTime = Math.min(
            Math.max(this.$store.seekableStart() + 0.1, time),
            this.$store.seekableEnd() - 0.1
          );
          if (Number.isFinite(boundTime))
            adapter.currentTime = boundTime;
        });
      }
    });
  }
  eb() {
    this.currentTime = this.$props.currentTime();
  }
  get volume() {
    return this.j?.volume ?? 1;
  }
  set volume(volume) {
    this.W.l("volume", () => this.j.volume = volume);
  }
  nc() {
    this.volume = clampNumber(0, this.$props.volume(), 1);
  }
  get playsinline() {
    return this.j?.playsinline ?? false;
  }
  set playsinline(inline) {
    this.W.l("playsinline", () => this.j.playsinline = inline);
  }
  pg() {
    this.playsinline = this.$props.playsinline();
  }
  get playbackRate() {
    return this.j?.playbackRate ?? 1;
  }
  set playbackRate(rate) {
    this.W.l("rate", () => this.j.playbackRate = rate);
  }
  qg() {
    this.playbackRate = this.$props.playbackRate();
  }
  async play() {
    return this.L.fc();
  }
  async pause() {
    return this.L.Ed();
  }
  async enterFullscreen(target) {
    return this.L.Gd(target);
  }
  async exitFullscreen(target) {
    return this.L.Hd(target);
  }
  enterPictureInPicture() {
    return this.L.ic();
  }
  exitPictureInPicture() {
    return this.L.hc();
  }
  seekToLiveEdge() {
    this.L.Fd();
  }
  startLoading() {
    this.a.delegate.d("can-load");
  }
  destroy() {
    this.dispatch("destroy");
  }
};
Player.el = defineElement({
  tagName: "media-player",
  props: mediaPlayerProps,
  store: MediaStoreFactory
});
__decorateClass([
  prop
], Player.prototype, "provider", 1);
__decorateClass([
  prop
], Player.prototype, "user", 1);
__decorateClass([
  prop
], Player.prototype, "orientation", 2);
__decorateClass([
  prop
], Player.prototype, "qualities", 1);
__decorateClass([
  prop
], Player.prototype, "audioTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textTracks", 1);
__decorateClass([
  prop
], Player.prototype, "textRenderers", 1);
__decorateClass([
  prop
], Player.prototype, "paused", 1);
__decorateClass([
  prop
], Player.prototype, "muted", 1);
__decorateClass([
  prop
], Player.prototype, "currentTime", 1);
__decorateClass([
  prop
], Player.prototype, "volume", 1);
__decorateClass([
  prop
], Player.prototype, "playsinline", 1);
__decorateClass([
  prop
], Player.prototype, "playbackRate", 1);
__decorateClass([
  method
], Player.prototype, "play", 1);
__decorateClass([
  method
], Player.prototype, "pause", 1);
__decorateClass([
  method
], Player.prototype, "enterFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "exitFullscreen", 1);
__decorateClass([
  method
], Player.prototype, "enterPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "exitPictureInPicture", 1);
__decorateClass([
  method
], Player.prototype, "seekToLiveEdge", 1);
__decorateClass([
  method
], Player.prototype, "startLoading", 1);

export { AudioTrackList, FullscreenController, List, MEDIA_KEY_SHORTCUTS, MediaRemoteControl, MediaStoreFactory, MediaUserController, Player, ScreenOrientationController, TextRenderers, TextTrackList, TimeRange, VideoQualityList, canFullscreen, getTimeRangesEnd, getTimeRangesStart, isAudioProvider, isHLSProvider, isHTMLAudioElement, isHTMLMediaElement, isHTMLVideoElement, isVideoProvider, softResetMediaStore };
