import { $ariaBool } from './chunk-EVP5E6AO.js';
import { onPress, setAttributeIfEmpty, isElementParent } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { menuContext } from './chunk-HSL7QSWM.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { signal, hasProvidedContext, useContext, provideContext, effect, scoped, peek, tick, onDispose } from 'maverick.js';
import { defineElement, method, Component } from 'maverick.js/element';
import { setAttribute, setStyle, listenEvent, ariaBool, isKeyboardEvent } from 'maverick.js/std';

var FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
  "a[href]",
  "[tabindex]",
  "input",
  "select",
  "button"
].map((selector) => `${selector}:not([aria-hidden])`).join(",");
var VALID_KEYS = /* @__PURE__ */ new Set([
  "Escape",
  "Tab",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "PageUp",
  "End",
  "PageDown",
  "Enter",
  " "
]);
var MenuFocusController = class {
  constructor(_closeMenu) {
    this.Fh = _closeMenu;
    this.Z = 0;
    this.ta = null;
    this.S = [];
  }
  get q() {
    return this.S;
  }
  Ch(el) {
    listenEvent(el, "focus", this.Ua.bind(this));
    this.ta = el;
  }
  Dh() {
    if (!this.ta)
      return;
    this.V();
    listenEvent(this.ta, "keyup", this._a.bind(this));
    listenEvent(this.ta, "keydown", this.$a.bind(this));
    onDispose(() => {
      this.Z = 0;
      this.S = [];
    });
  }
  Pa(index) {
    this.Z = index;
    this.S[index]?.focus();
    this.S[index]?.scrollIntoView({
      block: "center"
    });
  }
  Ua() {
    const index = this.S.findIndex((el) => el.getAttribute("aria-checked") === "true");
    this.Pa(index >= 0 ? index : 0);
  }
  V() {
    this.Z = 0;
    this.S = this.Eh();
  }
  _a(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
  }
  $a(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
    switch (event.key) {
      case "Escape":
        this.Fh(event);
        break;
      case "Tab":
        this.Pa(this.Rc(event.shiftKey ? -1 : 1));
        break;
      case "ArrowUp":
        this.Pa(this.Rc(-1));
        break;
      case "ArrowDown":
        this.Pa(this.Rc(1));
        break;
      case "Home":
      case "PageUp":
        this.Pa(0);
        break;
      case "End":
      case "PageDown":
        this.Pa(this.S.length - 1);
        break;
    }
  }
  Rc(delta) {
    let index = this.Z;
    do {
      index = (index + delta + this.S.length) % this.S.length;
    } while (this.S[index].offsetParent === null);
    return index;
  }
  Eh() {
    if (!this.ta)
      return [];
    const focusableElements = this.ta.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
    const is = (node) => node.hasAttribute("data-media-menu-items");
    for (const el of focusableElements) {
      if (el instanceof HTMLElement && el.offsetParent !== null && // does not have display: none
      isElementParent(this.ta, el, is)) {
        elements.push(el);
      }
    }
    return elements;
  }
};

// src/player/ui/menu/menu.tsx
var idCount = 0;
var Menu = class extends Component {
  constructor(instance) {
    super(instance);
    this.I = signal(false);
    this.re = signal(false);
    this.se = signal(false);
    this.jb = /* @__PURE__ */ new Set();
    this.Uc = null;
    this.s = null;
    this.Hb = null;
    this.zi = this.ua.bind(this);
    this.Oh = this.Ph.bind(this);
    this.Mh = this.Qh.bind(this);
    this.Nh = this.Rh.bind(this);
    this.a = useMedia();
    const currentIdCount = ++idCount;
    this.Sc = `media-menu-${currentIdCount}`;
    this.Tc = `media-menu-button-${currentIdCount}`;
    if (hasProvidedContext(menuContext)) {
      this.T = useContext(menuContext);
    }
    this.Vc = new MenuFocusController(this.close.bind(this));
    provideContext(menuContext, {
      I: this.I,
      kb: signal(""),
      ua: this.ua.bind(this),
      Wc: this.Wc.bind(this),
      Xc: this.Xc.bind(this),
      Yc: this.Yc.bind(this),
      Zc: this.Zc.bind(this),
      _c: this._c.bind(this)
    });
  }
  onAttach(el) {
    const { position } = this.$props;
    this.setAttributes({
      position,
      "data-open": this.I,
      "data-submenu": !!this.T,
      "data-disabled": this.p.bind(this),
      "data-media-menu": true
    });
  }
  onConnect(el) {
    if (!this.T) {
      effect(this.te.bind(this));
    }
    effect(this.Gh.bind(this));
    this.T?._c(el);
    requestAnimationFrame(() => this.G());
  }
  onDestroy() {
    this.ue();
    this.Uc = null;
    this.s = null;
    this.Hb = null;
  }
  ue() {
    if (!this.s || this.el?.contains(this.s))
      return;
    const menu = this.s?.parentElement;
    this.el.append(this.s);
    if (menu?.localName === "media-menu") {
      menu.destroy();
      menu.remove();
    }
  }
  te() {
    if (!this.el)
      return;
    const { breakpointX, breakpointY, viewType, orientation, fullscreen } = this.a.$store, popup = viewType() === "audio" ? breakpointX() === "sm" : breakpointY() === "sm";
    if (!this.s || this.T)
      return;
    setAttribute(this.el, "data-popup", popup);
    setAttribute(this.el, "data-popup-wide", popup && orientation() === "landscape");
    if (popup && !fullscreen()) {
      if (this.el.contains?.(this.s)) {
        const menu = this.el.cloneNode();
        menu.appendChild(this.s);
        requestAnimationFrame(() => {
          if (!this.el)
            return;
          const mediaRing = "--media-focus-ring", mediaRingValue = getComputedStyle(this.el).getPropertyValue(mediaRing);
          if (mediaRingValue)
            setStyle(menu, mediaRing, mediaRingValue);
        });
        scoped(() => {
          document.body.append(menu);
        }, this.a.scope);
      }
    }
    this.G();
    return () => this.ue();
  }
  Gh() {
    const expanded = this.ve();
    this.G();
    this.we(expanded);
    if (!expanded)
      return;
    this.Vc.Dh();
    const closeTarget = this.Hh();
    if (closeTarget) {
      onPress(closeTarget, this.Ih.bind(this));
    }
    this.listen("pointerup", this.Jh.bind(this));
    listenEvent(window, "pointerup", this.Kh.bind(this));
  }
  Wc(el) {
    const isMenuItem = !!this.T, isExpanded = this.ve.bind(this), isARIAExpanded = $ariaBool(isExpanded), isARIADisabled = $ariaBool(this.p.bind(this));
    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
    setAttribute(el, "id", this.Tc);
    setAttribute(el, "aria-controls", this.Sc);
    setAttribute(el, "aria-haspopup", "true");
    effect(() => {
      setAttribute(el, "aria-disabled", isARIADisabled());
      setAttribute(el, "aria-expanded", isARIAExpanded());
      if (!isMenuItem)
        setAttribute(el, "aria-pressed", isARIAExpanded());
      setAttribute(el, "data-pressed", isExpanded());
    });
    setAttribute(el, "data-media-button", !isMenuItem);
    setAttribute(el, "data-media-menu-button", "");
    onPress(el, this.Lh.bind(this));
    this.Uc = el;
  }
  Xc(el) {
    setAttributeIfEmpty(el, "role", "menu");
    setAttributeIfEmpty(el, "tabindex", "-1");
    setAttribute(el, "id", this.Sc);
    setAttribute(el, "aria-describedby", this.Tc);
    setAttribute(el, "data-media-menu-items", "");
    this.s = el;
    this.Vc.Ch(el);
    this.te();
    this.we(peek(this.I));
  }
  Yc(observer) {
    this.Hb = observer;
  }
  we(expanded) {
    if (this.s)
      setAttribute(this.s, "aria-hidden", ariaBool(!expanded));
  }
  Zc(disabled) {
    this.se.set(disabled);
  }
  Lh(event) {
    if (this.T)
      event.stopPropagation();
    if (this.p())
      return;
    this.I.set((expanded) => !expanded);
    this.$c();
    tick();
    if (isKeyboardEvent(event)) {
      this.s?.focus();
    }
    this.o(event);
  }
  o(trigger) {
    const expanded = peek(this.I);
    this.dispatch(expanded ? "open" : "close", { trigger });
    if (!this.T) {
      if (expanded) {
        this.a.activeMenu?.close(trigger);
        this.a.activeMenu = this;
      } else {
        for (const el of this.jb)
          el.close(trigger);
        this.a.activeMenu = null;
      }
    }
    if (expanded)
      this.Hb?.ad?.(trigger);
    else
      this.Hb?.yi?.(trigger);
  }
  ve() {
    return !this.p() && this.I();
  }
  p() {
    return this.re() || this.se();
  }
  ua(disabled) {
    this.re.set(disabled);
  }
  Jh(event) {
    event.stopPropagation();
  }
  Kh() {
    if (this.T)
      return setTimeout(this.close.bind(this), 300);
    this.close();
  }
  Ih(event) {
    event.stopPropagation();
    this.close(event);
  }
  Hh() {
    const target = this.el.querySelector('[slot="close-target"]');
    return isElementParent(this.el, target) ? target : null;
  }
  $c(trigger) {
    if (this.T)
      return;
    if (this.I())
      this.a.remote.pauseUserIdle(trigger);
    else
      this.a.remote.resumeUserIdle(trigger);
  }
  _c(el) {
    this.jb.add(el);
    listenEvent(el, "open", this.Mh);
    listenEvent(el, "close", this.Nh);
    onDispose(this.Oh);
  }
  Ph(el) {
    this.jb.delete(el);
  }
  Qh(event) {
    for (const el of this.jb) {
      if (el !== event.target)
        el.setAttribute("aria-hidden", "true");
    }
    this.G();
  }
  Rh() {
    for (const el of this.jb)
      el.removeAttribute("aria-hidden");
    this.G();
  }
  G() {
    if (!this.s || false)
      return;
    let style = getComputedStyle(this.s), height = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let children = [...this.s.children];
    if (children[0]?.localName === "shadow-root") {
      children.push(...children[0].children);
    }
    for (const child of children) {
      height += child.offsetHeight;
    }
    requestAnimationFrame(() => {
      if (!this.s)
        return;
      setAttribute(this.s, "data-resizing", "");
      setTimeout(() => {
        if (!this.s)
          return;
        setAttribute(this.s, "data-resizing", false);
      }, 250);
      setStyle(this.s, "--menu-height", height + "px");
    });
  }
  open(trigger) {
    if (peek(this.I))
      return;
    this.I.set(true);
    tick();
    this.o(trigger);
    if (isKeyboardEvent(trigger)) {
      this.s?.focus();
    }
    this.$c(trigger);
  }
  close(trigger) {
    if (!peek(this.I))
      return;
    this.I.set(false);
    tick();
    if (isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        this.Uc?.focus();
      });
    }
    this.o(trigger);
    this.$c(trigger);
  }
};
Menu.el = defineElement({
  tagName: "media-menu",
  props: { position: null }
});
__decorateClass([
  method
], Menu.prototype, "open", 1);
__decorateClass([
  method
], Menu.prototype, "close", 1);

export { Menu };
