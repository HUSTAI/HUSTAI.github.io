import { isMediaStream, isHLSSrc } from './chunk-FRNAFKFA.js';
import { IS_SAFARI } from './chunk-WSYKLWQE.js';
import { getNumberOfDecimalPlaces } from './chunk-CVLY5S52.js';
import { isUndefined, isNumber, setAttribute, isString, useDisposalBin, listenEvent, DOMEvent, isNil } from 'maverick.js/std';
import { effect, onDispose } from 'maverick.js';

var RAFLoop = class {
  constructor(_callback) {
    this.ja = _callback;
  }
  pb() {
    if (!isUndefined(this.Ba))
      return;
    this.kd();
  }
  ia() {
    if (isNumber(this.Ba))
      window.cancelAnimationFrame(this.Ba);
    this.Ba = void 0;
  }
  kd() {
    this.Ba = window.requestAnimationFrame(() => {
      if (isUndefined(this.Ba))
        return;
      this.ja();
      this.kd();
    });
  }
};

// src/player/core/providers/html/htmlâ€“media-events.ts
var HTMLMediaEvents = class {
  constructor(_provider, _context) {
    this.j = _provider;
    this.c = _context;
    this.ba = useDisposalBin();
    this.Wa = false;
    this.ld = false;
    this.md = false;
    this.qb = new RAFLoop(this.Ne.bind(this));
    this.gf = void 0;
    this.ti = void 0;
    this.Oe();
    effect(this.Pe.bind(this));
    onDispose(this.Rb.bind(this));
  }
  get a() {
    return this.j.media;
  }
  get g() {
    return this.c.delegate;
  }
  Rb() {
    this.qb.ia();
    this.ba.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  Ne() {
    const newTime = this.j.currentTime;
    if (this.c.$store.currentTime() !== newTime)
      this.Ca(newTime);
  }
  Oe() {
    this.r("loadstart", this.ka);
    this.r("abort", this.nd);
    this.r("emptied", this.Qe);
    this.r("error", this.la);
  }
  Re() {
    if (this.ld)
      return;
    this.ba.add(
      this.r("loadeddata", this.Se),
      this.r("loadedmetadata", this.Te),
      this.r("canplay", this.rb),
      this.r("canplaythrough", this.Ue),
      this.r("durationchange", this.Ve),
      this.r("play", this.We),
      this.r("progress", this.Xe),
      this.r("stalled", this.Ye),
      this.r("suspend", this.Ze)
    );
    this.ld = true;
  }
  _e() {
    if (this.md)
      return;
    this.ba.add(
      this.r("pause", this.$e),
      this.r("playing", this.af),
      this.r("ratechange", this.bf),
      this.r("seeked", this.cf),
      this.r("seeking", this.df),
      this.r("ended", this.ef),
      this.r("volumechange", this.Sb),
      this.r("waiting", this.ff)
    );
    this.md = true;
  }
  r(eventType, handler) {
    return listenEvent(
      this.a,
      eventType,
      handler.bind(this)
    );
  }
  ui(event2) {
    return;
  }
  Ca(time, trigger) {
    this.g.d("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.c.$store.seekableEnd()),
        played: this.a.played
      },
      trigger
    });
  }
  ka(event2) {
    if (this.a.networkState === 3) {
      this.nd(event2);
      return;
    }
    this.Re();
    this.g.d("load-start", { trigger: event2 });
  }
  nd(event2) {
    this.g.d("abort", { trigger: event2 });
  }
  Qe() {
    this.g.d("emptied", { trigger: event });
  }
  Se(event2) {
    this.g.d("loaded-data", { trigger: event2 });
  }
  Te(event2) {
    this.od();
    this._e();
    this.g.d("volume-change", {
      detail: {
        volume: this.a.volume,
        muted: this.a.muted
      }
    });
    this.g.d("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.c.$store.source())) {
      this.g.pd(this.Tb(), event2);
    }
  }
  Tb() {
    return {
      duration: this.a.duration,
      buffered: this.a.buffered,
      seekable: this.a.seekable
    };
  }
  od() {
    const isLive = !Number.isFinite(this.a.duration);
    this.g.d("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  We(event2) {
    if (!this.c.$store.canPlay)
      return;
    this.g.d("play", { trigger: event2 });
  }
  $e(event2) {
    if (this.a.readyState === 1 && !this.Wa)
      return;
    this.Wa = false;
    this.qb.ia();
    this.g.d("pause", { trigger: event2 });
  }
  rb(event2) {
    this.g.pd(this.Tb(), event2);
  }
  Ue(event2) {
    if (this.c.$store.started())
      return;
    this.g.d("can-play-through", {
      trigger: event2,
      detail: this.Tb()
    });
  }
  af(event2) {
    this.Wa = false;
    this.g.d("playing", { trigger: event2 });
    this.qb.pb();
  }
  Ye(event2) {
    this.g.d("stalled", { trigger: event2 });
    if (this.a.readyState < 3) {
      this.Wa = true;
      this.g.d("waiting", { trigger: event2 });
    }
  }
  ff(event2) {
    if (this.a.readyState < 3) {
      this.Wa = true;
      this.g.d("waiting", { trigger: event2 });
    }
  }
  ef(event2) {
    this.qb.ia();
    this.Ca(this.a.duration, event2);
    this.g.d("end", { trigger: event2 });
    if (this.c.$store.loop()) {
      this.hf();
    } else {
      this.g.d("ended", { trigger: event2 });
    }
  }
  Pe() {
    if (this.c.$store.paused()) {
      listenEvent(this.a, "timeupdate", this.Ub.bind(this));
    }
  }
  Ub(event2) {
    this.Ca(this.a.currentTime, event2);
  }
  Ve(event2) {
    this.od();
    if (this.c.$store.ended()) {
      this.Ca(this.a.duration, event2);
    }
    this.g.d("duration-change", {
      detail: this.a.duration,
      trigger: event2
    });
  }
  Sb(event2) {
    this.g.d("volume-change", {
      detail: {
        volume: this.a.volume,
        muted: this.a.muted
      },
      trigger: event2
    });
  }
  cf(event2) {
    this.Ca(this.a.currentTime, event2);
    this.g.d("seeked", {
      detail: this.a.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.a.currentTime) === Math.trunc(this.a.duration) && getNumberOfDecimalPlaces(this.a.duration) > getNumberOfDecimalPlaces(this.a.currentTime)) {
      this.Ca(this.a.duration, event2);
      if (!this.a.ended) {
        this.c.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  df(event2) {
    this.g.d("seeking", {
      detail: this.a.currentTime,
      trigger: event2
    });
  }
  Xe(event2) {
    this.g.d("progress", {
      detail: {
        buffered: this.a.buffered,
        seekable: this.a.seekable
      },
      trigger: event2
    });
  }
  hf() {
    const hasCustomControls = isNil(this.a.controls);
    if (hasCustomControls)
      this.a.controls = false;
    this.c.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  Ze(event2) {
    this.g.d("suspend", { trigger: event2 });
  }
  bf(event2) {
    this.g.d("rate-change", {
      detail: this.a.playbackRate,
      trigger: event2
    });
  }
  la(event2) {
    const error = this.a.error;
    if (!error)
      return;
    this.g.d("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
};

// src/foundation/list/symbols.ts
var LIST_ADD = Symbol(0);
var LIST_REMOVE = Symbol(0);
var LIST_RESET = Symbol(0);
var LIST_SELECT = Symbol(0);
var LIST_READONLY = Symbol(0);
var LIST_SET_READONLY = Symbol(0);
var LIST_ON_RESET = Symbol(0);
var LIST_ON_REMOVE = Symbol(0);
var LIST_ON_USER_SELECT = Symbol(0);

// src/player/core/providers/html/native-audio-tracks.ts
var NativeAudioTracks = class {
  constructor(_provider, _context) {
    this.j = _provider;
    this.c = _context;
    this.Xa.onaddtrack = this.jf.bind(this);
    this.Xa.onremovetrack = this.kf.bind(this);
    this.Xa.onchange = this.lf.bind(this);
    listenEvent(this.c.audioTracks, "change", this.mf.bind(this));
  }
  get Xa() {
    return this.j.media.audioTracks;
  }
  jf(event2) {
    const _track = event2.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.c.audioTracks[LIST_ADD](audioTrack, event2);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  kf(event2) {
    const track = this.c.audioTracks.getById(event2.track.id);
    if (track)
      this.c.audioTracks[LIST_REMOVE](track, event2);
  }
  lf(event2) {
    let enabledTrack = this.qd();
    if (!enabledTrack)
      return;
    const track = this.c.audioTracks.getById(enabledTrack.id);
    if (track)
      this.c.audioTracks[LIST_SELECT](track, true, event2);
  }
  qd() {
    return Array.from(this.Xa).find((track) => track.enabled);
  }
  mf(event2) {
    const { current } = event2.detail;
    if (!current)
      return;
    const track = this.Xa.getTrackById(current.id);
    if (track) {
      const prev = this.qd();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
};

// src/player/core/providers/html/provider.ts
var HTMLMediaProvider = class {
  constructor(_media) {
    this.a = _media;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
  }
  get type() {
    return "";
  }
  get media() {
    return this.a;
  }
  get paused() {
    return this.a.paused;
  }
  get muted() {
    return this.a.muted;
  }
  set muted(muted) {
    this.a.muted = muted;
  }
  get volume() {
    return this.a.volume;
  }
  set volume(volume) {
    this.a.volume = volume;
  }
  get currentTime() {
    return this.a.currentTime;
  }
  set currentTime(time) {
    this.a.currentTime = time;
  }
  get playsinline() {
    return this.a.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this.a, "playsinline", playsinline);
  }
  get playbackRate() {
    return this.a.playbackRate;
  }
  set playbackRate(rate) {
    this.a.playbackRate = rate;
  }
  async play() {
    return this.a.play();
  }
  async pause() {
    return this.a.pause();
  }
  async loadSource({ src }, preload) {
    this.a.preload = preload;
    if (isMediaStream(src)) {
      this.a.srcObject = src;
    } else {
      this.a.srcObject = null;
      this.a.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this.a.load();
  }
};

export { HTMLMediaProvider, LIST_ADD, LIST_ON_REMOVE, LIST_ON_RESET, LIST_ON_USER_SELECT, LIST_READONLY, LIST_REMOVE, LIST_RESET, LIST_SELECT, LIST_SET_READONLY, RAFLoop };
