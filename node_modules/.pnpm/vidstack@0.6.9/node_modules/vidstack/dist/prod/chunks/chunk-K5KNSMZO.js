import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { IS_SAFARI } from './chunk-WSYKLWQE.js';
import { round, clampNumber, getNumberOfDecimalPlaces } from './chunk-CVLY5S52.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-UMWH4QNT.js';
import { $$_create_walker, $$_effect, $$_attr, $$_next_element, $$_create_template } from 'maverick.js/dom';
import { provideContext, effect, peek } from 'maverick.js';
import { defineElement, Component, ComponentController } from 'maverick.js/element';
import { animationFrameThrottle, setStyle, ariaBool, listenEvent, isNull, isNumber, isDOMEvent, isKeyboardEvent, isUndefined } from 'maverick.js/std';

// src/player/ui/sliders/slider/api/props.ts
var sliderProps = {
  min: 0,
  max: 100,
  disabled: false,
  value: 100,
  step: 1,
  keyStep: 1,
  shiftKeyMultiplier: 5,
  trackClass: null,
  trackFillClass: null,
  trackProgressClass: null,
  thumbContainerClass: null,
  thumbClass: null
};

// src/player/ui/sliders/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/sliders/slider/events-controller.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
var SliderEventsController = class extends ComponentController {
  constructor(instance, _delegate, _media) {
    super(instance);
    this.g = _delegate;
    this.a = _media;
    this.Ma = null;
    this.qa = null;
    this.Na = null;
    this.ra = null;
    this.Oa = null;
    this.Ng = functionThrottle(
      (event) => {
        this.ea(this.Cb(event), event);
      },
      20,
      { leading: true }
    );
  }
  onConnect() {
    effect(this.Fg.bind(this));
    effect(this.Gg.bind(this));
    if (this.g.Hg) {
      scopedRaf(() => {
        const outlet = this.a.player?.querySelector("media-outlet");
        if (outlet) {
          this.Ma = outlet;
          listenEvent(outlet, "touchstart", this.Ig.bind(this));
          listenEvent(outlet, "touchmove", this.Jg.bind(this));
        }
      });
    }
  }
  Ig(event) {
    this.qa = event.touches[0].clientX;
  }
  Jg(event) {
    if (isNull(this.qa))
      return;
    event.preventDefault();
    if (this.$store.dragging())
      return;
    const diff = event.touches[0].clientX - this.qa;
    if (Math.abs(diff) > 20) {
      this.qa = event.touches[0].clientX;
      this.Na = this.$store.value();
      this.qc(this.Na, event);
    }
  }
  Fg() {
    if (this.g.p())
      return;
    this.listen("focus", this.Ua.bind(this));
    this.listen("pointerenter", this.Nb.bind(this));
    this.listen("pointermove", this.Kg.bind(this));
    this.listen("pointerleave", this.Ob.bind(this));
    this.listen("pointerdown", this.Lg.bind(this));
    this.listen("keydown", this.$a.bind(this));
    this.listen("keyup", this._a.bind(this));
  }
  Gg() {
    if (this.g.p() || !this.$store.dragging())
      return;
    listenEvent(document, "pointerup", this.Mg.bind(this));
    listenEvent(document, "pointermove", this.Ng.bind(this));
    if (IS_SAFARI) {
      listenEvent(document, "touchmove", this.Og.bind(this), {
        passive: false
      });
    }
  }
  Ua() {
    this.ea(this.$store.value());
  }
  rc(newValue, trigger) {
    const { value, min, max, dragging } = this.$store;
    const clampedValue = Math.max(min(), Math.min(newValue, max()));
    value.set(clampedValue);
    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
    this.el.dispatchEvent(event);
    this.g.sc(event);
    if (dragging()) {
      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
      this.el.dispatchEvent(event2);
      this.g.tc(event2);
    }
  }
  ea(value, trigger) {
    const { pointerValue, dragging } = this.$store;
    pointerValue.set(value);
    this.dispatch("pointer-value-change", { detail: value, trigger });
    if (dragging()) {
      const dir = this.g.K === "vertical" ? "bottom" : "left", size = this.g.K === "vertical" ? "height" : "width";
      if (this.Oa && !this.el?.hasAttribute("data-chapters")) {
        this.Oa.style[size] = value + "%";
      }
      if (this.ra) {
        this.ra.style[dir] = value + "%";
      }
      this.rc(value, trigger);
    }
  }
  Cb(event) {
    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$store;
    if (this.g.K === "vertical") {
      const { bottom: trackBottom, height: trackHeight } = rect;
      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
    } else {
      if (this.qa && isNumber(this.Na)) {
        const { width } = this.Ma.getBoundingClientRect(), rate = (event.clientX - this.qa) / width, range = max() - min(), diff = range * Math.abs(rate);
        thumbPositionRate = (rate < 0 ? this.Na - diff : this.Na + diff) / range;
      } else {
        const { left: trackLeft, width: trackWidth } = rect;
        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
      }
    }
    return Math.max(
      min(),
      Math.min(
        max(),
        this.g.ae(
          getValueFromRate(min(), max(), thumbPositionRate, this.g.Db())
        )
      )
    );
  }
  Nb(event) {
    this.$store.pointing.set(true);
  }
  Kg(event) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    this.ea(this.Cb(event), event);
  }
  Ob(event) {
    this.$store.pointing.set(false);
  }
  Lg(event) {
    if (event.button !== 0)
      return;
    const value = this.Cb(event);
    this.qc(value, event);
    this.ea(value, event);
  }
  qc(value, trigger) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    dragging.set(true);
    this.ra = this.el.querySelector(
      'shadow-root > div[part="thumb-container"]'
    );
    this.Oa = this.el.querySelector(
      'shadow-root > div[part~="track-fill"]'
    );
    this.a.remote.pauseUserIdle(trigger);
    const event = this.createEvent("drag-start", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.g.be(event);
  }
  ce(value, trigger) {
    const { dragging } = this.$store;
    if (!dragging())
      return;
    dragging.set(false);
    if (this.Oa) {
      setStyle(this.Oa, "width", null);
      this.Oa = null;
    }
    if (this.ra) {
      setStyle(this.ra, "left", null);
      setStyle(this.ra, "bottom", null);
      this.ra = null;
    }
    this.a.remote.resumeUserIdle(trigger);
    const event = this.createEvent("drag-end", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.g.uc(event);
    this.qa = null;
    this.Na = null;
  }
  $a(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key } = event;
    const { min, max } = this.$store;
    let newValue;
    if (key === "Home" || key === "PageUp") {
      newValue = min();
    } else if (key === "End" || key === "PageDown") {
      newValue = max();
    } else if (!event.metaKey && /[0-9]/.test(key)) {
      newValue = (max() - min()) / 10 * Number(key);
    }
    if (!isUndefined(newValue)) {
      this.ea(newValue, event);
      this.rc(newValue, event);
      return;
    }
    const value = this.de(event);
    if (!value)
      return;
    const repeat = key === this.vc;
    if (!this.$store.dragging() && repeat)
      this.qc(value, event);
    this.ea(value, event);
    if (!repeat)
      this.rc(value, event);
    this.vc = key;
  }
  _a(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    this.vc = "";
    const { dragging, value } = this.$store;
    if (!dragging())
      return;
    const newValue = this.de(event) ?? value();
    this.ea(newValue);
    this.ce(newValue, event);
  }
  de(event) {
    const { key, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key);
    if (!isValidKey)
      return;
    const { shiftKeyMultiplier } = this.$props;
    const { value } = this.$store, step = this.g.Db(), keyStep = this.g.ee();
    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, steps = (value() + diff) / step;
    return Number((step * steps).toFixed(3));
  }
  // -------------------------------------------------------------------------------------------
  // Document (Pointer Events)
  // -------------------------------------------------------------------------------------------
  Mg(event) {
    if (event.button !== 0)
      return;
    const value = this.Cb(event);
    this.ea(value, event);
    this.ce(value, event);
  }
  Og(event) {
    event.preventDefault();
  }
};

// src/player/ui/sliders/slider/slider.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><div part="track"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-fill"></div>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-progress"></div>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<!$><div part="thumb-container"><!$><div part="thumb"></div></div>`);
var Slider = class extends Component {
  constructor(instance) {
    super(instance);
    this.wc = false;
    this.K = "";
    this.Wg = animationFrameThrottle(
      (fillPercent, pointerPercent) => {
        this.el?.style.setProperty("--slider-fill-percent", fillPercent + "%");
        this.el?.style.setProperty("--slider-pointer-percent", pointerPercent + "%");
      }
    );
    // -------------------------------------------------------------------------------------------
    // Preview
    // -------------------------------------------------------------------------------------------
    this.R = null;
    this.ge = animationFrameThrottle(() => {
      if (!this.R)
        return;
      const rect = this.R.getBoundingClientRect();
      setStyle(this.R, "--computed-width", rect.width + "px");
      setStyle(this.R, "--computed-height", rect.height + "px");
    });
    provideContext(sliderValueFormatContext);
    this.a = useMedia();
    new SliderEventsController(instance, this, this.a);
    const focus = new FocusVisibleController(instance);
    this.$store.focused = focus.focused.bind(focus);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "role", "slider");
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(el, "autocomplete", "off");
    this.K = el.getAttribute("aria-orientation") || "";
    if (!this.wc) {
      effect(this.Pg.bind(this));
      effect(this.xc.bind(this));
    }
    effect(this.yc.bind(this));
    this.Qg();
  }
  onConnect(el) {
    this.Rg();
  }
  render() {
    const { trackClass, trackFillClass, trackProgressClass, thumbContainerClass, thumbClass } = this.$props;
    return [
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ);
        $$_effect(() => $$_attr($$_root, "class", trackClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
        $$_effect(() => $$_attr($$_root, "class", trackFillClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_3);
        $$_effect(() => $$_attr($$_root, "class", trackProgressClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_4), $$_el = $$_next_element($$_walker);
        $$_effect(() => $$_attr($$_root, "class", thumbContainerClass()));
        $$_effect(() => $$_attr($$_el, "class", thumbClass()));
        return $$_root;
      })()
    ];
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  Db() {
    return this.$props.step();
  }
  ee() {
    return this.$props.keyStep();
  }
  ae(value) {
    return Math.round(value);
  }
  p() {
    return this.$props.disabled();
  }
  // -------------------------------------------------------------------------------------------
  // Watch
  // -------------------------------------------------------------------------------------------
  Pg() {
    const { min, max } = this.$props;
    this.$store.min.set(min());
    this.$store.max.set(max());
  }
  xc() {
    if (!this.p())
      return;
    const { dragging, pointing } = this.$store;
    dragging.set(false);
    pointing.set(false);
  }
  yc() {
    const { dragging, value, min, max } = this.$store;
    if (peek(dragging))
      return;
    value.set(getClampedValue(min(), max(), value(), this.Db()));
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  Sg() {
    return ariaBool(this.p());
  }
  zc() {
    return this.$props.min();
  }
  Ac() {
    return this.$props.max();
  }
  Tg() {
    const { value } = this.$store;
    return Math.round(value());
  }
  fe() {
    const { value, max } = this.$store;
    return round(value() / max() * 100, 2) + "%";
  }
  // -------------------------------------------------------------------------------------------
  // Attributes
  // -------------------------------------------------------------------------------------------
  Qg() {
    const { disabled } = this.$props, { dragging, interactive, pointing } = this.$store;
    this.setAttributes({
      disabled,
      "data-dragging": dragging,
      "data-pointing": pointing,
      "data-interactive": interactive,
      "aria-disabled": this.Sg.bind(this),
      "aria-valuemin": this.zc.bind(this),
      "aria-valuemax": this.Ac.bind(this),
      "aria-valuenow": this.Tg.bind(this),
      "aria-valuetext": this.fe.bind(this),
      "data-styled": this.Ug.bind(this),
      "data-media-slider": true
    });
    effect(this.Vg.bind(this));
  }
  Ug() {
    return !!this.$props.trackClass();
  }
  Vg() {
    const { fillPercent, pointerPercent } = this.$store;
    this.Wg(round(fillPercent(), 3), round(pointerPercent(), 3));
  }
  Rg() {
    this.R = this.el.querySelector('[slot="preview"]');
    if (!this.R)
      return;
    effect(this.Xg.bind(this));
    import('./preview-JJG3ZTKT.js').then(({ setupPreviewStyles }) => {
      setupPreviewStyles(this.R, this.K);
    });
  }
  Xg() {
    if (this.p() || !this.R)
      return;
    window.requestAnimationFrame(this.ge);
    const observer = new ResizeObserver(this.ge);
    observer.observe(this.R);
    return () => observer.disconnect();
  }
  // -------------------------------------------------------------------------------------------
  // Events
  // -------------------------------------------------------------------------------------------
  sc(event) {
  }
  be(event) {
  }
  uc(event) {
  }
  tc(event) {
  }
};
Slider.el = defineElement({
  tagName: "media-slider",
  props: sliderProps,
  store: SliderStoreFactory
});

export { Slider, sliderProps };
