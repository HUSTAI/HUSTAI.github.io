export { DOMEvent, EventsTarget, appendTriggerEvent, attachDeclarativeShadowDOM, camelToKebabCase, camelToTitleCase, createComment, createFragment, findTriggerEvent, flattenArray, getOriginEvent, getSlottedChildren, hasTriggerEvent, isDOMElement, isDOMEvent, isDOMFragment, isDOMNode, isKeyboardClick, isKeyboardEvent, isMouseEvent, isPointerEvent, isTouchEvent, kebabToCamelCase, kebabToPascalCase, kebabToTitleCase, listenEvent, lowercaseFirstLetter, run, runAll, setAttribute, setStyle, toggleClass, trimTrailingSemicolon, uppercaseFirstChar, walkTriggerEventChain, wasEnterKeyPressed, wasEscapeKeyPressed } from './chunks/chunk-UQUIIFVF.js';
import { onDispose, noop } from './chunks/chunk-3GPUVQSV.js';
export { createRegex, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, unwrap, unwrapDeep } from './chunks/chunk-3GPUVQSV.js';

// src/std/aria.ts
function ariaBool(value) {
  return value ? "true" : "false";
}

// src/std/disposal.ts
function createDisposalBin() {
  const disposal = /* @__PURE__ */ new Set();
  return {
    add(...callbacks) {
      for (const callback of callbacks)
        disposal.add(callback);
    },
    empty() {
      for (const callback of disposal)
        callback();
      disposal.clear();
    }
  };
}
function useDisposalBin() {
  const disposal = createDisposalBin();
  onDispose(disposal.empty);
  return disposal;
}

// src/std/object.ts
function keysOf(obj) {
  return Object.keys(obj);
}
function mergeProperties(...sources) {
  const target = {};
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    if (source) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
  }
  return target;
}
function pick(source, props) {
  const target = {};
  for (const prop of props) {
    Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
  }
  return target;
}
function omit(source, props) {
  return pick(
    source,
    keysOf(source).filter((key) => !props.includes(key))
  );
}

// src/std/promise.ts
function deferredPromise() {
  let resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
function timedPromise(promise, timeout, timeoutMsg) {
  const timer = new Promise((_, reject) => {
    const timerId = setTimeout(() => {
      clearTimeout(timerId);
      reject(timeoutMsg);
    }, timeout);
  });
  return Promise.race([promise, timer]);
}

// src/std/timing.ts
function waitTimeout(delay) {
  return new Promise((resolve) => setTimeout(resolve, delay));
}
function waitAnimationFrame(callback) {
  return Promise.resolve();
}
function animationFrameThrottle(func) {
  return noop;
}
function waitIdlePeriod(callback, options) {
  return Promise.resolve();
}

export { animationFrameThrottle, ariaBool, createDisposalBin, deferredPromise, keysOf, mergeProperties, omit, pick, timedPromise, useDisposalBin, waitAnimationFrame, waitIdlePeriod, waitTimeout };
