import { createComment, DOMEvent, listenEvent, isDOMNode, createFragment, attachDeclarativeShadowDOM, setAttribute, toggleClass, setStyle, camelToKebabCase, trimTrailingSemicolon, flattenArray, runAll, isDOMElement } from './chunk-VABDA4SA.js';
import { root, isFunction, isArray, isString, isNumber, noop, unwrapDeep, effect, isUndefined, peek, scoped, computed, provideContext, isNull, isBoolean } from './chunk-NQ7TQAU7.js';
import { root as root$1, scoped as scoped$1, getScope, isFunction as isFunction$1, effect as effect$1, onDispose, tick, signal, untrack } from '@maverick-js/signals';

// src/std/html.ts
function escape(value, isAttr = false) {
  const type = typeof value;
  if (type !== "string") {
    if (!isAttr && type === "function")
      return escape(value());
    if (isAttr && type === "boolean")
      return value + "";
    return value;
  }
  const delimeter = isAttr ? '"' : "<", escapeDelimeter = isAttr ? "&quot;" : "&lt;";
  let iDelimeter = value.indexOf(delimeter), isAmpersand = value.indexOf("&");
  if (iDelimeter < 0 && isAmpersand < 0)
    return value;
  let left = 0, out = "";
  while (iDelimeter >= 0 && isAmpersand >= 0) {
    if (iDelimeter < isAmpersand) {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } else {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  }
  if (iDelimeter >= 0) {
    do {
      if (left < iDelimeter)
        out += value.substring(left, iDelimeter);
      out += escapeDelimeter;
      left = iDelimeter + 1;
      iDelimeter = value.indexOf(delimeter, left);
    } while (iDelimeter >= 0);
  } else
    while (isAmpersand >= 0) {
      if (left < isAmpersand)
        out += value.substring(left, isAmpersand);
      out += "&amp;";
      left = isAmpersand + 1;
      isAmpersand = value.indexOf("&", left);
    }
  return left < value.length ? out + value.substring(left) : out;
}

// src/runtime/ssr/render.ts
function renderToString(root4) {
  const result = root((dispose) => {
    const value = root4();
    dispose();
    return value;
  });
  return { code: resolve(escape(result)) };
}
var SSR_TEMPLATE = /* @__PURE__ */ Symbol();
function resolve(node) {
  if (isFunction(node)) {
    return resolve(node());
  } else if (isArray(node)) {
    let result = "";
    const flattened = node.flat(10);
    for (let i = 0; i < flattened.length; i++) {
      result += resolve(escape(flattened[i]));
    }
    return result + "<!/[]>";
  } else if (isString(node) || isNumber(node)) {
    return node + "";
  } else if (node?.[SSR_TEMPLATE]) {
    return node[SSR_TEMPLATE];
  }
  return "";
}
function injectHTML(html) {
  return { [SSR_TEMPLATE]: html };
}

// src/element/controller.ts
var ComponentController = class {
  /**
   * The custom element this component is attached to. This is safe to use server-side with the
   * limited API listed below.
   *
   * **Important:** Only specific DOM APIs are safe to call server-side. This includes:
   *
   * - Attributes: `getAttribute`, `setAttribute`, `removeAttribute`, and `hasAttribute`
   * - Classes: `classList` API
   * - Styles: `style` API
   * - Events (noop): `addEventListener`, `removeEventListener`, and `dispatchEvent`
   */
  get el() {
    return this.instance._el;
  }
  /**
   * Reactive component properties.
   */
  get $props() {
    return this.instance._props;
  }
  /**
   * Reactive component store.
   */
  get $store() {
    return this.instance._store;
  }
  constructor(instance) {
    this.instance = instance;
    if (this.onAttach)
      instance._attachCallbacks.push(this.onAttach.bind(this));
    if (this.onConnect)
      instance._connectCallbacks.push(this.onConnect.bind(this));
    if (this.onDisconnect)
      instance._disconnectCallbacks.push(this.onDisconnect.bind(this));
    if (this.onDestroy)
      instance._destroyCallbacks.push(this.onDestroy.bind(this));
  }
  /**
   * This method can be used to specify attributes that should be set on the host element. Any
   * attributes that are assigned to a function will be considered a signal and updated accordingly.
   */
  setAttributes(attributes) {
    if (this.instance._attrs)
      Object.assign(this.instance._attrs, attributes);
  }
  /**
   * This method can be used to specify styles that should set be set on the host element. Any
   * styles that are assigned to a function will be considered a signal and updated accordingly.
   */
  setStyles(styles) {
    if (this.instance._styles)
      Object.assign(this.instance._styles, styles);
  }
  /**
   * This method is used to satisfy the CSS variables contract specified on the current
   * custom element definition. Other CSS variables can be set via the `setStyles` method.
   */
  setCSSVars(vars) {
    this.setStyles(vars);
  }
  /**
   * Type-safe utility for creating component DOM events.
   */
  createEvent(type, ...init) {
    return new DOMEvent(type, init[0]);
  }
  /**
   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to
   * match all component events.
   */
  dispatch(type, ...init) {
    if (!this.el)
      return;
    const event = new DOMEvent(type, init[0]);
    this.el.dispatchEvent(event);
  }
  /**
   * Adds an event listener for the given `type` and returns a function which can be invoked to
   * remove the event listener.
   *
   * - The listener is removed if the current scope is disposed.
   * - This method is safe to use on the server (noop).
   */
  listen(type, handler, options) {
    if (!this.el)
      return noop;
    return listenEvent(this.el, type, handler, options);
  }
};

// src/element/component.ts
var Component = class extends ComponentController {
  constructor(instance) {
    super(instance);
    if (this.render && !instance._innerHTML && !instance._renderer) {
      instance._renderer = this.render.bind(this);
    }
  }
  destroy() {
    this.instance._destroy();
  }
};

// src/runtime/dom/reconcile.ts
function reconcile(parent, nodesA, nodesB) {
  let lengthB = nodesB.length, endA = nodesA.length, endB = lengthB, startA = 0, startB = 0, after = nodesA[endA - 1].nextSibling, map = null;
  while (startA < endA || startB < endB) {
    if (nodesA[startA] === nodesB[startB]) {
      startA++;
      startB++;
      continue;
    }
    while (nodesA[endA - 1] === nodesB[endB - 1]) {
      endA--;
      endB--;
    }
    if (endA === startA) {
      const node = endB < lengthB ? startB ? nodesB[startB - 1].nextSibling : nodesB[endB - startB] : after;
      while (startB < endB)
        parent.insertBefore(nodesB[startB++], node);
    } else if (endB === startB) {
      while (startA < endA) {
        if (!map || !map.has(nodesA[startA]))
          nodesA[startA].remove();
        startA++;
      }
    } else if (nodesA[startA] === nodesB[endB - 1] && nodesB[startB] === nodesA[endA - 1]) {
      const node = nodesA[--endA].nextSibling;
      parent.insertBefore(nodesB[startB++], nodesA[startA++].nextSibling);
      parent.insertBefore(nodesB[--endB], node);
      nodesA[endA] = nodesB[endB];
    } else {
      if (!map) {
        map = /* @__PURE__ */ new Map();
        let i = startB;
        while (i < endB)
          map.set(nodesB[i], i++);
      }
      const index = map.get(nodesA[startA]);
      if (index != null) {
        if (startB < index && index < endB) {
          let i = startA, sequence = 1, t;
          while (++i < endA && i < endB) {
            if ((t = map.get(nodesA[i])) == null || t !== index + sequence)
              break;
            sequence++;
          }
          if (sequence > index - startB) {
            const node = nodesA[startA];
            while (startB < index)
              parent.insertBefore(nodesB[startB++], node);
          } else
            parent.replaceChild(nodesB[startB++], nodesA[startA++]);
        } else
          startA++;
      } else
        nodesA[startA++].remove();
    }
  }
}

// src/runtime/dom/walker.ts
var createMarkerWalker = (root4) => (
  // @ts-expect-error - filter accepts `boolean` but not typed.
  document.createTreeWalker(root4, NodeFilter.SHOW_COMMENT, (node) => node.nodeValue === "$")
);

// src/runtime/dom/render.ts
var hydration = null;
function hydrate(root4, options) {
  return runHydration(() => render(root4, options), options);
}
function runHydration(run, options) {
  const prev = hydration;
  hydration = { w: createMarkerWalker(options.target) };
  const result = run();
  hydration = prev;
  return result;
}
function render(root4, options) {
  return root((dispose) => {
    if (!hydration) {
      insert(options.target, root4(), options.before);
    } else {
      unwrapDeep(root4);
    }
    return dispose;
  });
}

// src/runtime/dom/insert.ts
function insert(parent, value, marker) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    let current;
    effect(
      () => void (current = insertExpression(
        parent,
        unwrapDeep(value()),
        marker,
        current,
        true
      ))
    );
    return;
  } else if (hydration) {
    marker.remove();
  } else
    insertExpression(parent, value, marker);
}
function insertExpression(parent, value, marker, current, isSignal = false) {
  if (value === current)
    return current;
  if (isArray(value)) {
    const newNodes = [], currentNodes = hydration && marker ? claimArray(marker) : current && isArray(current) ? current : [];
    if (value.length && resolveArray(newNodes, value, currentNodes, isSignal)) {
      effect(() => void (current = insertExpression(parent, newNodes, marker, currentNodes, true)));
      return () => current;
    }
    if (hydration && marker)
      return currentNodes;
    if (newNodes.length === 0) {
      updateDOM(parent, current);
    } else if (currentNodes.length) {
      reconcile(parent, currentNodes, newNodes);
    } else {
      current && updateDOM(parent, current, marker);
      appendArray(parent, newNodes, marker);
    }
    return newNodes;
  } else if (isString(value) || isNumber(value)) {
    if (!isUndefined(marker)) {
      if (isDOMNode(current) && current.nodeType === 3) {
        current.data = value + "";
      } else if (!hydration) {
        return updateDOM(parent, current, marker, document.createTextNode(value + ""));
      } else {
        return marker.nextSibling;
      }
    } else if (current !== "" && isString(current)) {
      return parent.firstChild.data = value + "";
    } else
      return parent.textContent = value + "";
  } else if (isDOMNode(value)) {
    if (hydration) ; else if (marker || isArray(current)) {
      if (!isUndefined(marker))
        return current = updateDOM(parent, current, marker, value);
      updateDOM(parent, current, null, value);
    } else if (!current || !parent.firstChild) {
      parent.appendChild(value);
    } else
      parent.replaceChild(value, parent.firstChild);
    return value;
  } else {
    return updateDOM(parent, current, marker);
  }
  return current;
}
function appendArray(parent, nodes, marker) {
  if (isUndefined(marker)) {
    for (let i = 0; i < nodes.length; i++)
      parent.appendChild(nodes[i]);
  } else {
    for (let i = 0; i < nodes.length; i++)
      parent.insertBefore(nodes[i], marker);
  }
}
function resolveArray(nodes, values, current, computed2) {
  let value, prev, effect4 = false;
  for (let i = 0; i < values.length; i++) {
    value = values[i], prev = current[i];
    if (isDOMNode(value)) {
      nodes.push(value);
    } else if (isArray(value)) {
      effect4 = resolveArray(nodes, value, isArray(prev) ? prev : [], computed2) || effect4;
    } else if (isFunction(value)) {
      if (computed2) {
        value = value();
        effect4 = resolveArray(
          nodes,
          isArray(value) ? value : [value],
          isArray(prev) ? prev : [prev],
          true
        ) || effect4;
      } else {
        nodes.push(value);
        effect4 = true;
      }
    } else if (value || value === 0) {
      const text = value + "";
      if (prev && prev.nodeType === 3 && prev.data === text) {
        nodes.push(prev);
      } else {
        nodes.push(document.createTextNode(text));
      }
    }
  }
  return effect4;
}
var ARRAY_END_MARKER = "/[]";
function claimArray(marker) {
  let node = marker.nextSibling, nodes = [];
  while (node) {
    if (node.nodeType !== 8) {
      nodes.push(node);
    } else if (node.nodeValue === ARRAY_END_MARKER) {
      node.remove();
      break;
    }
    node = node.nextSibling;
  }
  return nodes;
}
function updateDOM(parent, current, marker, replace) {
  if (isUndefined(marker)) {
    parent.textContent = "";
    return;
  }
  const node = replace || createComment("~");
  if (isArray(current) && current.length) {
    let el, inserted = false, isParent = false;
    for (let i = current.length - 1; i >= 0; i--) {
      el = current[i];
      if (el !== node) {
        isParent = el.parentNode === parent;
        if (!inserted && !i)
          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);
        else
          isParent && parent.removeChild(el);
      } else
        inserted = true;
    }
  } else if (isDOMNode(current)) {
    parent.replaceChild(node, current);
  } else {
    parent.insertBefore(node, marker);
  }
  return node;
}

// src/runtime/dom/insert-lite.ts
var CONNECTED = /* @__PURE__ */ Symbol("CONNECTED" );
var INSERT_MARKER_NODE = createComment("$$");
var END_MARKER = /* @__PURE__ */ Symbol("END_MARKER" );
var END_MARKER_NODE = /* @__PURE__ */ createComment("/$");
var ARRAY_END_MARKER_VALUE = "/[]";
function insertLite(parent, value, before) {
  let isSignal = isFunction(value);
  if (isSignal && value[$$CHILDREN]) {
    value = value();
    isSignal = isFunction(value);
  }
  if (isSignal) {
    insertEffect(parent, value, before);
  } else if (!hydration && (value || value === 0)) {
    addChild(
      parent,
      isArray(value) ? resolveArray2(value) : isDOMNode(value) ? value : document.createTextNode(value + ""),
      before
    );
  }
}
function addChild(parent, node, before) {
  if (!node)
    return;
  if (before)
    parent.insertBefore(node, before);
  else
    parent.appendChild(node);
}
function insertEffect(parent, value, before) {
  const marker = before && before.nodeType === 8 ? before : INSERT_MARKER_NODE.cloneNode();
  if (marker !== before)
    addChild(parent, marker, before);
  effect(() => void insertExpression2(marker, unwrapDeep(value)));
}
function insertExpression2(start, value) {
  const end = start[END_MARKER];
  if (isArray(value)) {
    if (hydration) {
      start[END_MARKER] = findArrayEndMarker(start);
    } else {
      if (end)
        removeOldNodes(start, end);
      const fragment = resolveArray2(value);
      if (!fragment)
        return;
      if (!end)
        fragment.appendChild(createEndMarker(start));
      start.after(fragment);
    }
  } else if (isDOMNode(value)) {
    if (end)
      removeOldNodes(start, end);
    if (!hydration)
      start.after(value);
    if (!end)
      value.after(createEndMarker(start));
  } else if (isString(value) || isNumber(value)) {
    if (start[CONNECTED]) {
      start.nextSibling.data = value + "";
      return;
    }
    if (end)
      removeOldNodes(start, end);
    let text;
    if (!hydration) {
      text = document.createTextNode(value + "");
      start.after(text);
    } else {
      text = start.nextSibling;
    }
    start[CONNECTED] = true;
    if (!end)
      text.after(createEndMarker(start));
  } else if (end) {
    removeOldNodes(start, end);
  }
}
function createEndMarker(start) {
  return start[END_MARKER] = END_MARKER_NODE.cloneNode();
}
function findArrayEndMarker(node) {
  while (node) {
    if (node.nodeType === 8 && node.nodeValue === ARRAY_END_MARKER_VALUE)
      return node;
    node = node.nextSibling;
  }
}
function removeOldNodes(start, end) {
  while (start.nextSibling !== end)
    start.nextSibling.remove();
  start[CONNECTED] = false;
}
function resolveArray2(value) {
  const flattened = flattenArray(value);
  if (!flattened.length)
    return null;
  const fragment = createFragment();
  for (let i = 0; i < flattened.length; i++) {
    const child = flattened[i];
    if (isFunction(child)) {
      insertEffect(fragment, child);
    } else {
      fragment.append(child);
    }
  }
  return fragment;
}

// src/element/css.ts
var CSS = /* @__PURE__ */ Symbol();
var sheetCache = /* @__PURE__ */ new WeakMap();
var supported;
var supportsAdoptedStyleSheets = () => !isUndefined(supported) ? supported : supported = ShadowRoot && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
function injectCSS(value) {
  return createCSS(value + "");
}
function css(strings, ...values) {
  let css2 = strings[0] ?? "";
  for (let i = 0; i < values.length; i++) {
    const value = values[i];
    if (value?.[CSS]) {
      css2 += value.text;
    } else if (typeof value === "number") {
      css2 += value;
    } else {
      throw new Error(
        `[maverick] value passed to \`css\` function must be a \`css\` function result: ${value}. Use \`injectCSS\` to pass non-literal values, but take care to ensure page security.`
      );
    }
    css2 += strings[i + 1];
  }
  return createCSS(css2, strings);
}
function createCSS(css2, strings) {
  let styleSheet;
  return {
    [CSS]: true,
    get text() {
      return css2;
    },
    get sheet() {
      if (styleSheet) {
        return styleSheet;
      } else if (strings && sheetCache.has(strings)) {
        return sheetCache.get(strings);
      } else if (supportsAdoptedStyleSheets()) {
        (styleSheet = new CSSStyleSheet()).replaceSync(css2);
        if (strings)
          sheetCache.set(strings, styleSheet);
        return styleSheet;
      }
      return;
    },
    toString() {
      return css2;
    }
  };
}
function adoptCSS(root4, css2) {
  if (supportsAdoptedStyleSheets()) {
    root4.adoptedStyleSheets = css2.map((css3) => css3.sheet);
  } else {
    const style = document.createElement("style");
    style.textContent = css2.map((css3) => css3.text).join("");
    root4.appendChild(style);
  }
}

// src/element/register.ts
function registerCustomElement(Component2) {
  register(Component2, {
    insert,
    adoptCSS
  });
}
function registerLiteCustomElement(Component2) {
  register(Component2, {
    insert: insertLite
  });
}
function registerHeadlessCustomElement(Component2) {
  register(Component2);
}
var DOM_ELEMENT_REGISTRY = Symbol("MAVERICK_REGISTRY" );
var serverElementRegistry = void 0;
function register(Component2, init) {
  const tagName = Component2.el.tagName;
  if (!window.customElements.get(tagName)) {
    if (!window[DOM_ELEMENT_REGISTRY])
      window[DOM_ELEMENT_REGISTRY] = /* @__PURE__ */ new Map();
    window[DOM_ELEMENT_REGISTRY].set(tagName, Component2);
    window.customElements.define(tagName, createHTMLElement(Component2, init));
  }
}

// src/runtime/dom/internal.ts
function $$_create_template(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content;
}
var $$_create_fragment = createFragment;
function $$_create_walker(fragment, walker = hydration?.w) {
  try {
    return [$$_next_element(walker), walker];
  } catch (e) {
    return $$_create_walker(fragment, createMarkerWalker(document.importNode(fragment, true)));
  }
}
function $$_next_template(fragment) {
  return $$_create_walker(fragment)[0];
}
function $$_next_element(walker) {
  let element = walker.nextNode().nextSibling;
  if (element.localName.indexOf("-") > 0 && element.firstChild && element.firstChild.nodeName === "SHADOW-ROOT") {
    let node = element.firstChild.nextSibling || element.nextSibling;
    if (node)
      walker.currentNode = node;
  }
  return element;
}
var $$_hydrating = hydration;
function $$_setup_custom_element(host, props) {
  const Component2 = window[DOM_ELEMENT_REGISTRY]?.get(host.localName);
  if (!Component2) {
    throw Error(
      `[maverick] custom element not registered: ${host.localName}` 
    );
  }
  const component = createComponent(Component2, { props });
  host.attachComponent(component);
  return component.instance._scope;
}
function $$_clone(fragment) {
  const clone = document.importNode(fragment, true);
  return clone.firstElementChild;
}
function $$_create_element(tagName) {
  return document.createElement(tagName);
}
function $$_attach_declarative_shadow_dom(element) {
  if (element.firstChild?.nodeName === "TEMPLATE") {
    if (element.firstChild.hasAttribute("shadowroot")) {
      attachDeclarativeShadowDOM(element);
    } else {
      element.firstChild.remove();
    }
  }
}
var $$_insert = insert;
function $$_insert_at_marker(marker, value) {
  insert(marker.parentElement, value, marker);
}
var $$_insert_lite = insertLite;
function $$_insert_at_marker_lite(marker, value) {
  insertLite(marker.parentElement, value, marker);
}
function $$_create_component(component, props = {}) {
  return peek(() => component(props));
}
var $$CHILDREN = /* @__PURE__ */ Symbol("$$CHILDREN" );
function $$_children(fn) {
  fn[$$CHILDREN] = true;
  return fn;
}
function $$_ref(element, ref) {
  if (isArray(ref)) {
    ref.filter(isFunction).forEach((ref2) => ref2(element));
  } else if (isFunction(ref)) {
    ref(element);
  }
}
function $$_directive(element, directive, args) {
  if (isFunction(directive))
    directive(element, ...args);
}
var $$_attr = setAttribute;
var $$_class = toggleClass;
var $$_style = setStyle;
function $$_spread(element, props) {
  const keys = Object.keys(props);
  for (let i = 0; i < keys.length; i++) {
    const prop2 = keys[i];
    if (prop2 in element) {
      if (isFunction(props[prop2])) {
        effect(() => void (element[prop2] = props[prop2]()));
      } else {
        element[prop2] = props[prop2];
      }
    } else if (isFunction(props[prop2])) {
      effect(() => void $$_attr(element, prop2, props[prop2]()));
    } else {
      $$_attr(element, prop2, props[prop2]);
    }
  }
}
function $$_merge_props(...sources) {
  const target = sources[0] || {};
  for (let i = 1; i < sources.length; i++) {
    const source = sources[i];
    if (source)
      Object.assign(target, source);
  }
  return target;
}
function $$_listen(target, type, handler, capture = false) {
  if (isFunction(handler)) {
    listenEvent(target, type, handler, { capture });
  }
}
var DELEGATED_EVENTS = /* @__PURE__ */ Symbol("DELEGATED_EVENTS" );
function $$_delegate_events(types, document2 = window.document) {
  const events = document2[DELEGATED_EVENTS] ??= /* @__PURE__ */ new Set();
  for (let i = 0, len = types.length; i < len; i++) {
    const type = types[i];
    if (!events.has(type)) {
      events.add(type);
      document2.addEventListener(type, delegated_event_handler);
    }
  }
}
function delegated_event_handler(event) {
  const eventKey = `$$${event.type}`, dataKey = `$$${event.type}Data`;
  let node = event.composedPath && event.composedPath()[0] || event.target;
  if (event.target !== node) {
    Object.defineProperty(event, "target", {
      configurable: true,
      value: node
    });
  }
  Object.defineProperty(event, "currentTarget", {
    configurable: true,
    get() {
      return node || document;
    }
  });
  let handler, data;
  while (node) {
    handler = node[eventKey];
    if (handler && !node.disabled && isFunction(handler)) {
      data = node[dataKey];
      !isUndefined(data) ? handler.call(node, data, event) : handler.call(node, event);
    }
    node = node.parentNode || node.host;
  }
}
var $$_peek = peek;
var $$_scoped = scoped;
var $$_effect = effect;
var $$_computed = computed;
function hydrateLite(root4, options) {
  return runHydration(() => renderLite(root4, options), options);
}
function renderLite(root4, options) {
  return root$1((dispose) => {
    if (!hydration) {
      insertLite(options.target, root4());
    } else {
      unwrapDeep(root4);
    }
    return dispose;
  });
}

// src/element/internal.ts
var CONNECT = /* @__PURE__ */ Symbol("CONNECT" );
var PROPS = /* @__PURE__ */ Symbol("PROPS" );
var METHODS = /* @__PURE__ */ Symbol("METHODS" );
function createComponent(Component2, init) {
  const instance = new ComponentInstance(Component2, init);
  return scoped$1(() => new Component2(instance), instance._scope);
}
var ComponentInstance = class {
  constructor(Component2, init = {}) {
    this._el = null;
    this._renderer = null;
    this._innerHTML = false;
    this._destroyed = false;
    this._attrs = {};
    this._styles = {};
    this._props = {};
    // these props cause type issues - don't type them.
    this._state = null;
    this._store = null;
    this._attachCallbacks = [];
    this._connectCallbacks = [];
    this._disconnectCallbacks = [];
    this._destroyCallbacks = [];
    root$1((dispose) => {
      this._scope = getScope();
      this._dispose = dispose;
      if (init.scope)
        init.scope.append(this._scope);
      const store = Component2.el.store;
      if (store) {
        this._store = store.create();
        this._state = new Proxy(this._store, {
          get: (_, prop2) => this._store[prop2]()
        });
        provideContext(store, this._store);
      }
      const props = Component2.el.props;
      if (props) {
        this._props = createInstanceProps(props);
        if (init.props) {
          for (const prop2 of Object.keys(init.props)) {
            if (prop2 in props) {
              const value = init.props[prop2];
              if (isFunction$1(value)) {
                effect$1(() => void this._props[prop2].set(value()));
              } else {
                this._props[prop2].set(value);
              }
            }
          }
        }
      }
      if (init.props?.innerHTML) {
        this._innerHTML = true;
      }
      onDispose(this._destroy.bind(this));
    });
  }
  _destroy() {
    if (this._destroyed)
      return;
    this._destroyed = true;
    for (const destroy of this._destroyCallbacks) {
      scoped$1(() => destroy(this._el), this._scope);
    }
    this._el?.destroy();
    this._attachCallbacks.length = 0;
    this._connectCallbacks.length = 0;
    this._disconnectCallbacks.length = 0;
    this._destroyCallbacks.length = 0;
    tick();
    this._dispose();
    this._el = null;
    this._renderer = null;
  }
};
function createInstanceProps(defs) {
  const props = {};
  for (const name of Object.keys(defs)) {
    const def = defs[name];
    props[name] = signal(def.value, def);
  }
  return props;
}

// src/element/setup.ts
async function setup(host) {
  const parent = findParent(host);
  const hostCtor = host.constructor, componentCtor = hostCtor._component;
  if (parent) {
    await customElements.whenDefined(parent.localName);
    parent[CONNECT] === true || await new Promise((res) => parent[CONNECT].push(res));
  }
  if (host.isConnected) {
    if (parent?.keepAlive)
      host.keepAlive = true;
    host.attachComponent(
      createComponent(componentCtor, {
        scope: parent?.component?.instance._scope
      })
    );
  }
}
function resolvePropsFromAttrs(host) {
  const hostCtor = host.constructor, componentCtor = hostCtor._component, props = {};
  if (!hostCtor._attrs)
    return props;
  for (const attr of host.attributes) {
    let propName = hostCtor._attrs.get(attr.name), convert = propName && componentCtor.el.props[propName].type?.from;
    if (convert) {
      let attrValue = host.getAttribute(attr.name);
      props[propName] = convert(attrValue);
    }
  }
  return props;
}
function findParent(host) {
  let hostCtor = host.constructor, componentCtor = hostCtor._component, node = host.parentNode, prefix = componentCtor.el.tagName.split("-", 1)[0] + "-";
  while (node) {
    if (node.nodeType === 1 && node.localName.startsWith(prefix)) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}

// src/element/create-html-element.ts
function createHTMLElement(Component2, init) {
  const _register = Component2.register;
  if (Component2.register) {
    const result = isArray(_register) ? _register : _register?.();
    if (isArray(result))
      for (const Component3 of result)
        register(Component3, init);
  }
  let attrs;
  if (Component2.el.props) {
    attrs = /* @__PURE__ */ new Map();
    for (const propName of Object.keys(Component2.el.props)) {
      const def = Component2.el.props[propName];
      const attr = def.attribute;
      if (attr !== false) {
        const attrName = attr ?? camelToKebabCase(propName);
        attrs.set(attrName, propName);
      }
    }
  }
  class MaverickElement extends HTMLCustomElement {
    static get _component() {
      return Component2;
    }
  }
  MaverickElement._init = init;
  MaverickElement._attrs = attrs;
  const proto = MaverickElement.prototype, componentProto = Component2.prototype;
  if (Component2.el.props) {
    for (const prop2 of Object.keys(Component2.el.props)) {
      Object.defineProperty(proto, prop2, {
        enumerable: true,
        configurable: true,
        get() {
          return !this.component ? Component2.el.props[prop2].value : this.component.instance._props[prop2]();
        },
        set(value) {
          const fn = () => this.component.instance._props[prop2].set(value);
          if (!this.component) {
            this._queuedActions.delete(prop2);
            this._queuedActions.set(prop2, fn);
            return;
          }
          fn();
        }
      });
    }
  }
  if (componentProto[PROPS]) {
    for (const name of componentProto[PROPS]) {
      Object.defineProperty(proto, name, {
        enumerable: true,
        configurable: true,
        get() {
          return this.component ? this.component[name] : void 0;
        },
        set(value) {
          if (!this.component) {
            this._queuedActions.delete(name);
            this._queuedActions.set(name, () => {
              this.component[name] = value;
            });
            return;
          }
          this.component[name] = value;
        }
      });
    }
  }
  if (componentProto[METHODS]) {
    for (const name of componentProto[METHODS]) {
      proto[name] = function(...args) {
        if (!this.component)
          this._throwAttachError([`el.${name}(...)`]);
        return this.component[name](...args);
      };
    }
  }
  return MaverickElement;
}
var HTML_ELEMENT = HTMLElement;
var _a;
var HTMLCustomElement = class extends HTML_ELEMENT {
  constructor() {
    super(...arguments);
    this._connected = false;
    this._destroyed = false;
    this._component = null;
    this._connectScope = null;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this._disconnectCallbacks = [];
    this._queuedActions = /* @__PURE__ */ new Map();
    this.keepAlive = false;
    /** @internal */
    this[_a] = [];
    this._pendingSetup = false;
  }
  get _delegate() {
    return this.hasAttribute("mk-d");
  }
  get component() {
    return this._component;
  }
  get $store() {
    return this._component?.instance._store;
  }
  get state() {
    if (!this._component) {
      this._throwAttachError(["el.state.foo"]);
    }
    return this._component.instance._state;
  }
  static get observedAttributes() {
    return this._attrs ? Array.from(this._attrs.keys()) : [];
  }
  attributeChangedCallback(name, _, newValue) {
    const ctor = this.constructor;
    if (!this._component || !ctor._attrs)
      return;
    const propName = ctor._attrs.get(name);
    const from = ctor._component.el.props[propName]?.type?.from;
    if (from)
      this._component.instance._props[propName].set(from(newValue));
  }
  connectedCallback() {
    const instance = this._component?.instance;
    if (!this._delegate && !instance)
      return this._setup();
    if (!instance || !this.isConnected || this._connected)
      return;
    if (this._destroyed) {
      {
        throw Error(
          "[maverick] attempting to connect an element that has been destroyed" 
        );
      }
    }
    if (this.hasAttribute("keep-alive"))
      this.keepAlive = true;
    this._connected = true;
    if (instance._connectCallbacks.length) {
      scoped$1(() => {
        root$1((dispose) => {
          this._connectScope = getScope();
          for (const connectCallback of instance._connectCallbacks) {
            scoped$1(() => {
              const disconnectCallback = connectCallback(this);
              if (isFunction$1(disconnectCallback)) {
                this._disconnectCallbacks.push(disconnectCallback);
              }
            }, this._connectScope);
          }
          this._disconnectCallbacks.push(dispose);
        });
      }, instance._scope);
    }
    if (isArray(this[CONNECT])) {
      runAll(this[CONNECT], this);
      this[CONNECT] = true;
    }
    return;
  }
  disconnectedCallback() {
    const instance = this._component?.instance;
    if (!this._connected || this._destroyed)
      return;
    this._connected = false;
    for (const callback of this._disconnectCallbacks) {
      scoped$1(callback, this._connectScope);
    }
    if (instance?._disconnectCallbacks.length) {
      for (const callback of instance._disconnectCallbacks) {
        scoped$1(() => callback(this), instance._scope);
      }
    }
    this._connectScope = null;
    if (!this._delegate && !this.keepAlive) {
      requestAnimationFrame(() => {
        if (!this.isConnected) {
          instance?._destroy();
          this._destroyed = true;
        }
      });
    }
  }
  attachComponent(component) {
    const instance = component.instance, ctor = this.constructor, def = ctor._component.el, init = ctor._init;
    if (this._component) {
      console.warn(`[maverick] element \`${def.tagName}\` already has attached component`);
    }
    if (this._destroyed) {
      console.warn(`[maverick] attempted attaching to destroyed element \`${def.tagName}\``);
    }
    if (this._component || this._destroyed)
      return;
    scoped$1(() => {
      this._root = instance._renderer ? def.shadowRoot ? this.shadowRoot ?? this.attachShadow(isBoolean(def.shadowRoot) ? { mode: "open" } : def.shadowRoot) : resolveShadowRootElement(this) : null;
      if (def.css && !init?.adoptCSS) {
        console.warn(
          `[maverick] \`css\` was provided for \`${def.tagName}\` but element registration doesn't support adopting stylesheets. Resolve this by registering element with \`registerElement\` instead of lite or headless.`
        );
      }
      if (!hydration && def.shadowRoot && def.css && init?.adoptCSS) {
        init.adoptCSS(this._root, def.css);
      }
      instance._el = this;
      this._component = component;
      const attrValues = resolvePropsFromAttrs(this);
      for (const name of Object.keys(attrValues)) {
        instance._props[name].set(attrValues[name]);
      }
      if (this._queuedActions?.size) {
        for (const action of this._queuedActions.values())
          action();
      }
      this._queuedActions = null;
      for (const callback of [...instance._attachCallbacks, ...this._attachCallbacks]) {
        scoped$1(() => callback(this), instance._scope);
      }
      instance._attachCallbacks.length = 0;
      this._attachCallbacks = null;
      const $attrs = instance._attrs, $styles = instance._styles;
      if ($attrs) {
        for (const name of Object.keys($attrs)) {
          if (isFunction$1($attrs[name])) {
            effect$1(() => setAttribute(this, name, $attrs[name]()));
          } else {
            setAttribute(this, name, $attrs[name]);
          }
        }
      }
      if ($styles) {
        for (const name of Object.keys($styles)) {
          if (isFunction$1($styles[name])) {
            effect$1(() => setStyle(this, name, $styles[name]()));
          } else {
            setStyle(this, name, $styles[name]);
          }
        }
      }
      this.dispatchEvent(new Event("attached"));
      if (this._root && init && instance._renderer) {
        const insert2 = () => init.insert(this._root, instance._renderer);
        if (this.hasAttribute("mk-h") && !ctor._component.el.nohydrate) {
          runHydration(insert2, { target: this._root });
        } else {
          insert2();
        }
      }
      this.connectedCallback();
    }, instance._scope);
  }
  subscribe(callback) {
    if (!this._component) {
      this._throwAttachError(["el.subscribe(({ foo, bar }) => {", "  // ...", "});"]);
    }
    if (!this._component?.instance._state) {
      const ctor = this.constructor;
      const tagName = ctor._component.el.tagName;
      throw Error(`[maverick] \`${tagName}\` element does not have a store to subscribe to`);
    }
    return scoped$1(() => {
      return effect$1(() => callback(this._component.instance._state));
    }, this._component.instance._scope);
  }
  onAttach(callback) {
    if (this._component) {
      callback(this);
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => this._attachCallbacks?.delete(callback);
    }
  }
  onEventDispatch(callback) {
    const ctor = this.constructor;
    if (ctor._dispatchedEvents)
      for (const eventType of ctor._dispatchedEvents)
        callback(eventType);
    this._onEventDispatch = callback;
  }
  destroy() {
    this.disconnectedCallback();
    this._component?.destroy();
    this._component = null;
    this._destroyed = true;
  }
  dispatchEvent(event) {
    if (this._delegate) {
      const ctor = this.constructor;
      if (!ctor._dispatchedEvents)
        ctor._dispatchedEvents = /* @__PURE__ */ new Set();
      if (!ctor._dispatchedEvents.has(event.type)) {
        this._onEventDispatch?.(event.type);
        ctor._dispatchedEvents.add(event.type);
      }
    }
    return untrack(() => super.dispatchEvent(event));
  }
  async _setup() {
    if (this._pendingSetup)
      return;
    this._pendingSetup = true;
    await setup(this);
    this._pendingSetup = false;
  }
  _throwAttachError(code) {
    {
      const ctor = this.constructor;
      const tagName = ctor._component.el.tagName;
      throw Error(
        `[maverick] component instance has not attached yet, wait for event like so:

const el = document.querySelector('${tagName}');
el.addEventListener('attached', () => {
` + ("  " + code.join("\n  ")) + `
}, { once: true });
`
      );
    }
  }
};
_a = CONNECT;
function resolveShadowRootElement(root4) {
  if (root4.firstChild && isDOMElement(root4.firstChild) && root4.firstChild.localName === "shadow-root") {
    return root4.firstChild;
  } else {
    const shadowRoot = $$_create_element("shadow-root");
    root4.prepend(shadowRoot);
    return shadowRoot;
  }
}
var registry = /* @__PURE__ */ new Map();
function createServerElement(Component2) {
  if (registry.has(Component2))
    return registry.get(Component2);
  const register2 = Component2.register;
  if (Component2.register) {
    const result = isArray(register2) ? register2 : register2?.();
    if (isArray(result)) {
      for (const Component3 of result) {
        serverElementRegistry.set(Component3.el.tagName, Component3);
      }
    }
  }
  class MaverickElement extends ServerCustomElement {
    static get _component() {
      return Component2;
    }
  }
  registry.set(Component2, MaverickElement);
  return MaverickElement;
}
var ServerCustomElement = class {
  constructor() {
    this.keepAlive = false;
    this._component = null;
    this._rendered = false;
    this._attachCallbacks = /* @__PURE__ */ new Set();
    this.attributes = new Attributes();
    this.style = new Style();
    this.classList = new ClassList();
  }
  get component() {
    return this._component;
  }
  get $store() {
    return this._component?.instance._store;
  }
  get state() {
    return {};
  }
  attachComponent(component) {
    scoped$1(() => {
      this.setAttribute("mk-h", "");
      this.setAttribute("mk-d", "");
      if (this.hasAttribute("class")) {
        parseClassAttr(this.classList.tokens, this.getAttribute("class"));
      }
      if (this.hasAttribute("style")) {
        parseStyleAttr(this.style.tokens, this.getAttribute("style"));
      }
      const instance = component.instance;
      instance._el = this;
      this._component = component;
      for (const callback of [...instance._attachCallbacks, ...this._attachCallbacks]) {
        callback(this);
      }
      this._attachCallbacks = null;
      const $attrs = instance._attrs, $styles = instance._styles;
      if ($attrs) {
        for (const name of Object.keys($attrs))
          setAttribute(this, name, unwrapDeep($attrs[name]));
      }
      if ($styles) {
        for (const name of Object.keys($styles))
          setStyle(this, name, unwrapDeep($styles[name]));
      }
      this._rendered = !!instance._renderer;
      this._ssr = instance._renderer ? renderToString(instance._renderer).code : "";
      if (this.classList.length > 0) {
        this.setAttribute("class", this.classList.toString());
      }
      if (this.style.length > 0) {
        this.setAttribute("style", this.style.toString());
      }
    }, component.instance._scope);
  }
  render() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `render` before attaching component");
    }
    const innerHTML = this.renderInnerHTML(), def = this.constructor._component.el;
    return this._rendered || def.shadowRoot && def.css ? def.shadowRoot ? `<template shadowroot="${this.getShadowRootMode()}">${innerHTML}</template>` : `<shadow-root>${innerHTML}</shadow-root>` : innerHTML;
  }
  renderInnerHTML() {
    if (typeof this._ssr !== "string") {
      throw Error("[maverick] called `renderInnerHTML` before attaching component");
    }
    const def = this.constructor._component.el, styleTag = def.shadowRoot && def.css ? `<style>${def.css.map((css2) => css2.text).join("")}</style>` : "";
    return styleTag + this._ssr;
  }
  getShadowRootMode() {
    const def = this.constructor._component.el;
    return def.shadowRoot ? isBoolean(def.shadowRoot) ? "open" : def.shadowRoot.mode : "open";
  }
  getAttribute(name) {
    return this.attributes.getAttribute(name);
  }
  setAttribute(name, value) {
    this.attributes.setAttribute(name, value);
  }
  hasAttribute(name) {
    return this.attributes.hasAttribute(name);
  }
  removeAttribute(name) {
    return this.attributes.removeAttribute(name);
  }
  dispatchEvent() {
    return false;
  }
  onEventDispatch() {
  }
  addEventListener() {
  }
  removeEventListener() {
  }
  subscribe() {
    return noop;
  }
  onAttach(callback) {
    if (this._component) {
      callback(this);
      return noop;
    } else {
      this._attachCallbacks.add(callback);
      return () => this._attachCallbacks?.delete(callback);
    }
  }
  destroy() {
    this._component?.destroy();
  }
};
var Attributes = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getAttribute(name) {
    return this._tokens.get(name) ?? null;
  }
  hasAttribute(name) {
    return this._tokens.has(name);
  }
  setAttribute(name, value) {
    this._tokens.set(name, value + "");
  }
  removeAttribute(name) {
    this._tokens.delete(name);
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += ` ${name}="${escape(value, true)}"`;
    }
    return result;
  }
};
var Style = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Map();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  getPropertyValue(prop2) {
    return this._tokens.get(prop2) ?? "";
  }
  setProperty(prop2, value) {
    this._tokens.set(prop2, value ?? "");
  }
  removeProperty(prop2) {
    const value = this._tokens.get(prop2);
    this._tokens.delete(prop2);
    return value ?? "";
  }
  toString() {
    if (this._tokens.size === 0)
      return "";
    let result = "";
    for (const [name, value] of this._tokens) {
      result += `${name}: ${value};`;
    }
    return result;
  }
};
var ClassList = class {
  constructor() {
    this._tokens = /* @__PURE__ */ new Set();
  }
  get length() {
    return this._tokens.size;
  }
  get tokens() {
    return this._tokens;
  }
  add(...tokens) {
    for (const token of tokens) {
      this._tokens.add(token);
    }
  }
  contains(token) {
    return this._tokens.has(token);
  }
  remove(token) {
    this._tokens.delete(token);
  }
  replace(token, newToken) {
    if (!this._tokens.has(token))
      return false;
    this._tokens.delete(token);
    this._tokens.add(newToken);
    return true;
  }
  toggle(token, force) {
    if (force !== true && (this._tokens.has(token) || force === false)) {
      this._tokens.delete(token);
      return false;
    } else {
      this._tokens.add(token);
      return true;
    }
  }
  toString() {
    return Array.from(this._tokens).join(" ");
  }
};

// src/element/props.ts
var PROP_DEF = Symbol("PROP_DEF" );
function defineProp(definition) {
  return { [PROP_DEF]: true, ...definition };
}

// src/element/define.ts
function defineElement(declaration) {
  if ("props" in declaration) {
    const props = declaration.props;
    for (const name of Object.keys(props)) {
      const def = props[name]?.[PROP_DEF] ? props[name] : { [PROP_DEF]: true, value: props[name] };
      if (def.attribute !== false && !def.type)
        def.type = inferAttributeType(def.value);
      props[name] = def;
    }
  }
  return declaration;
}
var STRING = {
  from: (v) => v === null ? "" : v + ""
};
var NUMBER = {
  from: (v) => v === null ? 0 : Number(v)
};
var BOOLEAN = {
  from: (v) => v !== null,
  to: (v) => v ? "" : null
};
var FUNCTION = {
  from: false,
  to: () => null
};
var ARRAY = {
  from: (v) => v === null ? [] : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
var OBJECT = {
  from: (v) => v === null ? {} : JSON.parse(v),
  to: (v) => JSON.stringify(v)
};
function inferAttributeType(value) {
  if (value === null)
    return STRING;
  switch (typeof value) {
    case "undefined":
      return STRING;
    case "string":
      return STRING;
    case "boolean":
      return BOOLEAN;
    case "number":
      return NUMBER;
    case "function":
      return FUNCTION;
    case "object":
      return isArray(value) ? ARRAY : OBJECT;
    default:
      return STRING;
  }
}

// src/element/decorators.ts
function prop(target, propertyKey, descriptor) {
  if (!target[PROPS])
    target[PROPS] = /* @__PURE__ */ new Set();
  target[PROPS].add(propertyKey);
}
function method(target, propertyKey, descriptor) {
  if (!target[METHODS])
    target[METHODS] = /* @__PURE__ */ new Set();
  target[METHODS].add(propertyKey);
}

// src/runtime/ssr/internal.ts
function $$_ssr(template, ...parts) {
  let result = "";
  for (let i = 0; i < template.length; i++) {
    result += template[i];
    result += resolve(escape(parts[i]));
  }
  return { [SSR_TEMPLATE]: result };
}
function $$_custom_element(tagName, props, spreads) {
  const Component2 = serverElementRegistry.get(tagName);
  if (!Component2) {
    throw Error(`[maverick] custom element not registered: ${tagName}`);
  }
  const host = new (createServerElement(Component2))();
  if (spreads && spreads.length > 0) {
    const spread = $$_merge_spreads(spreads);
    for (const [key, value] of spread.attributes) {
      host.setAttribute(key, value);
    }
    for (const token of spread.classList) {
      host.classList.add(token);
    }
    for (const [key, value] of spread.styles) {
      host.style.setProperty(key, value);
    }
  }
  const component = createComponent(Component2, { props });
  host.attachComponent(component);
  const children = !props?.innerHTML && props?.$children ? scoped(() => props.$children(), component.instance._scope) : [];
  return [
    host.attributes + ">",
    injectHTML(!props?.innerHTML ? host.render() : props.innerHTML),
    ...children
  ];
}
function $$_attr2(name, value) {
  const attrValue = resolveAtrr(value);
  return isString(attrValue) ? ` ${name}="${escape(attrValue, true)}"` : "";
}
function resolveAtrr(value) {
  if (isFunction(value))
    return resolveAtrr(value());
  if (!value && value !== "" && value !== 0) {
    return null;
  } else {
    return value + "";
  }
}
function $$_classes(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? baseValue : "";
  if (tokens && Object.keys(tokens).length > 0) {
    const classList = /* @__PURE__ */ new Set();
    parseClassAttr(classList, result);
    resolveClasses(classList, tokens);
    result = Array.from(classList).join(" ");
  }
  result = result.trim();
  return result.length ? ` class="${escape(result, true)}"` : "";
}
var classSplitRE = /\s+/;
function parseClassAttr(tokens, attrValue) {
  const classes = attrValue.trim().split(classSplitRE);
  for (const token of classes)
    tokens.add(token);
}
function resolveClasses(classList, tokens) {
  for (const name of Object.keys(tokens)) {
    if (unwrapDeep(tokens[name])) {
      classList.add(name);
    } else {
      classList.delete(name);
    }
  }
}
function $$_styles(base, tokens) {
  let baseValue = unwrapDeep(base), result = isString(baseValue) ? trimTrailingSemicolon(baseValue) : "";
  if (Object.keys(tokens).length > 0) {
    const styleMap = /* @__PURE__ */ new Map();
    parseStyleAttr(styleMap, result);
    resolveStyles(styleMap, tokens);
    result = "";
    for (const [name, value] of styleMap)
      result += `${name}: ${value};`;
  }
  result = result.trim();
  return result.length ? ` style="${escape(result, true)}"` : result;
}
var styleSplitRE = /\s*:\s*/;
var stylesDelimeterRE = /\s*;\s*/;
function parseStyleAttr(tokens, attrValue) {
  const styles = attrValue.trim().split(stylesDelimeterRE);
  for (let i = 0; i < styles.length; i++) {
    if (styles[i] === "")
      continue;
    const [name, value] = styles[i].split(styleSplitRE);
    tokens.set(name, value);
  }
}
function resolveStyles(tokens, styles) {
  for (const name of Object.keys(styles)) {
    const value = unwrapDeep(styles[name]);
    if (!value && value !== 0) {
      tokens.delete(name);
    } else {
      tokens.set(name, value + "");
    }
  }
}
var propNameRE = /[A-Z]/;
function $$_merge_spreads(spreads) {
  let attributes = /* @__PURE__ */ new Map(), classList = /* @__PURE__ */ new Set(), styles = /* @__PURE__ */ new Map();
  for (let i = 0; i < spreads.length; i++) {
    const { $$class, $$style, class: classBase, style: styleBase, ...attrs } = spreads[i];
    const attrNames = Object.keys(attrs);
    for (let j = 0; j < attrNames.length; j++) {
      const attrName = attrNames[j];
      if (!propNameRE.test(attrName)) {
        const attrValue = resolveAtrr(attrs[attrName]);
        if (isString(attrValue)) {
          attributes.set(attrName, attrValue);
        } else {
          attributes.delete(attrName);
        }
      }
    }
    if ("class" in spreads[i]) {
      const base = unwrapDeep(classBase);
      if (isNull(base) || base === false) {
        classList.clear();
      } else if (isString(base) && base.length) {
        parseClassAttr(classList, base + "");
      }
    }
    if ($$class)
      resolveClasses(classList, $$class);
    if ("style" in spreads[i]) {
      const base = unwrapDeep(styleBase);
      if (isNull(base) || base === false) {
        styles.clear();
      } else if (isString(base) && base.length) {
        parseStyleAttr(styles, base);
      }
    }
    if ($$style)
      resolveStyles(styles, $$style);
  }
  return { attributes, classList, styles };
}
function $$_spread2(spreads) {
  const { attributes, classList, styles } = $$_merge_spreads(spreads);
  let result = "";
  if (classList.size > 0) {
    let _class = Array.from(classList).join(" ");
    result += `class="${escape(_class.trim(), true)}"`;
  }
  for (const [name, value] of attributes) {
    result += ` ${name}="${escape(value, true)}"`;
  }
  if (styles.size > 0) {
    let _styles = "";
    for (const [name, value] of styles)
      _styles += `${name}: ${value};`;
    result += ` style="${escape(_styles.trim(), true)}"`;
  }
  return result.trim();
}
function $$_inject_html(value) {
  return injectHTML(resolve(value));
}
var $$_scoped2 = scoped;
/**
 * The code below this comment was adapted from Lit: https://github.dev/lit/lit
 *
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */

export { $$CHILDREN, $$_attach_declarative_shadow_dom, $$_attr2 as $$_attr, $$_attr as $$_attr2, $$_children, $$_class, $$_classes, $$_clone, $$_computed, $$_create_component, $$_create_element, $$_create_fragment, $$_create_template, $$_create_walker, $$_custom_element, $$_delegate_events, $$_directive, $$_effect, $$_hydrating, $$_inject_html, $$_insert, $$_insert_at_marker, $$_insert_at_marker_lite, $$_insert_lite, $$_listen, $$_merge_props, $$_merge_spreads, $$_next_element, $$_next_template, $$_peek, $$_ref, $$_scoped2 as $$_scoped, $$_scoped as $$_scoped2, $$_setup_custom_element, $$_spread2 as $$_spread, $$_spread as $$_spread2, $$_ssr, $$_style, $$_styles, ARRAY, BOOLEAN, Component, ComponentController, ComponentInstance, FUNCTION, NUMBER, OBJECT, PROP_DEF, SSR_TEMPLATE, STRING, adoptCSS, createComponent, createHTMLElement, createServerElement, css, defineElement, defineProp, hydrate, hydrateLite, hydration, inferAttributeType, injectCSS, injectHTML, method, parseClassAttr, parseStyleAttr, prop, registerCustomElement, registerHeadlessCustomElement, registerLiteCustomElement, render, renderLite, renderToString, resolve, runHydration };
