import { setContext, getScope, getContext, computed, signal, effect as effect$1, onError, peek } from '@maverick-js/signals';
export { computed, createScope, getScope, isReadSignal, isWriteSignal, onDispose, onError, peek, readonly, root, scoped, signal, tick, untrack } from '@maverick-js/signals';
import { computedMap, computedKeyedMap } from '@maverick-js/signals/map';

// src/runtime/accessors.ts
function createAccessors(record) {
  const accessors = {};
  for (const name of Object.keys(record)) {
    Object.defineProperty(accessors, name, {
      configurable: true,
      enumerable: true,
      get: record[name],
      set: record[name].set
    });
  }
  return accessors;
}

// src/std/unit.ts
function noop(...args) {
}
function isNull(value) {
  return value === null;
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isNil(value) {
  return isNull(value) || isUndefined(value);
}
function isObject(value) {
  return value?.constructor === Object;
}
function isNumber(value) {
  return typeof value === "number" && !Number.isNaN(value);
}
function isString(value) {
  return typeof value === "string";
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function isFunction(value) {
  return typeof value === "function";
}
function isArray(value) {
  return Array.isArray(value);
}
function createRegex(regex) {
  return isString(regex) ? new RegExp(regex) : regex;
}
function isWindow(value) {
  return value === window;
}
function createContext(provide) {
  return { id: Symbol(), provide };
}
function provideContext(context, value, scope = getScope()) {
  const hasProvidedValue = !isUndefined(value);
  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);
}
function useContext(context) {
  const value = getContext(context.id);
  return value;
}
function hasProvidedContext(context) {
  return !isUndefined(getContext(context.id));
}

// src/runtime/store.ts
var StoreFactory = class {
  constructor(record) {
    this.id = Symbol(0);
    this.record = record;
    this.v = Object.getOwnPropertyDescriptors(record);
  }
  create() {
    const store = {}, state = new Proxy(store, { get: (_, prop) => store[prop]() });
    for (const name of Object.keys(this.record)) {
      const getter = this.v[name].get;
      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);
    }
    return store;
  }
  reset(record, filter) {
    for (const name of Object.keys(record)) {
      if (!this.v[name].get && (!filter || filter(name))) {
        record[name].set(this.record[name]);
      }
    }
  }
};
function useStore(store) {
  return useContext(store);
}

// src/runtime/reactivity.ts
var effect = effect$1;

// src/std/signal.ts
function unwrap(fn) {
  return isFunction(fn) ? fn() : fn;
}
function unwrapDeep(fn) {
  let value = fn;
  while (typeof value === "function")
    value = value();
  return value;
}

// src/runtime/components/ErrorBoundary.ts
function ErrorBoundary(props) {
  const $e = signal(null);
  const $error = () => $e();
  $error.handled = () => $e.set(null);
  return computed(
    () => {
      const $children = unwrap(props.$children);
      onError((error) => {
        $e.set(error);
        props.onError?.(error, $error.handled);
      });
      return isFunction($children) && $children.length > 0 ? peek(() => $children($error)) : $children;
    },
    { initial: null }
  );
}
function For(props) {
  return computedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}
function ForKeyed(props) {
  return computedKeyedMap(
    () => unwrap(props.each),
    unwrap(props.$children),
    void 0
  );
}

export { ErrorBoundary, For, ForKeyed, StoreFactory, createAccessors, createContext, createRegex, effect, hasProvidedContext, isArray, isBoolean, isFunction, isNil, isNull, isNumber, isObject, isString, isUndefined, isWindow, noop, provideContext, unwrap, unwrapDeep, useContext, useStore };
