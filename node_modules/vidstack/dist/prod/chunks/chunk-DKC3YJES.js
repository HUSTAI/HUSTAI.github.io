import { isMediaStream, isHLSSrc } from './chunk-FRNAFKFA.js';
import { IS_SAFARI } from './chunk-WSYKLWQE.js';
import { getNumberOfDecimalPlaces } from './chunk-CVLY5S52.js';
import { isUndefined, isNumber, setAttribute, isString, useDisposalBin, listenEvent, DOMEvent, isNil } from 'maverick.js/std';
import { effect, onDispose } from 'maverick.js';

var RAFLoop = class {
  constructor(_callback) {
    this.ja = _callback;
  }
  qb() {
    if (!isUndefined(this.Ba))
      return;
    this.kd();
  }
  ia() {
    if (isNumber(this.Ba))
      window.cancelAnimationFrame(this.Ba);
    this.Ba = void 0;
  }
  kd() {
    this.Ba = window.requestAnimationFrame(() => {
      if (isUndefined(this.Ba))
        return;
      this.ja();
      this.kd();
    });
  }
};

// src/player/core/providers/html/htmlâ€“media-events.ts
var HTMLMediaEvents = class {
  constructor(_provider, _context) {
    this.j = _provider;
    this.c = _context;
    this.ba = useDisposalBin();
    this.Ya = false;
    this.ld = false;
    this.md = false;
    this.rb = new RAFLoop(this.Qe.bind(this));
    this.kf = void 0;
    this.xi = void 0;
    this.Re();
    effect(this.Se.bind(this));
    onDispose(this.Sb.bind(this));
  }
  get a() {
    return this.j.media;
  }
  get d() {
    return this.c.delegate;
  }
  Sb() {
    this.rb.ia();
    this.ba.empty();
  }
  /**
   * The `timeupdate` event fires surprisingly infrequently during playback, meaning your progress
   * bar (or whatever else is synced to the currentTime) moves in a choppy fashion. This helps
   * resolve that by retrieving time updates in a request animation frame loop.
   */
  Qe() {
    const newTime = this.j.currentTime;
    if (this.c.$store.currentTime() !== newTime)
      this.Ca(newTime);
  }
  Re() {
    this.s("loadstart", this.ka);
    this.s("abort", this.nd);
    this.s("emptied", this.Te);
    this.s("error", this.la);
  }
  Ue() {
    if (this.ld)
      return;
    this.ba.add(
      this.s("loadeddata", this.Ve),
      this.s("loadedmetadata", this.We),
      this.s("canplay", this.sb),
      this.s("canplaythrough", this.Xe),
      this.s("durationchange", this.Ye),
      this.s("play", this.Ze),
      this.s("progress", this._e),
      this.s("stalled", this.$e),
      this.s("suspend", this.af)
    );
    this.ld = true;
  }
  bf() {
    if (this.md)
      return;
    this.ba.add(
      this.s("pause", this.cf),
      this.s("playing", this.df),
      this.s("ratechange", this.ef),
      this.s("seeked", this.ff),
      this.s("seeking", this.gf),
      this.s("ended", this.hf),
      this.s("volumechange", this.Tb),
      this.s("waiting", this.jf)
    );
    this.md = true;
  }
  s(eventType, handler) {
    return listenEvent(
      this.a,
      eventType,
      handler.bind(this)
    );
  }
  yi(event2) {
    return;
  }
  Ca(time, trigger) {
    this.d.e("time-update", {
      // Avoid errors where `currentTime` can have higher precision.
      detail: {
        currentTime: Math.min(time, this.c.$store.seekableEnd()),
        played: this.a.played
      },
      trigger
    });
  }
  ka(event2) {
    if (this.a.networkState === 3) {
      this.nd(event2);
      return;
    }
    this.Ue();
    this.d.e("load-start", { trigger: event2 });
  }
  nd(event2) {
    this.d.e("abort", { trigger: event2 });
  }
  Te() {
    this.d.e("emptied", { trigger: event });
  }
  Ve(event2) {
    this.d.e("loaded-data", { trigger: event2 });
  }
  We(event2) {
    this.od();
    this.bf();
    this.d.e("volume-change", {
      detail: {
        volume: this.a.volume,
        muted: this.a.muted
      }
    });
    this.d.e("loaded-metadata", { trigger: event2 });
    if (IS_SAFARI && isHLSSrc(this.c.$store.source())) {
      this.d.pd(this.Ub(), event2);
    }
  }
  Ub() {
    return {
      duration: this.a.duration,
      buffered: this.a.buffered,
      seekable: this.a.seekable
    };
  }
  od() {
    const isLive = !Number.isFinite(this.a.duration);
    this.d.e("stream-type-change", {
      detail: isLive ? "live" : "on-demand"
    });
  }
  Ze(event2) {
    if (!this.c.$store.canPlay)
      return;
    this.d.e("play", { trigger: event2 });
  }
  cf(event2) {
    if (this.a.readyState === 1 && !this.Ya)
      return;
    this.Ya = false;
    this.rb.ia();
    this.d.e("pause", { trigger: event2 });
  }
  sb(event2) {
    this.d.pd(this.Ub(), event2);
  }
  Xe(event2) {
    if (this.c.$store.started())
      return;
    this.d.e("can-play-through", {
      trigger: event2,
      detail: this.Ub()
    });
  }
  df(event2) {
    this.Ya = false;
    this.d.e("playing", { trigger: event2 });
    this.rb.qb();
  }
  $e(event2) {
    this.d.e("stalled", { trigger: event2 });
    if (this.a.readyState < 3) {
      this.Ya = true;
      this.d.e("waiting", { trigger: event2 });
    }
  }
  jf(event2) {
    if (this.a.readyState < 3) {
      this.Ya = true;
      this.d.e("waiting", { trigger: event2 });
    }
  }
  hf(event2) {
    this.rb.ia();
    this.Ca(this.a.duration, event2);
    this.d.e("end", { trigger: event2 });
    if (this.c.$store.loop()) {
      this.lf();
    } else {
      this.d.e("ended", { trigger: event2 });
    }
  }
  Se() {
    if (this.c.$store.paused()) {
      listenEvent(this.a, "timeupdate", this.Vb.bind(this));
    }
  }
  Vb(event2) {
    this.Ca(this.a.currentTime, event2);
  }
  Ye(event2) {
    this.od();
    if (this.c.$store.ended()) {
      this.Ca(this.a.duration, event2);
    }
    this.d.e("duration-change", {
      detail: this.a.duration,
      trigger: event2
    });
  }
  Tb(event2) {
    this.d.e("volume-change", {
      detail: {
        volume: this.a.volume,
        muted: this.a.muted
      },
      trigger: event2
    });
  }
  ff(event2) {
    this.Ca(this.a.currentTime, event2);
    this.d.e("seeked", {
      detail: this.a.currentTime,
      trigger: event2
    });
    if (Math.trunc(this.a.currentTime) === Math.trunc(this.a.duration) && getNumberOfDecimalPlaces(this.a.duration) > getNumberOfDecimalPlaces(this.a.currentTime)) {
      this.Ca(this.a.duration, event2);
      if (!this.a.ended) {
        this.c.player.dispatchEvent(
          new DOMEvent("media-play-request", {
            trigger: event2
          })
        );
      }
    }
  }
  gf(event2) {
    this.d.e("seeking", {
      detail: this.a.currentTime,
      trigger: event2
    });
  }
  _e(event2) {
    this.d.e("progress", {
      detail: {
        buffered: this.a.buffered,
        seekable: this.a.seekable
      },
      trigger: event2
    });
  }
  lf() {
    const hasCustomControls = isNil(this.a.controls);
    if (hasCustomControls)
      this.a.controls = false;
    this.c.player.dispatchEvent(new DOMEvent("media-loop-request"));
  }
  af(event2) {
    this.d.e("suspend", { trigger: event2 });
  }
  ef(event2) {
    this.d.e("rate-change", {
      detail: this.a.playbackRate,
      trigger: event2
    });
  }
  la(event2) {
    const error = this.a.error;
    if (!error)
      return;
    this.d.e("error", {
      detail: {
        message: error.message,
        code: error.code,
        mediaError: error
      },
      trigger: event2
    });
  }
};

// src/foundation/list/symbols.ts
var LIST_ADD = Symbol(0);
var LIST_REMOVE = Symbol(0);
var LIST_RESET = Symbol(0);
var LIST_SELECT = Symbol(0);
var LIST_READONLY = Symbol(0);
var LIST_SET_READONLY = Symbol(0);
var LIST_ON_RESET = Symbol(0);
var LIST_ON_REMOVE = Symbol(0);
var LIST_ON_USER_SELECT = Symbol(0);

// src/player/core/providers/html/native-audio-tracks.ts
var NativeAudioTracks = class {
  constructor(_provider, _context) {
    this.j = _provider;
    this.c = _context;
    this.Za.onaddtrack = this.mf.bind(this);
    this.Za.onremovetrack = this.nf.bind(this);
    this.Za.onchange = this.of.bind(this);
    listenEvent(this.c.audioTracks, "change", this.pf.bind(this));
  }
  get Za() {
    return this.j.media.audioTracks;
  }
  mf(event2) {
    const _track = event2.track;
    if (_track.label === "")
      return;
    const audioTrack = {
      id: _track.id + "",
      label: _track.label,
      language: _track.language,
      kind: _track.kind,
      selected: false
    };
    this.c.audioTracks[LIST_ADD](audioTrack, event2);
    if (_track.enabled)
      audioTrack.selected = true;
  }
  nf(event2) {
    const track = this.c.audioTracks.getById(event2.track.id);
    if (track)
      this.c.audioTracks[LIST_REMOVE](track, event2);
  }
  of(event2) {
    let enabledTrack = this.qd();
    if (!enabledTrack)
      return;
    const track = this.c.audioTracks.getById(enabledTrack.id);
    if (track)
      this.c.audioTracks[LIST_SELECT](track, true, event2);
  }
  qd() {
    return Array.from(this.Za).find((track) => track.enabled);
  }
  pf(event2) {
    const { current } = event2.detail;
    if (!current)
      return;
    const track = this.Za.getTrackById(current.id);
    if (track) {
      const prev = this.qd();
      if (prev)
        prev.enabled = false;
      track.enabled = true;
    }
  }
};

// src/player/core/providers/html/provider.ts
var HTMLMediaProvider = class {
  constructor(_media) {
    this.a = _media;
  }
  setup(context) {
    new HTMLMediaEvents(this, context);
    if ("audioTracks" in this.media)
      new NativeAudioTracks(this, context);
  }
  get type() {
    return "";
  }
  get media() {
    return this.a;
  }
  get paused() {
    return this.a.paused;
  }
  get muted() {
    return this.a.muted;
  }
  set muted(muted) {
    this.a.muted = muted;
  }
  get volume() {
    return this.a.volume;
  }
  set volume(volume) {
    this.a.volume = volume;
  }
  get currentTime() {
    return this.a.currentTime;
  }
  set currentTime(time) {
    this.a.currentTime = time;
  }
  get playsinline() {
    return this.a.hasAttribute("playsinline");
  }
  set playsinline(playsinline) {
    setAttribute(this.a, "playsinline", playsinline);
  }
  get playbackRate() {
    return this.a.playbackRate;
  }
  set playbackRate(rate) {
    this.a.playbackRate = rate;
  }
  async play() {
    return this.a.play();
  }
  async pause() {
    return this.a.pause();
  }
  async loadSource({ src }, preload) {
    this.a.preload = preload;
    if (isMediaStream(src)) {
      this.a.srcObject = src;
    } else {
      this.a.srcObject = null;
      this.a.src = isString(src) ? src : window.URL.createObjectURL(src);
    }
    this.a.load();
  }
};

export { HTMLMediaProvider, LIST_ADD, LIST_ON_REMOVE, LIST_ON_RESET, LIST_ON_USER_SELECT, LIST_READONLY, LIST_REMOVE, LIST_RESET, LIST_SELECT, LIST_SET_READONLY, RAFLoop };
