import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { IS_SAFARI } from './chunk-WSYKLWQE.js';
import { round, clampNumber, getNumberOfDecimalPlaces } from './chunk-CVLY5S52.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-DDO45JSG.js';
import { $$_create_walker, $$_effect, $$_attr, $$_next_element, $$_create_template } from 'maverick.js/dom';
import { provideContext, effect, peek } from 'maverick.js';
import { defineElement, Component, ComponentController } from 'maverick.js/element';
import { animationFrameThrottle, setStyle, ariaBool, listenEvent, isNull, isNumber, isDOMEvent, isKeyboardEvent, isUndefined } from 'maverick.js/std';

// src/player/ui/sliders/slider/api/props.ts
var sliderProps = {
  min: 0,
  max: 100,
  disabled: false,
  value: 100,
  step: 1,
  keyStep: 1,
  shiftKeyMultiplier: 5,
  trackClass: null,
  trackFillClass: null,
  trackProgressClass: null,
  thumbContainerClass: null,
  thumbClass: null
};

// src/player/ui/sliders/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/sliders/slider/events-controller.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
var SliderEventsController = class extends ComponentController {
  constructor(instance, _delegate, _media) {
    super(instance);
    this.d = _delegate;
    this.a = _media;
    this.Oa = null;
    this.qa = null;
    this.Pa = null;
    this.ra = null;
    this.Qa = null;
    this.Qg = functionThrottle(
      (event) => {
        this.ea(this.Db(event), event);
      },
      20,
      { leading: true }
    );
  }
  onConnect() {
    effect(this.Ig.bind(this));
    effect(this.Jg.bind(this));
    if (this.d.Kg) {
      scopedRaf(() => {
        const outlet = this.a.player?.querySelector("media-outlet");
        if (outlet) {
          this.Oa = outlet;
          listenEvent(outlet, "touchstart", this.Lg.bind(this));
          listenEvent(outlet, "touchmove", this.Mg.bind(this));
        }
      });
    }
  }
  Lg(event) {
    this.qa = event.touches[0].clientX;
  }
  Mg(event) {
    if (isNull(this.qa))
      return;
    event.preventDefault();
    if (this.$store.dragging())
      return;
    const diff = event.touches[0].clientX - this.qa;
    if (Math.abs(diff) > 20) {
      this.qa = event.touches[0].clientX;
      this.Pa = this.$store.value();
      this.rc(this.Pa, event);
    }
  }
  Ig() {
    if (this.d.p())
      return;
    this.listen("focus", this.Wa.bind(this));
    this.listen("pointerenter", this.Ob.bind(this));
    this.listen("pointermove", this.Ng.bind(this));
    this.listen("pointerleave", this.Pb.bind(this));
    this.listen("pointerdown", this.Og.bind(this));
    this.listen("keydown", this.ab.bind(this));
    this.listen("keyup", this.$a.bind(this));
  }
  Jg() {
    if (this.d.p() || !this.$store.dragging())
      return;
    listenEvent(document, "pointerup", this.Pg.bind(this));
    listenEvent(document, "pointermove", this.Qg.bind(this));
    if (IS_SAFARI) {
      listenEvent(document, "touchmove", this.Rg.bind(this), {
        passive: false
      });
    }
  }
  Wa() {
    this.ea(this.$store.value());
  }
  sc(newValue, trigger) {
    const { value, min, max, dragging } = this.$store;
    const clampedValue = Math.max(min(), Math.min(newValue, max()));
    value.set(clampedValue);
    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
    this.el.dispatchEvent(event);
    this.d.tc(event);
    if (dragging()) {
      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
      this.el.dispatchEvent(event2);
      this.d.uc(event2);
    }
  }
  ea(value, trigger) {
    const { pointerValue, dragging } = this.$store;
    pointerValue.set(value);
    this.dispatch("pointer-value-change", { detail: value, trigger });
    if (dragging()) {
      const dir = this.d.L === "vertical" ? "bottom" : "left", size = this.d.L === "vertical" ? "height" : "width";
      if (this.Qa && !this.el?.hasAttribute("data-chapters")) {
        this.Qa.style[size] = value + "%";
      }
      if (this.ra) {
        this.ra.style[dir] = value + "%";
      }
      this.sc(value, trigger);
    }
  }
  Db(event) {
    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$store;
    if (this.d.L === "vertical") {
      const { bottom: trackBottom, height: trackHeight } = rect;
      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
    } else {
      if (this.qa && isNumber(this.Pa)) {
        const { width } = this.Oa.getBoundingClientRect(), rate = (event.clientX - this.qa) / width, range = max() - min(), diff = range * Math.abs(rate);
        thumbPositionRate = (rate < 0 ? this.Pa - diff : this.Pa + diff) / range;
      } else {
        const { left: trackLeft, width: trackWidth } = rect;
        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
      }
    }
    return Math.max(
      min(),
      Math.min(
        max(),
        this.d.ae(
          getValueFromRate(min(), max(), thumbPositionRate, this.d.Eb())
        )
      )
    );
  }
  Ob(event) {
    this.$store.pointing.set(true);
  }
  Ng(event) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    this.ea(this.Db(event), event);
  }
  Pb(event) {
    this.$store.pointing.set(false);
  }
  Og(event) {
    if (event.button !== 0)
      return;
    const value = this.Db(event);
    this.rc(value, event);
    this.ea(value, event);
  }
  rc(value, trigger) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    dragging.set(true);
    this.ra = this.el.querySelector(
      'shadow-root > div[part="thumb-container"]'
    );
    this.Qa = this.el.querySelector(
      'shadow-root > div[part~="track-fill"]'
    );
    this.a.remote.pauseUserIdle(trigger);
    const event = this.createEvent("drag-start", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.d.be(event);
  }
  ce(value, trigger) {
    const { dragging } = this.$store;
    if (!dragging())
      return;
    dragging.set(false);
    if (this.Qa) {
      setStyle(this.Qa, "width", null);
      this.Qa = null;
    }
    if (this.ra) {
      setStyle(this.ra, "left", null);
      setStyle(this.ra, "bottom", null);
      this.ra = null;
    }
    this.a.remote.resumeUserIdle(trigger);
    const event = this.createEvent("drag-end", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this.d.vc(event);
    this.qa = null;
    this.Pa = null;
  }
  ab(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key } = event;
    const { min, max } = this.$store;
    let newValue;
    if (key === "Home" || key === "PageUp") {
      newValue = min();
    } else if (key === "End" || key === "PageDown") {
      newValue = max();
    } else if (!event.metaKey && /[0-9]/.test(key)) {
      newValue = (max() - min()) / 10 * Number(key);
    }
    if (!isUndefined(newValue)) {
      this.ea(newValue, event);
      this.sc(newValue, event);
      return;
    }
    const value = this.de(event);
    if (!value)
      return;
    const repeat = key === this.wc;
    if (!this.$store.dragging() && repeat)
      this.rc(value, event);
    this.ea(value, event);
    if (!repeat)
      this.sc(value, event);
    this.wc = key;
  }
  $a(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    this.wc = "";
    const { dragging, value } = this.$store;
    if (!dragging())
      return;
    const newValue = this.de(event) ?? value();
    this.ea(newValue);
    this.ce(newValue, event);
  }
  de(event) {
    const { key, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key);
    if (!isValidKey)
      return;
    const { shiftKeyMultiplier } = this.$props;
    const { value } = this.$store, step = this.d.Eb(), keyStep = this.d.ee();
    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, steps = (value() + diff) / step;
    return Number((step * steps).toFixed(3));
  }
  // -------------------------------------------------------------------------------------------
  // Document (Pointer Events)
  // -------------------------------------------------------------------------------------------
  Pg(event) {
    if (event.button !== 0)
      return;
    const value = this.Db(event);
    this.ea(value, event);
    this.ce(value, event);
  }
  Rg(event) {
    event.preventDefault();
  }
};

// src/player/ui/sliders/slider/slider.tsx
var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><div part="track"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-fill"></div>`);
var $$_templ_3 = /* @__PURE__ */ $$_create_template(`<!$><div part="track track-progress"></div>`);
var $$_templ_4 = /* @__PURE__ */ $$_create_template(`<!$><div part="thumb-container"><!$><div part="thumb"></div></div>`);
var Slider = class extends Component {
  constructor(instance) {
    super(instance);
    this.xc = false;
    this.L = "";
    this.Zg = animationFrameThrottle(
      (fillPercent, pointerPercent) => {
        this.el?.style.setProperty("--slider-fill-percent", fillPercent + "%");
        this.el?.style.setProperty("--slider-pointer-percent", pointerPercent + "%");
      }
    );
    // -------------------------------------------------------------------------------------------
    // Preview
    // -------------------------------------------------------------------------------------------
    this.T = null;
    this.ge = animationFrameThrottle(() => {
      if (!this.T)
        return;
      const rect = this.T.getBoundingClientRect();
      setStyle(this.T, "--computed-width", rect.width + "px");
      setStyle(this.T, "--computed-height", rect.height + "px");
    });
    provideContext(sliderValueFormatContext);
    this.a = useMedia();
    new SliderEventsController(instance, this, this.a);
    const focus = new FocusVisibleController(instance);
    this.$store.focused = focus.focused.bind(focus);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "role", "slider");
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(el, "autocomplete", "off");
    this.L = el.getAttribute("aria-orientation") || "";
    if (!this.xc) {
      effect(this.Sg.bind(this));
      effect(this.yc.bind(this));
    }
    effect(this.zc.bind(this));
    this.Tg();
  }
  onConnect(el) {
    this.Ug();
  }
  render() {
    const { trackClass, trackFillClass, trackProgressClass, thumbContainerClass, thumbClass } = this.$props;
    return [
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ);
        $$_effect(() => $$_attr($$_root, "class", trackClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_2);
        $$_effect(() => $$_attr($$_root, "class", trackFillClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_3);
        $$_effect(() => $$_attr($$_root, "class", trackProgressClass()));
        return $$_root;
      })(),
      (() => {
        const [$$_root, $$_walker] = $$_create_walker($$_templ_4), $$_el = $$_next_element($$_walker);
        $$_effect(() => $$_attr($$_root, "class", thumbContainerClass()));
        $$_effect(() => $$_attr($$_el, "class", thumbClass()));
        return $$_root;
      })()
    ];
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  Eb() {
    return this.$props.step();
  }
  ee() {
    return this.$props.keyStep();
  }
  ae(value) {
    return Math.round(value);
  }
  p() {
    return this.$props.disabled();
  }
  // -------------------------------------------------------------------------------------------
  // Watch
  // -------------------------------------------------------------------------------------------
  Sg() {
    const { min, max } = this.$props;
    this.$store.min.set(min());
    this.$store.max.set(max());
  }
  yc() {
    if (!this.p())
      return;
    const { dragging, pointing } = this.$store;
    dragging.set(false);
    pointing.set(false);
  }
  zc() {
    const { dragging, value, min, max } = this.$store;
    if (peek(dragging))
      return;
    value.set(getClampedValue(min(), max(), value(), this.Eb()));
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  Vg() {
    return ariaBool(this.p());
  }
  Ac() {
    return this.$props.min();
  }
  Bc() {
    return this.$props.max();
  }
  Wg() {
    const { value } = this.$store;
    return Math.round(value());
  }
  fe() {
    const { value, max } = this.$store;
    return round(value() / max() * 100, 2) + "%";
  }
  // -------------------------------------------------------------------------------------------
  // Attributes
  // -------------------------------------------------------------------------------------------
  Tg() {
    const { disabled } = this.$props, { dragging, interactive, pointing } = this.$store;
    this.setAttributes({
      disabled,
      "data-dragging": dragging,
      "data-pointing": pointing,
      "data-interactive": interactive,
      "aria-disabled": this.Vg.bind(this),
      "aria-valuemin": this.Ac.bind(this),
      "aria-valuemax": this.Bc.bind(this),
      "aria-valuenow": this.Wg.bind(this),
      "aria-valuetext": this.fe.bind(this),
      "data-styled": this.Xg.bind(this),
      "data-media-slider": true
    });
    effect(this.Yg.bind(this));
  }
  Xg() {
    return !!this.$props.trackClass();
  }
  Yg() {
    const { fillPercent, pointerPercent } = this.$store;
    this.Zg(round(fillPercent(), 3), round(pointerPercent(), 3));
  }
  Ug() {
    this.T = this.el.querySelector('[slot="preview"]');
    if (!this.T)
      return;
    effect(this._g.bind(this));
    import('./preview-JJG3ZTKT.js').then(({ setupPreviewStyles }) => {
      setupPreviewStyles(this.T, this.L);
    });
  }
  _g() {
    if (this.p() || !this.T)
      return;
    window.requestAnimationFrame(this.ge);
    const observer = new ResizeObserver(this.ge);
    observer.observe(this.T);
    return () => observer.disconnect();
  }
  // -------------------------------------------------------------------------------------------
  // Events
  // -------------------------------------------------------------------------------------------
  tc(event) {
  }
  be(event) {
  }
  vc(event) {
  }
  uc(event) {
  }
};
Slider.el = defineElement({
  tagName: "media-slider",
  props: sliderProps,
  store: SliderStoreFactory
});

export { Slider, sliderProps };
