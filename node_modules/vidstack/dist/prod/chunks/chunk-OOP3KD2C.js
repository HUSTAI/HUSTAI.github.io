import { $ariaBool } from './chunk-EVP5E6AO.js';
import { onPress, setAttributeIfEmpty, isElementParent } from './chunk-HQQTSFXD.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { menuContext } from './chunk-HSL7QSWM.js';
import { __decorateClass } from './chunk-VPSTUDLO.js';
import { signal, hasProvidedContext, useContext, provideContext, effect, scoped, peek, tick, onDispose } from 'maverick.js';
import { defineElement, method, Component } from 'maverick.js/element';
import { setAttribute, setStyle, listenEvent, ariaBool, isKeyboardEvent } from 'maverick.js/std';

var FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [
  "a[href]",
  "[tabindex]",
  "input",
  "select",
  "button"
].map((selector) => `${selector}:not([aria-hidden])`).join(",");
var VALID_KEYS = /* @__PURE__ */ new Set([
  "Escape",
  "Tab",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "PageUp",
  "End",
  "PageDown",
  "Enter",
  " "
]);
var MenuFocusController = class {
  constructor(_delegate) {
    this.d = _delegate;
    this.Z = 0;
    this.ta = null;
    this.U = [];
  }
  get q() {
    return this.U;
  }
  Fh(el) {
    listenEvent(el, "focus", this.Wa.bind(this));
    this.ta = el;
  }
  Gh() {
    if (!this.ta)
      return;
    this.S();
    listenEvent(this.ta, "keyup", this.$a.bind(this));
    listenEvent(this.ta, "keydown", this.ab.bind(this));
    onDispose(() => {
      this.Z = 0;
      this.U = [];
    });
  }
  S() {
    this.Z = 0;
    this.U = this.Hh();
  }
  re(index = this.se()) {
    const element = this.U[index], container = this.d.Ih();
    if (element && container) {
      requestAnimationFrame(() => {
        container.scrollTop = element.offsetTop - container.offsetHeight / 2 + element.offsetHeight / 2;
      });
    }
  }
  Ra(index) {
    this.Z = index;
    this.U[index]?.focus();
    this.re(index);
  }
  se() {
    return this.U.findIndex((el) => el.getAttribute("aria-checked") === "true");
  }
  Wa() {
    setTimeout(() => {
      const index = this.se();
      this.Ra(index >= 0 ? index : 0);
    }, 100);
  }
  $a(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
  }
  ab(event) {
    if (!VALID_KEYS.has(event.key))
      return;
    event.stopPropagation();
    event.preventDefault();
    switch (event.key) {
      case "Escape":
        this.d.Jh(event);
        break;
      case "Tab":
        this.Ra(this.Sc(event.shiftKey ? -1 : 1));
        break;
      case "ArrowUp":
        this.Ra(this.Sc(-1));
        break;
      case "ArrowDown":
        this.Ra(this.Sc(1));
        break;
      case "Home":
      case "PageUp":
        this.Ra(0);
        break;
      case "End":
      case "PageDown":
        this.Ra(this.U.length - 1);
        break;
    }
  }
  Sc(delta) {
    let index = this.Z;
    do {
      index = (index + delta + this.U.length) % this.U.length;
    } while (this.U[index].offsetParent === null);
    return index;
  }
  Hh() {
    if (!this.ta)
      return [];
    const focusableElements = this.ta.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];
    const is = (node) => node.hasAttribute("data-media-menu-items");
    for (const el of focusableElements) {
      if (el instanceof HTMLElement && el.offsetParent !== null && // does not have display: none
      isElementParent(this.ta, el, is)) {
        elements.push(el);
      }
    }
    return elements;
  }
};

// src/player/ui/menu/menu.tsx
var idCount = 0;
var Menu = class extends Component {
  constructor(instance) {
    super(instance);
    this.I = signal(false);
    this.te = signal(false);
    this.ue = signal(false);
    this.jb = /* @__PURE__ */ new Set();
    this.Vc = null;
    this.r = null;
    this.Ib = null;
    this.Di = this.ua.bind(this);
    this.Th = this.Uh.bind(this);
    this.Rh = this.Vh.bind(this);
    this.Sh = this.Wh.bind(this);
    this.a = useMedia();
    const currentIdCount = ++idCount;
    this.Tc = `media-menu-${currentIdCount}`;
    this.Uc = `media-menu-button-${currentIdCount}`;
    if (hasProvidedContext(menuContext)) {
      this.K = useContext(menuContext);
    }
    this.kb = new MenuFocusController({
      Ih: this.Kh.bind(this),
      Jh: this.close.bind(this)
    });
    provideContext(menuContext, {
      I: this.I,
      lb: signal(""),
      ua: this.ua.bind(this),
      Wc: this.Wc.bind(this),
      Xc: this.Xc.bind(this),
      Yc: this.Yc.bind(this),
      Zc: this.Zc.bind(this),
      _c: this._c.bind(this)
    });
  }
  onAttach(el) {
    const { position } = this.$props;
    this.setAttributes({
      position,
      "data-open": this.I,
      "data-submenu": !!this.K,
      "data-disabled": this.p.bind(this),
      "data-media-menu": true
    });
  }
  onConnect(el) {
    if (!this.K) {
      effect(this.ve.bind(this));
    }
    effect(this.Lh.bind(this));
    this.K?._c(el);
    requestAnimationFrame(() => this.G());
  }
  onDestroy() {
    this.we();
    this.Vc = null;
    this.r = null;
    this.Ib = null;
  }
  we() {
    if (!this.r || this.el?.contains(this.r))
      return;
    const menu = this.r?.parentElement;
    this.el.append(this.r);
    if (menu?.localName === "media-menu") {
      menu.destroy();
      menu.remove();
    }
  }
  ve() {
    if (!this.el)
      return;
    const { breakpointX, breakpointY, viewType, orientation, fullscreen } = this.a.$store, popup = viewType() === "audio" ? breakpointX() === "sm" : breakpointY() === "sm";
    if (!this.r || this.K)
      return;
    setAttribute(this.el, "data-popup", popup);
    setAttribute(this.el, "data-popup-wide", popup && orientation() === "landscape");
    if (popup && !fullscreen()) {
      if (this.el.contains?.(this.r)) {
        const menu = this.el.cloneNode();
        menu.appendChild(this.r);
        requestAnimationFrame(() => {
          if (!this.el)
            return;
          const mediaRing = "--media-focus-ring", mediaRingValue = getComputedStyle(this.el).getPropertyValue(mediaRing);
          if (mediaRingValue)
            setStyle(menu, mediaRing, mediaRingValue);
        });
        scoped(() => {
          document.body.append(menu);
        }, this.a.scope);
      }
    }
    this.G();
    return () => this.we();
  }
  Lh() {
    const expanded = this.xe();
    this.G();
    this.ye(expanded);
    if (!expanded)
      return;
    this.kb.Gh();
    const closeTarget = this.Mh();
    if (closeTarget) {
      onPress(closeTarget, this.Nh.bind(this));
    }
    this.listen("pointerup", this.Oh.bind(this));
    listenEvent(window, "pointerup", this.Ph.bind(this));
  }
  Wc(el) {
    const isMenuItem = !!this.K, isExpanded = this.xe.bind(this), isARIAExpanded = $ariaBool(isExpanded), isARIADisabled = $ariaBool(this.p.bind(this));
    setAttributeIfEmpty(el, "tabindex", isMenuItem ? "-1" : "0");
    setAttributeIfEmpty(el, "role", isMenuItem ? "menuitem" : "button");
    setAttribute(el, "id", this.Uc);
    setAttribute(el, "aria-controls", this.Tc);
    setAttribute(el, "aria-haspopup", "true");
    effect(() => {
      setAttribute(el, "aria-disabled", isARIADisabled());
      setAttribute(el, "aria-expanded", isARIAExpanded());
      if (!isMenuItem)
        setAttribute(el, "aria-pressed", isARIAExpanded());
      setAttribute(el, "data-pressed", isExpanded());
    });
    setAttribute(el, "data-media-button", !isMenuItem);
    setAttribute(el, "data-media-menu-button", "");
    onPress(el, this.Qh.bind(this));
    this.Vc = el;
  }
  Xc(el) {
    setAttributeIfEmpty(el, "role", "menu");
    setAttributeIfEmpty(el, "tabindex", "-1");
    setAttribute(el, "id", this.Tc);
    setAttribute(el, "aria-describedby", this.Uc);
    setAttribute(el, "data-media-menu-items", "");
    this.r = el;
    this.kb.Fh(el);
    this.ve();
    this.ye(peek(this.I));
  }
  Yc(observer) {
    this.Ib = observer;
  }
  ye(expanded) {
    if (this.r)
      setAttribute(this.r, "aria-hidden", ariaBool(!expanded));
  }
  Zc(disabled) {
    this.ue.set(disabled);
  }
  Qh(event) {
    if (this.K)
      event.stopPropagation();
    if (this.p())
      return;
    this.I.set((expanded) => !expanded);
    this.$c();
    tick();
    if (isKeyboardEvent(event)) {
      this.r?.focus();
    }
    this.o(event);
  }
  o(trigger) {
    const expanded = peek(this.I);
    this.dispatch(expanded ? "open" : "close", { trigger });
    if (expanded) {
      if (!this.K) {
        this.a.activeMenu?.close(trigger);
        this.a.activeMenu = this;
      }
      this.Ib?.ad?.(trigger);
    } else {
      if (!this.K) {
        setTimeout(() => {
          for (const el of this.jb)
            el.close(trigger);
        }, 300);
        this.a.activeMenu = null;
      }
      this.Ib?.Ci?.(trigger);
    }
    if (expanded && !isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        this.kb.S();
        setTimeout(() => {
          this.kb.re();
        }, 100);
      });
    }
  }
  xe() {
    return !this.p() && this.I();
  }
  p() {
    return this.te() || this.ue();
  }
  ua(disabled) {
    this.te.set(disabled);
  }
  Oh(event) {
    event.stopPropagation();
  }
  Ph() {
    if (this.K)
      return setTimeout(this.close.bind(this), 800);
    else
      this.close();
  }
  Nh(event) {
    event.stopPropagation();
    this.close(event);
  }
  Mh() {
    const target = this.el.querySelector('[slot="close-target"]');
    return isElementParent(this.el, target) ? target : null;
  }
  Kh() {
    if (!this.K) {
      return this.r;
    } else {
      let el = this.el;
      while (el && el.tagName !== "media-menu" && el.hasAttribute("data-submenu")) {
        el = el.parentNode;
      }
      return el;
    }
  }
  $c(trigger) {
    if (this.K)
      return;
    if (this.I())
      this.a.remote.pauseUserIdle(trigger);
    else
      this.a.remote.resumeUserIdle(trigger);
  }
  _c(el) {
    this.jb.add(el);
    listenEvent(el, "open", this.Rh);
    listenEvent(el, "close", this.Sh);
    onDispose(this.Th);
  }
  Uh(el) {
    this.jb.delete(el);
  }
  Vh(event) {
    for (const el of this.jb) {
      if (el !== event.target)
        el.setAttribute("aria-hidden", "true");
    }
    this.G();
  }
  Wh() {
    for (const el of this.jb)
      el.removeAttribute("aria-hidden");
    this.G();
  }
  G() {
    if (!this.r || false)
      return;
    let style = getComputedStyle(this.r), height = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    let children = [...this.r.children];
    if (children[0]?.localName === "shadow-root") {
      children.push(...children[0].children);
    }
    for (const child of children) {
      height += child.offsetHeight;
    }
    requestAnimationFrame(() => {
      if (!this.r)
        return;
      setAttribute(this.r, "data-resizing", "");
      setTimeout(() => {
        if (!this.r)
          return;
        setAttribute(this.r, "data-resizing", false);
      }, 250);
      setStyle(this.r, "--menu-height", height + "px");
    });
  }
  open(trigger) {
    if (peek(this.I))
      return;
    this.I.set(true);
    tick();
    this.o(trigger);
    if (isKeyboardEvent(trigger)) {
      this.r?.focus();
    }
    this.$c(trigger);
  }
  close(trigger) {
    if (!peek(this.I))
      return;
    this.I.set(false);
    tick();
    if (isKeyboardEvent(trigger)) {
      requestAnimationFrame(() => {
        this.Vc?.focus();
      });
    }
    this.o(trigger);
    this.$c(trigger);
  }
};
Menu.el = defineElement({
  tagName: "media-menu",
  props: { position: null }
});
__decorateClass([
  method
], Menu.prototype, "open", 1);
__decorateClass([
  method
], Menu.prototype, "close", 1);

export { Menu };
