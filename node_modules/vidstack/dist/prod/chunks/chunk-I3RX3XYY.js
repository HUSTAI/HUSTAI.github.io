import { sliderProps, Slider } from './chunk-LOOCLFQO.js';
import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { formatSpokenTime, formatTime } from './chunk-JY53PGKC.js';
import { round } from './chunk-CVLY5S52.js';
import { ClassManager } from './chunk-UHECQU42.js';
import { onTrackChapterChange } from './chunk-NOPW2CG3.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-HQQTSFXD.js';
import { $$_computed, $$_peek, $$_clone, $$_effect, $$_attr, $$_insert_lite, $$_create_template } from 'maverick.js/dom';
import { signal, provideContext, effect, peek, computed, onDispose } from 'maverick.js';
import { defineElement, defineProp } from 'maverick.js/element';
import { listenEvent, setAttribute, isNull, animationFrameThrottle } from 'maverick.js/std';

var $$_templ = /* @__PURE__ */ $$_create_template(`<div part="chapters"></div>`);
var $$_templ_2 = /* @__PURE__ */ $$_create_template(`<div part="chapter-container"><div part="chapter"><div part="track"></div><div part="track track-fill" style="width: 0%"></div><div part="track track-progress" style="width: 0%"></div></div></div>`);
var SliderChaptersRenderer = class {
  constructor(_media, _slider, _onChange) {
    this.a = _media;
    this.N = _slider;
    this.o = _onChange;
    this.B = [];
    this.ga = [];
    this.Y = 0;
    this.Nc = 0;
    this.th = animationFrameThrottle((bufferedPercent) => {
      let width;
      for (let i = this.Nc; i < this.ga.length; i++) {
        width = this.Oc(this.B[i], bufferedPercent);
        this.rh(this.ga[i]).style.width = width + "%";
        if (width < 100) {
          this.Nc = i;
          break;
        }
      }
    });
    this.uh = computed(this.vh.bind(this));
  }
  render(cues, $class) {
    return cues?.length ? $$_peek(
      () => (() => {
        const $$_root = $$_clone($$_templ);
        $$_effect(() => $$_attr($$_root, "class", $class()));
        $$_insert_lite($$_root, () => this.kh(cues));
        return $$_root;
      })()
    ) : null;
  }
  kh(cues) {
    this.B = this.lh(cues);
    const firstChapter = this.B[0];
    this.o(firstChapter.startTime === 0 ? firstChapter.text : "");
    for (let i = 0; i < this.B.length; i++)
      this.ga.push(this.mh());
    this.nh();
    effect(this.oh.bind(this));
    effect(this.ph.bind(this));
    effect(this.qh.bind(this));
    onDispose(() => {
      this.ga = [];
      this.Y = 0;
      this.Nc = 0;
    });
    return this.ga;
  }
  mh() {
    return $$_clone($$_templ_2);
  }
  le(container) {
    return container.firstChild.firstChild.nextSibling;
  }
  rh(container) {
    return container.firstChild.lastChild;
  }
  sh() {
    return this.B[this.B.length - 1].endTime;
  }
  nh() {
    let cue, endTime = this.sh();
    for (let i = 0; i < this.B.length; i++) {
      cue = this.B[i];
      this.ga[i].style.width = round((cue.endTime - cue.startTime) / endTime * 100, 3) + "%";
    }
  }
  oh() {
    let { fillPercent, value, pointing } = this.N, currentChapter = this.B[this.Y], activeIndex = this.me(
      currentChapter.startTime <= peek(value) ? this.Y : 0,
      fillPercent()
    );
    if (activeIndex > this.Y) {
      this.ne(this.Y, activeIndex, "100%");
    } else if (activeIndex < this.Y) {
      this.ne(activeIndex + 1, this.Y + 1, "0%");
    }
    if (!peek(pointing) && this.Y !== activeIndex) {
      this.o(this.B[activeIndex].text);
    }
    let trackFill = this.le(this.ga[activeIndex]), percent = this.Oc(this.B[activeIndex], fillPercent()) + "%";
    if (trackFill.style.width !== percent)
      trackFill.style.width = percent;
    this.Y = activeIndex;
  }
  ph() {
    let { pointing, pointerPercent } = this.N;
    if (!pointing())
      return;
    const activeIndex = this.me(0, pointerPercent());
    this.o(this.B[activeIndex].text);
  }
  ne(start, end, width) {
    for (let i = start; i < end; i++)
      this.le(this.ga[i]).style.width = width;
  }
  me(startIndex, percent) {
    let chapterPercent = 0;
    for (let i = startIndex; i < this.B.length; i++) {
      chapterPercent = this.Oc(this.B[i], percent);
      if (chapterPercent >= 0 && chapterPercent < 100)
        return i;
    }
    return 0;
  }
  qh() {
    this.th(this.uh());
  }
  vh() {
    const { bufferedEnd, duration } = this.a;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;
  }
  Oc(cue, percent) {
    const lastChapter = this.B[this.B.length - 1], startPercent = cue.startTime / lastChapter.endTime * 100, endPercent = cue.endTime / lastChapter.endTime * 100;
    return Math.max(
      0,
      round(
        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,
        3
      )
    );
  }
  lh(cues) {
    const chapters = [];
    for (let i = 0; i < cues.length - 1; i++) {
      const currentCue = cues[i], nextCue = cues[i + 1];
      chapters.push(currentCue);
      if (nextCue) {
        const timeDiff = nextCue.startTime - currentCue.endTime;
        if (timeDiff > 0) {
          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, ""));
        }
      }
    }
    chapters.push(cues[cues.length - 1]);
    return chapters;
  }
};

// src/player/ui/sliders/time-slider/time-slider.tsx
var TimeSlider = class extends Slider {
  constructor(instance) {
    super(instance);
    this.xc = true;
    this.Kg = true;
    this.m = signal(null);
    this.Rc = false;
    // -------------------------------------------------------------------------------------------
    // Chapters
    // -------------------------------------------------------------------------------------------
    this.ib = null;
    this.qe = signal("");
    provideContext(sliderValueFormatContext, {
      value: this.wh.bind(this),
      time: this.xh.bind(this)
    });
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "aria-label", "Media time");
    super.onAttach(el);
    this.oe = new SliderChaptersRenderer(
      this.a.$store,
      this.$store,
      this.qe.set
    );
    this.setAttributes({
      "data-chapters": this.yh.bind(this)
    });
    this.setStyles({
      "--media-buffered-percent": this.zh.bind(this)
    });
    effect(this.Ma.bind(this));
    effect(this.Ah.bind(this));
    effect(this.Qc.bind(this));
    scopedRaf(() => {
      effect(this.Bh.bind(this));
    });
  }
  zh() {
    const { bufferedEnd, duration } = this.a.$store;
    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + "%";
  }
  yh() {
    const { duration } = this.a.$store;
    this.pe?.Mc();
    return this.m()?.cues.length && Number.isFinite(duration()) && duration() > 0;
  }
  onConnect(el) {
    super.onConnect(el);
    this.oa();
    listenEvent(this.a.textTracks, "mode-change", this.oa.bind(this));
    const { chapterContainerClass, chapterClass, trackClass, trackFillClass, trackProgressClass } = this.$props;
    this.pe = new ClassManager(el).u('[part="chapter-container"]', chapterContainerClass).u('[part="chapter"]', chapterClass).u('[part="track"]', trackClass).u('[part~="track-fill"]', trackFillClass).u('[part~="track-progress"]', trackProgressClass);
  }
  render() {
    const tracks = super.render(), { chaptersClass } = this.$props;
    return [$$_computed(() => this.oe.render(this.m()?.cues, chaptersClass)), tracks];
  }
  Ah() {
    this.Pc = functionThrottle(
      this.ca.bind(this),
      this.$props.seekingRequestThrottle()
    );
  }
  Ma() {
    const { currentTime } = this.a.$store, { value, dragging } = this.$store, newValue = this.Ch(currentTime());
    if (!peek(dragging)) {
      value.set(newValue);
      this.dispatch("value-change", { detail: newValue });
    }
  }
  Bh() {
    const player = this.a.player;
    player && this.T && setAttribute(player, "data-preview", this.$store.interactive());
  }
  ca(time, event) {
    this.a.remote.seeking(time, event);
  }
  Dh(time, percent, event) {
    this.Pc.cancel();
    const { live } = this.a.$store;
    if (live() && percent >= 99) {
      this.a.remote.seekToLiveEdge(event);
      return;
    }
    this.a.remote.seek(time, event);
  }
  be(event) {
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging()) {
      const { paused } = this.a.$store;
      this.Rc = !paused();
      this.a.remote.pause(event);
    }
  }
  uc(event) {
    this.Pc(this.hb(event.detail), event);
  }
  vc(event) {
    const percent = event.detail;
    this.Dh(this.hb(percent), percent, event);
    const { pauseWhileDragging } = this.$props;
    if (pauseWhileDragging() && this.Rc) {
      this.a.remote.play(event);
      this.Rc = false;
    }
  }
  tc(event) {
    const { dragging } = this.$store;
    if (dragging() || !event.trigger)
      return;
    this.vc(event);
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  Eb() {
    const value = this.$props.step() / this.a.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  ee() {
    const value = this.$props.keyStep() / this.a.$store.duration() * 100;
    return Number.isFinite(value) ? value : 1;
  }
  ae(value) {
    return round(value, 3);
  }
  p() {
    const { canSeek } = this.a.$store;
    return super.p() || !canSeek();
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  Ac() {
    return 0;
  }
  Bc() {
    return 100;
  }
  fe() {
    const time = this.hb(this.$store.value()), { duration } = this.a.$store;
    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : "live";
  }
  // -------------------------------------------------------------------------------------------
  // Format
  // -------------------------------------------------------------------------------------------
  hb(percent) {
    const { duration } = this.a.$store;
    return Math.round(percent / 100 * duration());
  }
  Ch(time) {
    const { liveEdge, duration } = this.a.$store, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));
    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;
  }
  wh(percent) {
    const time = this.hb(percent), { live, duration } = this.a.$store;
    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : "LIVE";
  }
  xh(percent, padHours, padMinutes, showHours) {
    const time = this.hb(percent), { live, duration } = this.a.$store, value = live() ? time - duration() : time;
    return Number.isFinite(time) ? `${value < 0 ? "-" : ""}${formatTime(
      Math.abs(value),
      padHours,
      isNull(padMinutes) ? Math.abs(value) >= 3600 : padMinutes,
      showHours
    )}` : "LIVE";
  }
  oa() {
    onTrackChapterChange(this.a.textTracks, peek(this.m), this.m.set);
  }
  Qc() {
    this.m();
    this.ib = this.el?.querySelector('[part="chapter-title"]') ?? null;
    if (!this.ib)
      return;
    effect(this.Eh.bind(this));
    return () => {
      this.ib.textContent = "";
      this.ib = null;
    };
  }
  Eh() {
    this.ib.textContent = this.qe();
  }
};
TimeSlider.el = defineElement({
  tagName: "media-time-slider",
  props: {
    ...sliderProps,
    min: defineProp({ value: 0, attribute: false }),
    max: defineProp({ value: 100, attribute: false }),
    value: defineProp({ value: 0, attribute: false }),
    pauseWhileDragging: false,
    seekingRequestThrottle: 100,
    chaptersClass: null,
    chapterContainerClass: null,
    chapterClass: null
  },
  store: SliderStoreFactory
});

export { TimeSlider };
