import { findActiveCue } from './chunk-NOPW2CG3.js';
import { $ariaBool } from './chunk-EVP5E6AO.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { $$_create_walker, $$_effect, $$_attr, $$_listen, $$_ref, $$_create_template } from 'maverick.js/dom';
import { signal, effect, peek } from 'maverick.js';
import { defineElement, Component } from 'maverick.js/element';
import { animationFrameThrottle } from 'maverick.js/std';

var $$_templ = /* @__PURE__ */ $$_create_template(`<!$><img part="img" loading="eager" decoding="async" aria-hidden="true" />`);
var Thumbnail = class extends Component {
  constructor(instance) {
    super(instance);
    this.sa = null;
    this.Fb = null;
    this.Cc = [];
    this.fa = signal("");
    this.Dc = signal(false);
    this.Ec = signal(null);
    this.he = animationFrameThrottle(this.eh.bind(this));
    this.a = useMedia();
  }
  onAttach() {
    this.setAttributes({
      "data-loading": this.Fc.bind(this),
      "aria-hidden": $ariaBool(this.z.bind(this))
    });
  }
  onConnect() {
    effect(this.ka.bind(this));
    effect(this.$g.bind(this));
    effect(this.ah.bind(this));
  }
  ka() {
    this.fa();
    this.a.$store.thumbnails();
    this.Dc.set(false);
  }
  ac() {
    this.Dc.set(true);
    this.he();
  }
  Fc() {
    return !this.z() && !this.Dc();
  }
  z() {
    const { duration, thumbnailCues } = this.a.$store;
    return !Number.isFinite(duration()) || thumbnailCues().length === 0;
  }
  $g() {
    const { time } = this.$props, { duration, thumbnailCues } = this.a.$store, _cues = thumbnailCues(), _time = time();
    if (!_cues || !Number.isFinite(duration())) {
      this.Ec.set(null);
      return;
    }
    this.Ec.set(findActiveCue(_time, _cues));
  }
  bh(el) {
    this.sa = el;
  }
  ah() {
    const activeCue = this.Ec(), thumbnails = peek(this.a.$store.thumbnails);
    if (!thumbnails || !activeCue) {
      this.fa.set("");
      this.ie();
      return;
    }
    const [_src, _coords = ""] = (activeCue.text || "").split("#");
    this.Fb = this.ch(_coords);
    if (!this.Fb) {
      this.ie();
      return;
    }
    this.fa.set(this.dh(thumbnails, _src));
    this.he();
  }
  dh(baseURL, src) {
    return !/https?:/.test(src) ? `${baseURL.split("/").slice(0, -1).join("/")}${src.replace(/^\/?/, "/")}`.replace(
      /^\/\//,
      "/"
    ) : src;
  }
  ch(coords) {
    const [props, values] = coords.split("="), resolvedCoords = {}, coordValues = values?.split(",");
    if (!props || !values)
      return null;
    for (let i = 0; i < props.length; i++)
      resolvedCoords[props[i]] = +coordValues[i];
    return resolvedCoords;
  }
  eh() {
    if (!this.sa || !this.Fb || !this.el)
      return;
    const { w, h, x, y } = this.Fb, { maxWidth, maxHeight, minWidth, minHeight } = getComputedStyle(this.el), minRatio = Math.max(parseInt(minWidth) / w, parseInt(minHeight) / h), maxRatio = Math.min(parseInt(maxWidth) / w, parseInt(maxHeight) / h), scale = maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;
    this.fb(this.el, "--thumbnail-width", `${w * scale}px`);
    this.fb(this.el, "--thumbnail-height", `${h * scale}px`);
    this.fb(this.sa, "width", `${this.sa.naturalWidth * scale}px`);
    this.fb(this.sa, "height", `${this.sa.naturalHeight * scale}px`);
    this.fb(this.sa, "transform", `translate(-${x * scale}px, -${y * scale}px)`);
  }
  fb(el, name, value) {
    el.style.setProperty(name, value);
    this.Cc.push(() => el.style.removeProperty(name));
  }
  ie() {
    for (const reset of this.Cc)
      reset();
    this.Cc = [];
  }
  render() {
    const { crossorigin } = this.a.$store;
    return (() => {
      const [$$_root, $$_walker] = $$_create_walker($$_templ);
      $$_effect(() => $$_attr($$_root, "src", this.fa()));
      $$_effect(() => $$_attr($$_root, "crossorigin", crossorigin()));
      $$_listen($$_root, "load", this.ac.bind(this));
      $$_ref($$_root, this.bh.bind(this));
      return $$_root;
    })();
  }
};
Thumbnail.el = defineElement({
  tagName: "media-thumbnail",
  props: { time: 0 }
});

export { Thumbnail };
