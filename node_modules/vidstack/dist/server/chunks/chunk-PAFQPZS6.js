import { sliderValueFormatContext } from './chunk-U43VNZZW.js';
import { SliderStoreFactory } from './chunk-53B74NMI.js';
import { functionThrottle } from './chunk-JELAJF2G.js';
import { IS_SAFARI } from './chunk-M727CDUQ.js';
import { round, clampNumber, getNumberOfDecimalPlaces } from './chunk-N2X5VJTG.js';
import { setAttributeIfEmpty, scopedRaf } from './chunk-JTTKMFDW.js';
import { useMedia } from './chunk-ZIBTY3GT.js';
import { FocusVisibleController } from './chunk-RLGAJ5QB.js';
import { $$_ssr, $$_classes } from 'maverick.js/ssr';
import { provideContext, effect, peek } from 'maverick.js';
import { defineElement, Component, ComponentController } from 'maverick.js/element';
import { animationFrameThrottle, setStyle, ariaBool, listenEvent, isNull, isNumber, isDOMEvent, isKeyboardEvent, isUndefined } from 'maverick.js/std';

// src/player/ui/sliders/slider/api/props.ts
var sliderProps = {
  min: 0,
  max: 100,
  disabled: false,
  value: 100,
  step: 1,
  keyStep: 1,
  shiftKeyMultiplier: 5,
  trackClass: null,
  trackFillClass: null,
  trackProgressClass: null,
  thumbContainerClass: null,
  thumbClass: null
};

// src/player/ui/sliders/slider/utils.ts
function getClampedValue(min, max, value, step) {
  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);
}
function getValueFromRate(min, max, rate, step) {
  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * stepRatio;
  return min + steps;
}

// src/player/ui/sliders/slider/events-controller.ts
var SliderKeyDirection = {
  Left: -1,
  ArrowLeft: -1,
  Up: 1,
  ArrowUp: 1,
  Right: 1,
  ArrowRight: 1,
  Down: -1,
  ArrowDown: -1
};
var SliderEventsController = class extends ComponentController {
  constructor(instance, _delegate, _media) {
    super(instance);
    this._delegate = _delegate;
    this._media = _media;
    this._outlet = null;
    this._touchX = null;
    this._touchStartValue = null;
    this._thumb = null;
    this._trackFill = null;
    this._onDocumentPointerMove = functionThrottle(
      (event) => {
        this._updatePointerValue(this._getPointerValue(event), event);
      },
      20,
      { leading: true }
    );
  }
  onConnect() {
    effect(this._attachEventListeners.bind(this));
    effect(this._attachPointerListeners.bind(this));
    if (this._delegate._swipeGesture) {
      scopedRaf(() => {
        var _a;
        const outlet = (_a = this._media.player) == null ? void 0 : _a.querySelector("media-outlet");
        if (outlet) {
          this._outlet = outlet;
          listenEvent(outlet, "touchstart", this._onTouchStart.bind(this));
          listenEvent(outlet, "touchmove", this._onTouchMove.bind(this));
        }
      });
    }
  }
  _onTouchStart(event) {
    this._touchX = event.touches[0].clientX;
  }
  _onTouchMove(event) {
    if (isNull(this._touchX))
      return;
    event.preventDefault();
    if (this.$store.dragging())
      return;
    const diff = event.touches[0].clientX - this._touchX;
    if (Math.abs(diff) > 20) {
      this._touchX = event.touches[0].clientX;
      this._touchStartValue = this.$store.value();
      this._onStartDragging(this._touchStartValue, event);
    }
  }
  _attachEventListeners() {
    if (this._delegate._isDisabled())
      return;
    this.listen("focus", this._onFocus.bind(this));
    this.listen("pointerenter", this._onPointerEnter.bind(this));
    this.listen("pointermove", this._onPointerMove.bind(this));
    this.listen("pointerleave", this._onPointerLeave.bind(this));
    this.listen("pointerdown", this._onPointerDown.bind(this));
    this.listen("keydown", this._onKeyDown.bind(this));
    this.listen("keyup", this._onKeyUp.bind(this));
  }
  _attachPointerListeners() {
    if (this._delegate._isDisabled() || !this.$store.dragging())
      return;
    listenEvent(document, "pointerup", this._onDocumentPointerUp.bind(this));
    listenEvent(document, "pointermove", this._onDocumentPointerMove.bind(this));
    if (IS_SAFARI) {
      listenEvent(document, "touchmove", this._onDocumentTouchMove.bind(this), {
        passive: false
      });
    }
  }
  _onFocus() {
    this._updatePointerValue(this.$store.value());
  }
  _updateValue(newValue, trigger) {
    const { value, min, max, dragging } = this.$store;
    const clampedValue = Math.max(min(), Math.min(newValue, max()));
    value.set(clampedValue);
    const event = this.createEvent("value-change", { detail: clampedValue, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onValueChange(event);
    if (dragging()) {
      const event2 = this.createEvent("drag-value-change", { detail: clampedValue, trigger });
      this.el.dispatchEvent(event2);
      this._delegate._onDragValueChange(event2);
    }
  }
  _updatePointerValue(value, trigger) {
    var _a;
    const { pointerValue, dragging } = this.$store;
    pointerValue.set(value);
    this.dispatch("pointer-value-change", { detail: value, trigger });
    if (dragging()) {
      const dir = this._delegate._orientation === "vertical" ? "bottom" : "left", size = this._delegate._orientation === "vertical" ? "height" : "width";
      if (this._trackFill && !((_a = this.el) == null ? void 0 : _a.hasAttribute("data-chapters"))) {
        this._trackFill.style[size] = value + "%";
      }
      if (this._thumb) {
        this._thumb.style[dir] = value + "%";
      }
      this._updateValue(value, trigger);
    }
  }
  _getPointerValue(event) {
    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$store;
    if (this._delegate._orientation === "vertical") {
      const { bottom: trackBottom, height: trackHeight } = rect;
      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;
    } else {
      if (this._touchX && isNumber(this._touchStartValue)) {
        const { width } = this._outlet.getBoundingClientRect(), rate = (event.clientX - this._touchX) / width, range = max() - min(), diff = range * Math.abs(rate);
        thumbPositionRate = (rate < 0 ? this._touchStartValue - diff : this._touchStartValue + diff) / range;
      } else {
        const { left: trackLeft, width: trackWidth } = rect;
        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;
      }
    }
    return Math.max(
      min(),
      Math.min(
        max(),
        this._delegate._roundValue(
          getValueFromRate(min(), max(), thumbPositionRate, this._delegate._getStep())
        )
      )
    );
  }
  _onPointerEnter(event) {
    this.$store.pointing.set(true);
  }
  _onPointerMove(event) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    this._updatePointerValue(this._getPointerValue(event), event);
  }
  _onPointerLeave(event) {
    this.$store.pointing.set(false);
  }
  _onPointerDown(event) {
    if (event.button !== 0)
      return;
    const value = this._getPointerValue(event);
    this._onStartDragging(value, event);
    this._updatePointerValue(value, event);
  }
  _onStartDragging(value, trigger) {
    const { dragging } = this.$store;
    if (dragging())
      return;
    dragging.set(true);
    this._thumb = this.el.querySelector(
      'shadow-root > div[part="thumb-container"]'
    );
    this._trackFill = this.el.querySelector(
      'shadow-root > div[part~="track-fill"]'
    );
    this._media.remote.pauseUserIdle(trigger);
    const event = this.createEvent("drag-start", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onDragStart(event);
  }
  _onStopDragging(value, trigger) {
    const { dragging } = this.$store;
    if (!dragging())
      return;
    dragging.set(false);
    if (this._trackFill) {
      setStyle(this._trackFill, "width", null);
      this._trackFill = null;
    }
    if (this._thumb) {
      setStyle(this._thumb, "left", null);
      setStyle(this._thumb, "bottom", null);
      this._thumb = null;
    }
    this._media.remote.resumeUserIdle(trigger);
    const event = this.createEvent("drag-end", { detail: value, trigger });
    this.el.dispatchEvent(event);
    this._delegate._onDragEnd(event);
    this._touchX = null;
    this._touchStartValue = null;
  }
  _onKeyDown(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    const { key } = event;
    const { min, max } = this.$store;
    let newValue;
    if (key === "Home" || key === "PageUp") {
      newValue = min();
    } else if (key === "End" || key === "PageDown") {
      newValue = max();
    } else if (!event.metaKey && /[0-9]/.test(key)) {
      newValue = (max() - min()) / 10 * Number(key);
    }
    if (!isUndefined(newValue)) {
      this._updatePointerValue(newValue, event);
      this._updateValue(newValue, event);
      return;
    }
    const value = this._getKeyValue(event);
    if (!value)
      return;
    const repeat = key === this._lastDownKey;
    if (!this.$store.dragging() && repeat)
      this._onStartDragging(value, event);
    this._updatePointerValue(value, event);
    if (!repeat)
      this._updateValue(value, event);
    this._lastDownKey = key;
  }
  _onKeyUp(event) {
    if (isDOMEvent(event)) {
      const trigger = event.trigger;
      if (isKeyboardEvent(trigger))
        event = trigger;
      else
        return;
    }
    this._lastDownKey = "";
    const { dragging, value } = this.$store;
    if (!dragging())
      return;
    const newValue = this._getKeyValue(event) ?? value();
    this._updatePointerValue(newValue);
    this._onStopDragging(newValue, event);
  }
  _getKeyValue(event) {
    const { key, shiftKey } = event, isValidKey = Object.keys(SliderKeyDirection).includes(key);
    if (!isValidKey)
      return;
    const { shiftKeyMultiplier } = this.$props;
    const { value } = this.$store, step = this._delegate._getStep(), keyStep = this._delegate._getKeyStep();
    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, steps = (value() + diff) / step;
    return Number((step * steps).toFixed(3));
  }
  // -------------------------------------------------------------------------------------------
  // Document (Pointer Events)
  // -------------------------------------------------------------------------------------------
  _onDocumentPointerUp(event) {
    if (event.button !== 0)
      return;
    const value = this._getPointerValue(event);
    this._updatePointerValue(value, event);
    this._onStopDragging(value, event);
  }
  _onDocumentTouchMove(event) {
    event.preventDefault();
  }
};

// src/player/ui/sliders/slider/slider.tsx
var $$_templ = ['<!$><div part="track"', "></div>"];
var $$_templ_2 = ['<!$><div part="track track-fill"', "></div>"];
var $$_templ_3 = ['<!$><div part="track track-progress"', "></div>"];
var $$_templ_4 = ['<!$><div part="thumb-container"', '><!$><div part="thumb"', "></div></div>"];
var Slider = class extends Component {
  constructor(instance) {
    super(instance);
    this._readonly = false;
    this._orientation = "";
    this._updateSliderVars = animationFrameThrottle(
      (fillPercent, pointerPercent) => {
        var _a, _b;
        (_a = this.el) == null ? void 0 : _a.style.setProperty("--slider-fill-percent", fillPercent + "%");
        (_b = this.el) == null ? void 0 : _b.style.setProperty("--slider-pointer-percent", pointerPercent + "%");
      }
    );
    // -------------------------------------------------------------------------------------------
    // Preview
    // -------------------------------------------------------------------------------------------
    this._preview = null;
    this._onPreviewResize = animationFrameThrottle(() => {
      if (!this._preview)
        return;
      const rect = this._preview.getBoundingClientRect();
      setStyle(this._preview, "--computed-width", rect.width + "px");
      setStyle(this._preview, "--computed-height", rect.height + "px");
    });
    provideContext(sliderValueFormatContext);
    this._media = useMedia();
    new SliderEventsController(instance, this, this._media);
    const focus = new FocusVisibleController(instance);
    this.$store.focused = focus.focused.bind(focus);
  }
  onAttach(el) {
    setAttributeIfEmpty(el, "role", "slider");
    setAttributeIfEmpty(el, "tabindex", "0");
    setAttributeIfEmpty(el, "aria-orientation", "horizontal");
    setAttributeIfEmpty(el, "autocomplete", "off");
    this._orientation = el.getAttribute("aria-orientation") || "";
    if (!this._readonly) {
      effect(this._watchMinMax.bind(this));
      effect(this._watchDisabled.bind(this));
    }
    effect(this._watchValue.bind(this));
    this._setAttrs();
  }
  onConnect(el) {
    this._setupPreview();
  }
  render() {
    const { trackClass, trackFillClass, trackProgressClass, thumbContainerClass, thumbClass } = this.$props;
    return [
      $$_ssr($$_templ, $$_classes(trackClass)),
      $$_ssr($$_templ_2, $$_classes(trackFillClass)),
      $$_ssr($$_templ_3, $$_classes(trackProgressClass)),
      $$_ssr($$_templ_4, $$_classes(thumbContainerClass), $$_classes(thumbClass))
    ];
  }
  // -------------------------------------------------------------------------------------------
  // Props
  // -------------------------------------------------------------------------------------------
  _getStep() {
    return this.$props.step();
  }
  _getKeyStep() {
    return this.$props.keyStep();
  }
  _roundValue(value) {
    return Math.round(value);
  }
  _isDisabled() {
    return this.$props.disabled();
  }
  // -------------------------------------------------------------------------------------------
  // Watch
  // -------------------------------------------------------------------------------------------
  _watchMinMax() {
    const { min, max } = this.$props;
    this.$store.min.set(min());
    this.$store.max.set(max());
  }
  _watchDisabled() {
    if (!this._isDisabled())
      return;
    const { dragging, pointing } = this.$store;
    dragging.set(false);
    pointing.set(false);
  }
  _watchValue() {
    const { dragging, value, min, max } = this.$store;
    if (peek(dragging))
      return;
    value.set(getClampedValue(min(), max(), value(), this._getStep()));
  }
  // -------------------------------------------------------------------------------------------
  // ARIA
  // -------------------------------------------------------------------------------------------
  _getARIADisabled() {
    return ariaBool(this._isDisabled());
  }
  _getARIAValueMin() {
    return this.$props.min();
  }
  _getARIAValueMax() {
    return this.$props.max();
  }
  _getARIAValueNow() {
    const { value } = this.$store;
    return Math.round(value());
  }
  _getARIAValueText() {
    const { value, max } = this.$store;
    return round(value() / max() * 100, 2) + "%";
  }
  // -------------------------------------------------------------------------------------------
  // Attributes
  // -------------------------------------------------------------------------------------------
  _setAttrs() {
    const { disabled } = this.$props, { dragging, interactive, pointing } = this.$store;
    this.setAttributes({
      disabled,
      "data-dragging": dragging,
      "data-pointing": pointing,
      "data-interactive": interactive,
      "aria-disabled": this._getARIADisabled.bind(this),
      "aria-valuemin": this._getARIAValueMin.bind(this),
      "aria-valuemax": this._getARIAValueMax.bind(this),
      "aria-valuenow": this._getARIAValueNow.bind(this),
      "aria-valuetext": this._getARIAValueText.bind(this),
      "data-styled": this._isStyled.bind(this),
      "data-media-slider": true
    });
    this._watchCSSVars();
  }
  _isStyled() {
    return !!this.$props.trackClass();
  }
  _watchCSSVars() {
    const { fillPercent, pointerPercent } = this.$store;
    this._updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));
  }
  _setupPreview() {
    this._preview = this.el.querySelector('[slot="preview"]');
    if (!this._preview)
      return;
    effect(this._watchPreview.bind(this));
    import('./preview-JJG3ZTKT.js').then(({ setupPreviewStyles }) => {
      setupPreviewStyles(this._preview, this._orientation);
    });
  }
  _watchPreview() {
    if (this._isDisabled() || !this._preview)
      return;
    window.requestAnimationFrame(this._onPreviewResize);
    const observer = new ResizeObserver(this._onPreviewResize);
    observer.observe(this._preview);
    return () => observer.disconnect();
  }
  // -------------------------------------------------------------------------------------------
  // Events
  // -------------------------------------------------------------------------------------------
  _onValueChange(event) {
  }
  _onDragStart(event) {
  }
  _onDragEnd(event) {
  }
  _onDragValueChange(event) {
  }
};
Slider.el = defineElement({
  tagName: "media-slider",
  props: sliderProps,
  store: SliderStoreFactory
});

export { Slider, sliderProps };
