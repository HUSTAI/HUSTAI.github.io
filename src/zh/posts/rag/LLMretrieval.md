---
author: 猞猁-zlj
icon: blog
date: 2023-09-07
shortTitle: "大模型外挂知识库优化"
category:
  - rag
tag:
  - LLM
  - 检索
  - rag
---

# 如何通过大模型实现外挂知识库优化

大模型时代，通常采用向量召回的方式从文档库里召回和用户问题相关的文档片段，输入到LLM中来增强模型回答质量。本文分享两篇通过大模型的能力增强召回效果的文章，这两篇文章的内容都已经加入了langchain的标准组件，但是**都有一些特定的使用场景**。
<!-- more -->
HYDE：[https://arxiv.org/abs/2212.10496](https://arxiv.org/abs/2212.10496)
FLARE：[https://arxiv.org/abs/2305.06983](https://arxiv.org/abs/2305.06983)
知乎：[https://zhuanlan.zhihu.com/p/653808554](https://zhuanlan.zhihu.com/p/653808554)

## 1 HYDE[1]

### 1.1 框架介绍

这篇文章是篇纯讨论召回的文章，最后的衡量指标也是nDCG和召回率这些指标，使用LLM单纯是为了提高召回效果的。

![图1.1 HYDE框架图](/assets/images/token/LLMretrieval1.png "图1.1 HYDE框架图")

论文思路非常简单：

- Step1: 用LLM根据用户query生成k个“假答案”。
- Step2: 利用向量化模型，将生成的k的假答案和用户的query变成向量。
- Step3: 根据公式1.1，将k+1个向量取平均：其中dk为第k个生成的答案，q为用户问题，f为向量化操作。

$$
\hat{\mathbf{v}}_{q_{i j}}=\frac{1}{N+1}\left[\sum_{k=1}^{N} f\left(\hat{d}_{k}\right)+f\left(q_{i j}\right)\right]
\tag {1.1}
$$

- Step4: 利用融合向量v从文档库中召回答案。融合向量中既有用户问题的信息，也有想要答案的模式信息，可以增强召回效果。

### 1.2 实验结果

模型有上标FT指的是向量化模型在TREC DL相关的数据集上微调过的。黄框标出来的是未使用hyde技术的baseline结果。绿框标出来的是未微调的向量化模型使用hyde技术的实验结果。红框标出来的是微调过的向量化模型使用hyde技术的实验结果。

![表1.1 实验结果](/assets/images/token/LLMretrieval2.png "表1.1 实验结果")

$$
N D C G @ n=\frac{1}{N} \sum_{i=1}^{n} \frac{G}{D}
\tag {1.2}
$$

实验指标为NDCG@10，可以发现，对于没有微调过的向量户化模型（zero shot场景），hyde还是非常有用的，并且随着使用的LLM模型的增大，效果不断变好（因为LLM的回答质量提高了）。因为领域微调过的向量化模型性能已经不错了，NDCG@10指标能达到60多，**LLM生成的假答案的知识性错误带来的负面影响大于回答模式信息带来的正面影响。**

## 2 FLARE[2]

和上一篇文章相比，FLARE论文评估的指标是直接看最后LLM的回答效果的，而非是向第一篇文章那样只讨论召回准确率。这篇文章涉及到针对同一个问题的**多次召回**，因此比较适合长文本回答。对于大模型外挂知识库，大家通常的做法是根据用户query一次召回文档片段，让模型生成答案。只进行一次文档召回在长文本生成的场景下效果往往不好，生成的文本过长，更有可能扩展出和query相关性较弱的内容，如果模型没有这部分知识，容易产生模型幻觉问题。一种解决思路是随着文本生成，多次从向量库中召回内容。
有三种常用的多次召回策略：

- a. 每生成固定的n个token就召回一次。
- b. 每生成一个完整的句子就召回一次。
- c. 将用户query一步步分解为子问题，需要解答当前子问题时候，就召回一次。

已有的多次召回方案比较被动，召回文档的目的是为了得到模型不知道的信息，a、b策略并不能保证不需要召回的时候不召回，需要召回的时候触发召回。c.方案需要设计特定的prompt工程，限制了其通用性。作者在本文里提出了两种更主动的多次召回策略，让模型自己决定啥时候触发召回操作。

### 2.1 策略1-让模型自己决定

通过设计prompt以及提供示例的方式，让模型知道当遇到需要查询知识的时候，提出问题，并按照格式输出，和toolformer的模式类似。**提出问题的格式为[Search(“模型自动提出的问题”)]**。利用模型生成的问题去召回答案。召回出答案后，将答案放到用户query的前边，然后去掉主动召回标识之后，继续生成。当下一次生成主动召回标识之后，将上一次召回出来的内容从prompt中去掉。下图展示了生成拜登相关答案时，触发多次召回的例子，分别面对拜登在哪上学和获得了什么学位的知识点上进行了主动召回标识的生成。

![图2.1 策略1示意图](/assets/images/token/LLMretrieval3.png "图2.1 策略1示意图")

该方法也存在一些缺陷：

- 1.LLM不愿意生成主动召回标识。解决方法：对"["对应的logit乘2，增加生成"["的概率，"["为主动召回标识的第一个字，进而促进主动召回标识的生成。
- 2.过于频繁的主动召回可能会影响生成质量。解决方法：在刚生成一次主动召回标识、得到召回后的文档、去掉主动召回标识之后，接下来生成的几个token禁止生成"["。
- 3.不微调该方案不太可靠，很难通过few shot的方式让模型生成这种输出模式。

### 2.2 策略2-根据模型生成的token决定

策略1存在的第3点缺陷比较知名。因此作者提出了另外一个策略。该策略基于一个假设：模型生成的词对应该的概率能够表现生成内容的置信度。（传统的chatgpt接口是用不了策略2的，因为得不到生成每个词的概率。）
分为4个步骤：

- Step0:根据用户的query，进行第一次召回，让模型生成答案。
- Step1:之后，每生成64个token，用NLTK工具包从64个token里边找到第一个完整句子，当作“假答案”，扔掉多余的token。（和第一篇文章思想一样，利用LLM生成符合回答模式的“假答案”）
- Step2:如果“假答案”里有任意一个token对应的概率，低于某一阈值，那么就利用这个句子进行向量召回。将“假答案”中生成概率低于某一阈值的token扔掉（低概率的token很有可能存在错误信息），然后再进行向量召回。
- Step3:利用召回出来的文本，重新生成新的“真答案”，然后进行下一个句子的生成。

依然针对拜登的问题，下图给出了例子。

![图2.2 策略2示意图](/assets/images/token/LLMretrieval4.png "图2.2 策略2示意图")

接下来介绍一下实验结果。先声明一下，这篇文章用的召回器（向量化模型）是BM25，2009年被提出，基于统计学的原理，属于一种词袋模型，效果一般。如果用一些效果更好的基于神经网络的召回器，本文提出的方法提升就没那么大了。

![图2.3 实验结果](/assets/images/token/LLMretrieval5.png "图2.3 实验结果")

## 3 参考

[1] Luyu Gao, Xueguang Ma, Jimmy Lin, Jamie Callan. Precise Zero-Shot Dense Retrieval without Relevance Labels. In: Proceedings of the 61st Annual Meeting of the Association for Computational Linguistics (ACL 2023), Toronto, Canada, July 9-14, 2023, ACL, 2023: 1762–1777
[2] Zhengbao Jiang, Frank F. Xu, Luyu Gao, Zhiqing Sun, Qian Liu, Jane Dwivedi-Yu, et al. Active Retrieval Augmented Generation. arXiv, 2023